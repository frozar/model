<html><head><!-- This document was created from RTF source by rtftohtml version 2.7.4 --><title>Windows Sockets</title></head>
<body bgcolor="#ffffff" link="#0000ff" text="#000000" vlink="#800080">

<h1><img src="winsock_files/winsock.gif" align="bottom"> Windows Sockets</h1>

<h2>An Open Interface for<br>
Network Programming under<br>
Microsoft Windows<br></h2>

<h3>Version 1.1<br>
20 January 1993</h3>

<hr>

<h2>Note</h2>

This HTML version of the Windows Socket 1.1 Specification is provided
by Mark Towfiq.  It may be freely redistributed, either as provided or
in modified form.  Winsock providers may integrate it into their
product documentation without incurring any obligation.

<h2>Acknowledgements</h2>

I am indebted and thankful to:
<ul>

<li> <a href="mailto:joel@infomagic.com">Joel Golberger</a> of
InfoMagic, Inc. for the work he did on the <a href="http://www.sockets.com/winsock.hlp">
Windows Help version</a> of the <a href="http://www.sockets.com/winsock.rtf">Windows Sockets
Specification</a>.  I used <a href="http://www.sockets.com/winsockx.rtf">his .RTF file</a> as
the source file for this document.

</li><li> <a href="mailto:cjh@cray.com">Chris Hector</a> of
Cray Research Inc. for his package
<a href="ftp://ftp.cray.com/src/WWWstuff/RTF/rtftohtml_overview.html">rtftohtml</a>, which was used to generate this document.

</li></ul>

<address>
<a href="http://sunsite.unc.edu/towfiq">Mark Towfiq</a>
<em> (<a href="mailto:towfiq@East.Sun.Com">towfiq@East.Sun.Com</a>) </em>
</address>

<hr>
<h1>Table of Contents</h1>
<ul>
<li><a href="#Authors">Authors and Copyright</a>
</li><li><a href="#Acknowledgements">Acknowledgments</a>
</li><li><a href="#Intro">Introduction</a>
    <ul>
    <li><a href="#WhatIs">What is Windows Sockets</a>
    </li><li><a href="#Berkeley">Berkeley Sockets</a>
    </li><li><a href="#Windows">Microsoft Windows and Windows-specific extensions</a>
    </li><li><a href="#Status">The Status of this Specification</a>
    </li><li><a href="#Revision">Revision History</a>
	<ul>
	<li><a href="#Revision_1.0">Windows Sockets Version 1.0</a>
	</li><li><a href="#Revision_1.1">Windows Sockets Version 1.1</a>
	</li></ul>
    </li></ul>
</li><li><a href="#ProgrammingWithSockets">Programming with Sockets</a>
    <ul>
    <li><a href="#Prog_StackInstall">Windows Sockets Stack Installation Checking</a>
    </li><li><a href="#Prog_Sockets">Sockets</a>
	<ul>
	<li><a href="#Sockets_BasicConcepts">Basic concepts</a>
	</li><li><a href="#Sockets_ClientServer">Client-server model</a>
	</li><li><a href="#Sockets_OutOfBand">Out-of-band data</a>
	</li><li><a href="#Sockets_Broadcasting">Broadcasting</a>
	</li></ul>
    </li><li><a href="#Prog_ByteOrdering">Byte Ordering</a>
    </li><li><a href="#Prog_SocketOptions">Socket Options</a>
    </li><li><a href="#Prog_DatabaseFiles">Database Files</a>
    </li><li><a href="#Prog_Deviation">Deviation from Berkeley Sockets</a>
	<ul>
	<li><a href="#Deviation_DataType">socket data type and error values</a>
	</li><li><a href="#Deviation_Select">select() and FD_*</a>
	</li><li><a href="#Deviation_ErrorCodes">Error codes - errno, h_errno &amp; WSAGetLastError()</a>
	</li><li><a href="#Deviation_Pointers">Pointers</a>
	</li><li><a href="#Deviation_RenamedFunctions">Renamed functions</a>
	</li><li><a href="#Deviation_BlockingRoutines">Blocking routines &amp; EINPROGRESS</a>
	</li><li><a href="#Deviation_MaxSockets">Maximum number of sockets supported</a>
	</li><li><a href="#Deviation_IncludeFiles">Include files</a>
	</li><li><a href="#Deviation_ReturnValues">Return values on API failure</a>
	</li></ul>
    </li><li><a href="#Prog_RawSockets">Raw Sockets</a>
    </li><li><a href="#Prog_MultithreadedWindows">Windows Sockets in Multithreaded Versions of Windows</a>
    </li></ul>
</li><li><a href="#SocketLibraryOverview">Socket Library Overview</a>
    <ul>
    <li><a href="#Overview_SocketFunctions">Socket Functions</a>
	<ul>
	<li><a href="#Overview_BlockingNonBlocking">Blocking/Non blocking &amp; Data Volatility</a>
	</li></ul>
    </li><li><a href="#Overview_DatabaseFunctions">Database Functions</a>
    </li><li><a href="#Overview_WindowsSpecific">Microsoft Windows-specific Extension Functions</a>
	<ul>
	<li><a href="#Windows_AsyncSelect">Asynchronous select() Mechanism</a>
	</li><li><a href="#Windows_AsyncSupport">Asynchronous Support Routines</a>
	</li><li><a href="#Windows_HookingBlocking">Hooking Blocking Methods</a>
	</li><li><a href="#Windows_ErrorHandling">Error Handling</a>
	</li><li><a href="#Windows_Intermediate">Accessing a Windows Sockets DLL from an Intermediate DLL</a>
	</li><li><a href="#Windows_InternalMessages">Internal use of Messages by Windows Sockets Implementations</a>
	</li><li><a href="#Windows_PrivateAPIs">Private API Interfaces</a>
	</li></ul>
    </li></ul>
</li><li><a href="#SocketLibraryReference">Socket Library Reference</a>
    <ul>
    <li><a href="#Ref_SocketRoutines">Socket Routines</a>
	<ul>
	<li><a href="#Accept">accept()</a>
	</li><li><a href="#Bind">bind()</a>
	</li><li><a href="#CloseSocket">closesocket()</a>
	</li><li><a href="#Connect">connect()</a>
	</li><li><a href="#GetPeerName">getpeername()</a>
	</li><li><a href="#GetSockName">getsockname()</a>
	</li><li><a href="#GetSockOpt">getsockopt()</a>
	</li><li><a href="#HtoNL">htonl()</a>
	</li><li><a href="#HtoNS">htons()</a>
	</li><li><a href="#InetAddr">inet_addr()</a>
	</li><li><a href="#InetNtoA">inet_ntoa()</a>
	</li><li><a href="#IOCTLSocket">ioctlsocket()</a>
	</li><li><a href="#Listen">listen()</a>
	</li><li><a href="#NtoHL">ntohl()</a>
	</li><li><a href="#NtoHS">ntohs()</a>
	</li><li><a href="#Recv">recv()</a>
	</li><li><a href="#RecvFrom">recvfrom()</a>
	</li><li><a href="#Select">select()</a>
	</li><li><a href="#Send">send()</a>
	</li><li><a href="#SendTo">sendto()</a>
	</li><li><a href="#SetSockOpt">setsockopt()</a>
	</li><li><a href="#ShutDown">shutdown()</a>
	</li><li><a href="#Socket">socket()</a>
	</li></ul>
    </li><li><a href="#Ref_DatabaseRoutines">Database Routines</a>
	<ul>
	<li><a href="#GetHostByAddr">gethostbyaddr()</a>
	</li><li><a href="#GetHostByName">gethostbyname()</a>
	</li><li><a href="#GetHostName">gethostname()</a>
	</li><li><a href="#GetProtoByName">getprotobyname()</a>
	</li><li><a href="#GetProtoByNumber">getprotobynumber()</a>
	</li><li><a href="#GetServByName">getservbyname()</a>
	</li><li><a href="#GetServByPort">GetServByPort()</a>
	</li></ul>
    </li><li><a href="#Ref_WindowsExtensions">Microsoft Windows-specific Extensions</a>
	<ul>
	<li><a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a>
	</li><li><a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a>
	</li><li><a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a>
	</li><li><a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a>
	</li><li><a href="#AsyncGetServByName">WSAAsyncGetServByName()</a>
	</li><li><a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a>
	</li><li><a href="#AsyncSelect">WSAAsyncSelect()</a>
	</li><li><a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
	</li><li><a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
	</li><li><a href="#Cleanup">WSACleanup()</a>
	</li><li><a href="#GetLastError">WSAGetLastError()</a>
	</li><li><a href="#IsBlocking">WSAIsBlocking()</a>
	</li><li><a href="#SetBlockingHook">WSASetBlockingHook()</a>
	</li><li><a href="#SetLastError">WSASetLastError()</a>
	</li><li><a href="#Startup">WSAStartup()</a>
	</li><li><a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>
	</li></ul>
    </li></ul>
</li><li><a href="#Appendices">Appendices</a>
    <ul>
    <li><a href="#ErrorsAndHeaders">Error Codes and Header Files</a>
	<ul>
	<li><a href="#ErrorCodes">Error Codes</a>
	</li><li><a href="#HeaderFiles">Header Files</a>
	    <ul>
	    <li><a href="#BerkeleyHeaders">Berkeley Header Files</a>
	    </li><li><a href="#WinsockH">Windows Sockets Header File - winsock.h</a>
	    </li></ul>
	</li></ul>
    </li><li><a href="#NotesForSuppliers">Notes for Windows Sockets Suppliers</a>
	<ul>
	<li><a href="#Notes_Introduction">Introduction</a>
	</li><li><a href="#Notes_WindowsComponents">Windows Sockets Components</a>
	    <ul>
	    <li><a href="#NotesComp_Development">Development Components</a>
	    </li><li><a href="#NotesComp_RunTime">Run Time Components</a>
	    </li></ul>
	</li><li><a href="#Notes_Multithreadedness">Multithreadedness and blocking routines.</a>
	</li><li><a href="#Notes_DatabaseFiles">Database Files</a>
	</li><li><a href="#Notes_FDISSET">FD_ISSET</a>
	</li><li><a href="#Notes_ErrorCodes">Error Codes</a>
	</li><li><a href="#Notes_DLLOrdinals">DLL Ordinal Numbers</a>
	</li><li><a href="#Notes_Validation">Validation Suite</a>
	</li></ul>
    </li><li><a href="#FurtherReference">For Further Reference</a>
    </li><li><a href="#Background">Background Information</a>
	<ul>
	<li><a href="#Origins">Origins of Windows Sockets</a>
	</li><li><a href="#LegalStatus">Legal Status of Windows Sockets</a>
	</li><li><a href="#IconStory">The Story Behind the Windows Sockets Icon</a>
	</li></ul>
    </li></ul>
</li></ul>

<hr><h1><a name="Authors">Authors and Copyright</a></h1>

<h2><a href="mailto:MartinH@JSBUS.Com">Martin Hall</a><br>
<a href="mailto:Towfiq@East.Sun.Com">Mark Towfiq</a><br>
<a href="mailto:Geoff@East.Sun.Com">Geoff Arnold</a><br>
<a href="mailto:DavidTr@Microsoft.Com">David Treadwell</a><br>
<a href="mailto:HenrySa@Microsoft.Com">Henry Sanders</a></h2>

<h3>Copyright (c) 1992 by Martin Hall, Mark Towfiq<br>
Geoff Arnold, David Treadwell and Henry Sanders</h3>

<h3>All rights reserved.</h3>

<p>
This document may be freely redistributed in any form, electronic or otherwise,
provided that it is distributed in its entirety and that the copyright and this
notice are included.  Comments or questions may be submitted via electronic
mail to <a href="mailto:WinSock@MailBag.Intel.Com"><i>WinSock@MailBag.Intel.Com</i></a>.  Requests to be added to the Windows
Sockets mailing list should be addressed to <a href="mailto:MajorDomo@MailBag.Intel.Com"><i>MajorDomo@MailBag.Intel.Com</i></a>.
This specification, archives of the mailing list, and other information on
Windows Sockets are available via anonymous FTP from the host
<a href="ftp://sunsite.unc.edu/pub/micro/pc-stuff/ms-windows/winsock"><i>SunSite.UNC.Edu</i>, directory /pub/micro/pc-stuff/ms-windows/winsock</a>.
Questions about products conforming to this specification should be addressed
to the vendors of the products.</p><p>

</p><hr><h1>
<a name="Acknowledgements">Acknowledgments</a></h1>
<p>
The authors would like to thank their companies for allowing them the time and
resources to make this specification possible:  JSB Corporation, Microdyne
Corporation, FTP Software, Sun Microsystems, and Microsoft Corporation.</p><p>

Special thanks should also be extended to the other efforts contributing to the
success of Windows Sockets. The original draft was heavily influenced by
existing specifications offered and detailed by JSB Corporation and NetManage,
Inc. The "version 1.0 debate" hosted by Microsoft in Seattle allowed many of
the members of the working group to hash out final details for 1.0 vis-a-vis.
</p><p>
Sun Microsystems was kind enough to allow first time implementors to "plug and
play" beta software during the first Windows Sock-A-Thon of  Windows Sockets
applications and implementations at Interop Fall '92.  Microsoft has shared
WSAT (the Windows Sockets API Tester) with other Windows Sockets implementors
as a standard Windows Sockets test suite to aid in testing their
implementations. Finally, Sun Microsystems and FTP Software plan to host the
Windows Sock-A-Thon II in Boston February '93. </p><p>

Without the contributions of the individuals and corporations involved in the
working group, Windows Sockets would never have been as thoroughly reviewed and
completed as quickly. In just one year, several competitors in the networking
business developed a useful specification with something to show for it! Many
thanks to all which participated, either in person or on e-mail to the Windows
Sockets effort. The authors would like to thank everyone who participated in
any way, and apologize in advance for anyone we have omitted. </p><p>

List of contributors:</p><p>
</p><pre>
Martin Hall 	(Chairman)	JSB Corporation		<a href="mailto:martinh@jsbus.com">martinh@jsbus.com</a>
<a href="http://sunsite.unc.edu/towfiq">Mark Towfiq</a> 	(Coordinator)	Microdyne Corporation	<a href="mailto:towfiq@east.sun.com">towfiq@microdyne.com</a>
Geoff Arnold 	(Editor 1.0)	Sun Microsystems	<a href="mailto:geoff@east.sun.com">geoff@east.sun.com</a>
David Treadwell	(Editor 1.1)	Microsoft Corporation	<a href="mailto:davidtr@microsoft.com">davidtr@microsoft.com</a>
Henry Sanders			Microsoft Corporation	<a href="mailto:henrysa@microsoft.com">henrysa@microsoft.com</a>
<p>
J. Allard			Microsoft Corporation	<a href="mailto:jallard@microsoft.com">jallard@microsoft.com</a>
Chris Arap-Bologna		Distinct		<a href="mailto:chris@distinct.com">chris@distinct.com</a>
Larry Backman			FTP Software		<a href="mailto:backman@ftp.com">backman@ftp.com</a>
Alistair Banks			Microsoft Corporation	<a href="mailto:alistair@microsoft.com">alistair@microsoft.com</a>
Rob Barrow			JSB Corporation		<a href="mailto:robb@jsb.co.uk">robb@jsb.co.uk</a>
Carl Beame			Beame &amp; Whiteside	<a href="mailto:beame@mcmaster,ca">beame@mcmaster,ca</a>
Dave Beaver			Microsoft Corporation	<a href="mailto:dbeaver@microsoft.com">dbeaver@microsoft.com</a>
Amatzia BenArtzi		NetManage, Inc.		<a href="mailto:amatzia@netmanage.com">amatzia@netmanage.com</a>
Mark Beyer			Ungermann-Bass		<a href="mailto:mbeyer@ub.com">mbeyer@ub.com</a>
Nelson Bolyard			Silicon Graphics, Inc.	<a href="mailto:nelson@sgi.com">nelson@sgi.com</a>
Pat Bonner			Hewlett-Packard		<a href="mailto:p_bonner@cnd.hp.com">p_bonner@cnd.hp.com</a>
Derek Brown			FTP Software		<a href="mailto:db@wco.ftp.com">db@wco.ftp.com</a>
Malcolm Butler			ICL			<a href="mailto:mcab@oasis.icl.co.uk">mcab@oasis.icl.co.uk</a>
Mike Calbaum			Frontier Technologies	<a href="mailto:mike@frontiertech.com">mike@frontiertech.com</a>
Isaac Chan			Microsoft Corporation	<a href="mailto:isaacc@microsoft.com">isaacc@microsoft.com</a>
Khoji Darbani			Informix		<a href="mailto:khoji@informix.com">khoji@informix.com</a>
Nestor Fesas			Hughes LAN Systems	<a href="mailto:nestor@hls.com">nestor@hls.com</a>
Karanja Gakio			FTP Software		<a href="mailto:karanja@ftp.com">karanja@ftp.com</a>
Vikas Garg			Distinct		<a href="mailto:vikas@distinct.com">vikas@distinct.com</a>
Gary Gere			Gupta			<a href="mailto:ggere@gupta.com">ggere@gupta.com</a>
Jim Gilroy			Microsoft Corporation	<a href="mailto:jamesg@microsoft.com">jamesg@microsoft.com</a>
Bill Hayes			Hewlett-Packard		<a href="mailto:billh@hpchdpc.cnd.hp.com">billh@hpchdpc.cnd.hp.com</a>
Paul Hill			MIT			<a href="mailto:pbh@athena.mit.edu">pbh@athena.mit.edu</a>
Tmima Koren			NetManage, Inc.		<a href="mailto:tmima@netmanage.com">tmima@netmanage.com</a>
Hoek Law			Citicorp		<a href="mailto:law@dcc.tti.com">law@dcc.tti.com</a>
Graeme Le Roux			Moresdawn P/L		-
Kevin Lewis			Novell			<a href="mailto:kevinl@novell.com">kevinl@novell.com</a>
Roger Lin			3Com			<a href="mailto:roger_lin@3mail.3com.com">roger_lin@3mail.3com.com</a>
Terry Lister			Hewlett-Packard		<a href="mailto:tel@cnd.hp.com">tel@cnd.hp.com</a>
Jeng Long Jiang			Wollongong		<a href="mailto:long@twg.com">long@twg.com</a>
Lee Murach			Network Research	<a href="mailto:lee@nrc.com">lee@nrc.com</a>
Pete Ostenson			Microsoft Corporation	<a href="mailto:peteo@microsoft.com">peteo@microsoft.com</a>
David Pool			Spry, Inc.		<a href="mailto:dave@spry.com">dave@spry.com</a>
Bob Quinn			FTP Software		<a href="mailto:rcq@ftp.com">rcq@ftp.com</a>
Glenn Reitsma			Hughes LAN Systems	<a href="mailto:glennr@hls.com">glennr@hls.com</a>
Brad Rice			Age			<a href="mailto:rice@age.com">rice@age.com</a>
Allen Rochkind			3Com			-
Jonathan Rosen			IBM			<a href="mailto:jrosen@vnet.ibm.com">jrosen@vnet.ibm.com</a>
Steve Stokes			Novell			<a href="mailto:stoke@novell.com">stoke@novell.com</a>
Joseph Tsai			3Com			<a href="mailto:joe_tsai@3mail.3com.com">joe_tsai@3mail.3com.com</a>
James Van Bokkelen		FTP Software		<a href="mailto:jbvb@ftp.com">jbvb@ftp.com</a>
Miles Wu			Wollongong		<a href="mailto:wu@twg.com">wu@twg.com</a>
Boris Yanovsky			NetManage, Inc.		<a href="mailto:boris@netmanage.com">boris@netmanage.com</a>
</p></pre>

<hr><h1><a name="Intro">Introduction</a></h1>

<hr><h2><a name="WhatIs">What is Windows Sockets</a></h2>

The Windows Sockets specification defines a network programming interface for
Microsoft Windows which is based on the "socket" paradigm popularized in the
Berkeley Software Distribution (BSD) from the University of California at
Berkeley.  It encompasses both familiar Berkeley socket style routines and a
set of Windows-specific extensions designed to allow the programmer to take
advantage of the message-driven nature of Windows.<p>

The Windows Sockets Specification is intended to provide a single API to which
application developers can program and multiple network software vendors can
conform.  Furthermore, in the context of a particular version of Microsoft
Windows, it defines a binary interface (ABI) such that an application written
to the Windows Sockets API can work with a conformant protocol implementation
from any network software vendor.  This specification thus defines the library
calls and associated semantics to which an application developer can program
and which a network software vendor can implement.</p><p>

Network software which conforms to this Windows Sockets specification will be
considered "Windows Sockets Compliant".  Suppliers of interfaces which are
"Windows Sockets Compliant" shall be referred to as "Windows Sockets
Suppliers".  To be Windows Sockets Compliant, a vendor must implement 100% of
this Windows Sockets specification.</p><p>

Applications which are capable of operating with any "Windows Sockets
Compliant" protocol implementation will be considered as having a "Windows
Sockets Interface" and will be referred to as "Windows Sockets Applications".</p><p>

This version of the Windows Sockets specification defines and documents the use
of the API in conjunction with the Internet Protocol Suite (IPS, generally
referred to as TCP/IP).  Specifically, all Windows Sockets implementations
support both stream (TCP) and datagram (UDP) sockets.</p><p>

While the use of this API with alternative protocol stacks is not precluded
(and is expected to be the subject of future revisions of the specification),
such usage is beyond the scope of this version of the specification.</p><p>

</p><hr><h2><a name="Berkeley">Berkeley Sockets</a></h2>

The Windows Sockets Specification has been built upon the Berkeley Sockets
programming model which is the de facto standard for TCP/IP networking.  It is
intended to provide a high degree of familiarity for programmers who are used
to programming with sockets in UNIX and other environments, and to simplify the
task of porting existing sockets-based source code.  The Windows Sockets API is
consistent with release 4.3 of the Berkeley Software Distribution (4.3BSD).<p>

Portions of the Windows Sockets specification are derived from material which
is Copyright (c) 1982-1986 by the Regents of the University of California.  All
rights are reserved.  The Berkeley Software License Agreement specifies the
terms and conditions for redistribution.</p><p>


</p><hr><h2><a name="Windows">Microsoft Windows and Windows-specific extensions</a></h2>

This API is intended to be usable within all implementations and versions of
Microsoft Windows from Microsoft Windows Version 3.0 onwards.  It thus provides
for Windows Sockets implementations and Windows Sockets applications in both 16
and 32 bit operating environments.  <p>

Windows Sockets makes provisions for multithreaded Windows processes.  A
process contains one or more threads of execution.  In the Windows 3.1
non-multithreaded world, a task corresponds to a process with a single thread.
All references to threads in this document refer to actual "threads" in
multithreaded Windows environments.  In non multithreaded environments (such as
Windows 3.0), use of the term thread refers to a Windows process.</p><p>

The Microsoft Windows extensions included in Windows Sockets are provided to
allow application developers to create software which conforms to the Windows
programming model.  It is expected that this will facilitate the creation of
robust and high-performance applications, and will improve the cooperative
multitasking of applications within non-preemptive versions of Windows.  With
the exception of 
<a href="#Startup">WSAStartup()</a>
and 
<a href="#Cleanup">WSACleanup()</a>
their use is not mandatory.</p><p>


</p><hr><h2><a name="Status">The Status of this Specification</a></h2>

Windows Sockets is an independent specification which was created and exists
for the benefit of application developers and network vendors and, indirectly,
computer users. Each published (non-draft) version of this specification
represents a fully workable API for implementation by network vendors and
programming use by application developers. Discussion of this specification and
suggested improvements continue and are welcomed. Such discussion occurs mainly
via the Internet electronic mail forum winsock@microdyne.com. Meetings of
interested parties occur on an irregular basis. Details of these meetings are
publicized to the electronic mail forum.<p>

</p><hr><h2><a name="Revision">Revision History</a></h2>

<hr><h3><a name="Revision_1.0">Windows Sockets Version 1.0</a></h3>

Windows Sockets Version 1.0 represented the results of considerable work within
the vendor and user community as discussed in "
<a href="#Origins">Origins
of Windows Sockets</a>". This version of  the specification was released in
order that network software suppliers and  application developers could begin
to construct implementations and applications  which conformed to the Windows
Sockets standard.<p>

</p><hr><h3><a name="Revision_1.1">Windows Sockets Version 1.1</a></h3>

Windows Sockets Version 1.1 follows the guidelines and structure laid out by
version 1.0, making changes only where absolutely necessary as indicated by the
experiences of a number of companies that created Windows Sockets
implementations based on the version 1.0 specification.  Version 1.1 contains
several clarifications and minor fixes to version 1.0.  Additionally, the
following more significant changes were incorporated into version 1.1:
<p>

</p><ul>
<li> Inclusion of the <a href="#GetHostName">gethostname()</a>
routine to simplify retrieval of the host's name and address.<p>

</p></li><li> Definition of DLL ordinal values below 1000 as reserved for Windows Sockets
and ordinals above 1000 as unrestricted.  This allows Windows Sockets vendors
to include private interfaces to their DLLs without risking that the ordinals
choosen will conflict with a future version of Windows Sockets.<p>

</p></li><li> Addition of a reference count to <a href="#Startup">WSAStartup()</a> and
<a href="#Cleanup">WSACleanup()</a>, requiring correspondences between the
calls.  This allows applications and third-party DLLs to make use of a Windows
Sockets implementation without being concerned about the calls to these APIs
made by the other.<p>

</p></li><li> Change of return type of <a href="#InetAddr">inet_addr()</a> from
<b>struct in_addr</b> to <b>unsigned long</b>.  This was required due to
different handling of four-byte structure returns between the Microsoft and
Borland C compilers.<p>

</p></li><li> Change of <a href="#AsyncSelect">WSAAsyncSelect()</a> semantics
from "edge-triggerred" to "level-triggerred".  The level-triggerred semantics
significantly simplify an application's use of this routine.<p>

</p></li><li> Change the <a href="#IoctlSocket">ioctlsocket()</a> FIONBIO
semantics to fail if a <a href="#AsyncSelect">WSAAsyncSelect()</a> call
is outstanding on the socket.<p>

</p></li><li> Addition of the TCP_NODELAY socket option for RFC 1122 conformance.
</li></ul>

<hr><h1><a name="ProgrammingWithSockets">Programming with Sockets</a></h1>

<hr><h2><a name="Prog_StackInstall">Windows Sockets Stack Installation Checking</a></h2>

To detect the presence of one (or many) Windows Sockets implementations on a
system, an application which has been linked with the Windows Sockets Import
Library may simply call the 
<a href="#Startup">WSAStartup()</a>
routine.  If an application wishes to be a little more sophisticated it can
examine the $PATH environment variable and search for instances of Windows
Sockets implementations (WINSOCK.DLL).  For each instance it can issue a
<b>LoadLibrary()</b> call and use the 
<a href="#Startup">WSAStartup()</a>
routine to discover implementation specific data.<p>

This version of the Windows Sockets specification does not attempt to address
explicitly the issue of multiple concurrent Windows Sockets implementations.
Nothing in the specification should be interpreted as restricting multiple
Windows Sockets DLLs from being present and used concurrently by one or more
Windows Sockets applications.</p><p>

For further details of where to obtain Windows Sockets components, see "
<a href="#Notes_WindowsComponents">Windows
Sockets Components</a>".</p><p>

</p><hr><h2><a name="Prog_Sockets">Sockets</a></h2>

The following material is derived from the document "An Advanced 4.3BSD
Interprocess Communication Tutorial" by Samuel J. Leffler, Robert S. Fabry,
William N. Joy, Phil Lapsley, Steve Miller, and Chris Torek.<p>

</p><hr><h3><a name="Sockets_BasicConcepts">Basic concepts</a></h3>

The basic building block for communication is the socket.  A socket is an
endpoint of communication to which a name may be bound.  Each socket in use has
a type and an associated process.  Sockets exist within communication domains.
A communication domain is an abstraction introduced to bundle common properties
of threads communicating through sockets.  Sockets normally exchange data only
with sockets in the same domain (it may be possible to cross domain boundaries,
but only if some translation process is performed).  The Windows Sockets
facilities support a single communication domain: the Internet domain, which is
used by processes which communicate using the Internet Protocol Suite.  (Future
versions of this specification may include additional domains.) <p>

Sockets are typed according to the communication properties visible to a user.
Applications are presumed to communicate only between sockets of the same type,
although there is nothing that prevents communication between sockets of
different types should the underlying communication protocols support this.  </p><p>

Two types of sockets currently are available to a user.  A stream socket
provides for the bi-directional, reliable, sequenced, and unduplicated flow of
data without record boundaries.  </p><p>

A datagram socket supports bi-directional flow of data which is not promised to
be sequenced, reliable, or unduplicated.  That is, a process receiving messages
on a datagram socket may find messages duplicated, and, possibly, in an order
different from the order in which it was sent.  An important characteristic of
a datagram socket is that record boundaries in data are preserved.  Datagram
sockets closely model the facilities found in many contemporary packet switched
networks such as Ethernet.  </p><p>


</p><hr><h3><a name="Sockets_ClientServer">Client-server model</a></h3>

The most commonly used paradigm in constructing distributed applications is the
client/server model.  In this scheme client applications request services from
a server application.  This implies an asymmetry in establishing communication
between the client and server.  <p>

The client and server require a well-known set of conventions before service
may be rendered (and accepted).  This set of conventions comprises a protocol
which must be implemented at both ends of a connection.  Depending on the
situation, the protocol may be symmetric or asymmetric.  In a symmetric
protocol, either side may play the master or slave roles.  In an asymmetric
protocol, one side is immutably recognized as the master, with the other as the
slave.  An example of a symmetric protocol is the TELNET protocol used in the
Internet for remote terminal emulation.  An example of an asymmetric protocol
is the Internet file transfer protocol, FTP.  No matter whether the specific
protocol used in obtaining a service is symmetric or asymmetric, when accessing
a service there is a ``client process'' and a ``server process''.  </p><p>

A server application normally listens at a well-known address for service
requests.  That is, the server process remains dormant until a connection is
requested by a client's connection to the server's address.  At such a time the
server process ``wakes up'' and services the client, performing whatever
appropriate actions the client requests of it.  While connection-based services
are the norm, some services are based on the use of datagram sockets.  </p><p>


</p><hr><h3><a name="Sockets_OutOfBand">Out-of-band data</a></h3>

Note: The following discussion of out-of-band data, also referred to as TCP
Urgent data,  follows the model used in the Berkeley software distribution.
Users and implementors should be aware of the fact that there are at present
two conflicting interpretations of RFC 793 (in which the concept is
introduced), and that the implementation of out-of-band data in the Berkeley
Software Distribution does not conform to the Host Requirements laid down in
RFC 1122.  To minimize interoperability problems, applications writers are
advised not to use out-of-band data unless this is required in order to
interoperate with an existing service.  Windows Sockets suppliers are urged to
document the out-of-band semantics (BSD or RFC 1122) which their product
implements.  It is beyond the scope of this specification to mandate a
particular set of semantics for out-of-band data handling.<p>

The stream socket abstraction includes the notion of ``out of band'' data.
Out-of-band data is a logically independent transmission channel associated
with each pair of connected stream sockets.  Out-of-band data is delivered to
the user independently of normal data.  The abstraction defines that the
out-of-band data facilities must support the reliable delivery of at least one
out-of-band message at a time.  This message may contain at least one byte of
data, and at least one message may be pending delivery to the user at any one
time.  For communications protocols which support only in-band signaling (i.e.
the urgent data is delivered in sequence with the normal data), the system
normally extracts the data from the normal data stream and stores it
separately.  This allows users to choose between receiving the urgent data in
order and receiving it out of sequence without having to buffer all the
intervening data.  It is possible to ``peek'' at out-of-band data.  </p><p>

An application may prefer to process out-of-band data "in-line", as part of the
normal data stream.  This is achieved by setting the socket option SO_OOBINLINE
(see 
<a href="#SetSockOpt">setsockopt()</a>).
In this case, the application may wish to determine whether any of the unread
data is "urgent" (the term usually applied to in-line out-of-band data).  To
facilitate this, the Windows Sockets implementation will maintain a logical
"mark" in the data stream to indicate the point at which the out-of-band data
was sent.  An application can use the SIOCATMARK 
<a href="#IOCTLSocket">ioctlsocket()</a>
command to determine whether there is any unread data preceding the mark.  For
example, it might use this to resynchronize with its peer by ensuring that all
data up to the mark in the data stream is discarded when appropriate.</p><p>

The 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
routine is particularly well suited to handling notification of the presence of
out-of-band-data.</p><p>


</p><hr><h3><a name="Sockets_Broadcasting">Broadcasting</a></h3>

By using a datagram socket, it is possible to send broadcast packets on many
networks supported by the system.  The network itself must support broadcast:
the system provides no simulation of broadcast in software.  Broadcast messages
can place a high load on a network, since they force every host on the network
to service them.  Consequently, the ability to send broadcast packets has been
limited to sockets which are explicitly marked as allowing broadcasting.
Broadcast is typically used for one of two reasons: it is desired to find a
resource on a local network without prior knowledge of its address, or
important functions such as routing require that information be sent to all
accessible neighbors.<p>

The destination address of the message to be broadcast depends on the
network(s) on which the message is to be broadcast.  The Internet domain
supports a shorthand notation for broadcast on the local network, the address
INADDR_BROADCAST.  Received broadcast messages contain the senders address and
port, as datagram sockets must be bound before use.</p><p>

Some types of network support the notion of different types of broadcast.  For
example, the IEEE 802.5 token ring architecture supports the use of link-level
broadcast indicators, which control whether broadcasts are forwarded by
bridges.  The Windows Sockets specification does not provide any mechanism
whereby an application can determine the type of underlying network, nor any
way to control the semantics of broadcasting.</p><p>


</p><hr><h2><a name="Prog_ByteOrdering">Byte Ordering</a></h2>

The Intel byte ordering is like that of the DEC VAX, and therefore differs from
the Internet and 68000-type processor byte ordering.  Thus care must be taken
to ensure correct orientation.<p>

Any reference to IP addresses or port numbers passed to or from a Windows
Sockets routine must be in network order.  This includes the IP address and
port fields of a <b>struct sockaddr_in</b> (but not the <i>sin_family</i>
field).</p><p>

Consider an application which normally contacts a server on the TCP port
corresponding to the "time" service, but which provides a mechanism for the
user to specify that an alternative port is to be used.  The port number
returned by 
<a href="#GetServByName">getservbyname()</a>
is already in network order, which is the format required constructing an
address, so no translation is required.  However if the user elects to use a
different port, entered as an integer, the application must convert this from
host to network order (using the 
<a href="#HtoNS">htons()</a>
function) before using it to construct an address.  Conversely, if the
application wishes to display the number of the port within an address
(returned via, e.g., 
<a href="#GetPeerName">getpeername()</a>),
the port number must be converted from network to host order (using 
<a href="#NtoHS">ntohs()</a>)
before it can be displayed.</p><p>

Since the Intel and Internet byte orders are different, the conversions
described above are unavoidable.  Application writers are cautioned that they
should use the standard conversion functions provided as part of the Windows
Sockets API rather than writing their own conversion code, since future
implementations of Windows Sockets are likely to run on systems for which the
host order is identical to the network byte order.  Only applications which use
the standard conversion functions are likely to be portable.</p><p>


</p><hr><h2><a name="Prog_SocketOptions">Socket Options</a></h2>

The socket options supported by Windows Sockets are listed in the pages
describing 
<a href="#SetSockOpt">setsockopt()</a>
and 
<a href="#GetSockOpt">getsockopt()</a>.
A Windows Sockets implementation must recognize all of these options, and (for 
<a href="#GetSockOpt">getsockopt()</a>)
return plausible values for each.  The default value for each option is shown
in the following table.

<pre><b><u>Value		Type		Meaning			Default		Note</u></b>
--------------- --------------- ----------------------- --------------- ----
SO_ACCEPTCON	BOOL		Socket is <a href="#Listen">listen()</a>ing.
				FALSE unless a <a href="#Listen">listen()</a>
				has been performed<p>

SO_BROADCAST	BOOL		Socket is configured	FALSE</p><p>
				for the transmission of</p><p>
				broadcast messages.	</p><p>

SO_DEBUG	BOOL		Debugging is enabled.  	FALSE		(i)</p><p>

SO_DONTLINGER	BOOL		If true, the SO_LINGER	TRUE</p><p>
				option is disabled..		</p><p>

SO_DONTROUTE	BOOL		Routing is disabled.	FALSE		(i)</p><p>

SO_ERROR	int		Retrieve error status	0</p><p>
				and clear.	</p><p>

SO_KEEPALIVE	BOOL		Keepalives are being	FALSE</p><p>
				sent.	</p><p>

SO_LINGER	struct linger	Returns the current	<i>l_onoff</i> is 0</p><p>
		FAR *		linger options.</p><p>

SO_OOBINLINE	BOOL		Out-of-band data is	FALSE</p><p>
				being received in the</p><p>
				normal data stream.	</p><p>

SO_RCVBUF	int		Buffer size for		Implementation	(i)</p><p>
				receives		dependant.</p><p>

SO_REUSEADDR	BOOL		The address to which	FALSE</p><p>
				this socket is bound</p><p>
				can be used by others.	</p><p>

SO_SNDBUF	int		Buffer size for sends	Implementation	(i)</p><p>
							dependant.</p><p>

SO_TYPE		int		The type of the socket	As created</p><p>
				(e.g. SOCK_STREAM).	via <a href="#Socket">socket()</a></p><p>

TCP_NODELAY	BOOL		Disables the Nagle	Implementation</p><p>
				algorithm for send	dependant.</p><p>
				coalescing.
</p></pre>
<p>Notes:</p><p>
(i)	An implementation may silently ignore this option on 
<a href="#SetSockOpt">setsockopt()</a>
and return a constant value for 
<a href="#GetSockOpt">getsockopt()</a>,
or it may accept a value for 
<a href="#SetSockOpt">setsockopt()</a>
and return the corresponding value in 
<a href="#GetSockOpt">getsockopt()</a>
without using the value in any way.
</p><p>

</p><hr><h2><a name="Prog_DatabaseFiles">Database Files</a></h2>

The 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
and 
<a href="#Overview_DatabaseFunctions">WSAAsyncGetXByY()</a>
classes of routines are provided for retrieving network specific information.
The <b>getXbyY()</b> routines were originally designed (in the first Berkeley
UNIX releases) as mechanisms for looking up information in text databases.
Although the information may be retrieved by the Windows Sockets implementation
in different ways, a Windows Sockets application requests such information in a
consistent manner through either the <b>getXbyY()</b> or the
<b>WSAAsyncGetXByY()</b> class of routines.<p>


</p><hr><h2><a name="Prog_Deviation">Deviation from Berkeley Sockets</a></h2>

There are a few limited instances where the Windows Sockets API has had to
divert from strict adherence to the Berkeley conventions, usually because of
difficulties of implementation in a Windows environment.<p>

<a href="#Deviation_DataType">socket
data type and error values</a></p><p>
<a href="#Deviation_Select">select()
and FD_*</a></p><p>
<a href="#Deviation_ErrorCodes">Error
codes -- errno, h_errno &amp; WSAGetLastError()</a></p><p>
<a href="#Deviation_Pointers">Pointers</a></p><p>
<a href="#Deviation_RenamedFunctions">Renamed
functions</a></p><p>
<a href="#Deviation_BlockingRoutines">Blocking
routines &amp; EINPROGRESS</a></p><p>
<a href="#Deviation_MaxSockets">Maximum
number of sockets supported</a></p><p>
<a href="#Deviation_IncludeFiles">Include
files</a></p><p>
<a href="#Deviation_ReturnValues">Return
values on API failure</a></p><p>

</p><p>

</p><hr><h3><a name="Deviation_DataType">socket data type and error values</a></h3>

A new data type, SOCKET, has been defined.  The definition of this type was
necessary for future enhancements to the Windows Sockets specification, such as
being able to use sockets as file handles in Windows NT.  Definition of this
type also facilitates porting of applications to a Win/32 environment, as the
type will automatically be promoted from 16 to 32 bits.<p>

In UNIX, all handles, including socket handles, are small, non-negative
intergers, and some applications make assumptions that this will be true.
Windows Sockets handles have no restrictions, other than that the value
INVALID_SOCKET is not a valid socket.  Socket handles may take any value in the
range 0 to INVALID_SOCKET-1.</p><p>

Because the SOCKET type is unsigned, compiling existing source code from, for
example, a UNIX environment may lead to compiler warnings about signed/unsigned
data type mismatches.</p><p>

This means, for example, that checking for errors when the 
<a href="#Socket">socket()</a>
and 
<a href="#Accept">accept()</a>
routines return should <u>not</u> be done by comparing the return value with
-1, or seeing if the value is negative (both common, and legal, approaches in
BSD).  Instead, an application should use the manifest constant INVALID_SOCKET
as defined in 
<a href="#WinsockH">winsock.h</a>.
For example:</p><p>
	<b>TYPICAL BSD STYLE:</b>

</p><pre>s = socket(...);
if (s == -1)	/* or s &lt; 0 */
	{...}
</pre>
<p>
	<b>PREFERRED STYLE:</b>

</p><pre>s = socket(...);
if (s == INVALID_SOCKET)
	{...}
</pre>
<p>

</p><hr><h3><a name="Deviation_Select">select() and FD_*</a></h3>

Because a SOCKET is no longer represented by the UNIX-style "small non-negative
integer", the implementation of the 
<a href="#Select">select()</a>
function was changed in the Windows Sockets API.  Each set of descriptors is
still represented by the fd_set type, but instead of being stored as a bitmask
the set is implemented as an array of SOCKETs..  To avoid potential problems,
applications <b>must</b> adhere to the use of the FD_XXX macros to set,
initialize, clear, and check the fd_set structures.<p>


</p><hr><h3><a name="Deviation_ErrorCodes">Error codes -- errno, h_errno &amp; WSAGetLastError()</a></h3>

Error codes set by the Windows Sockets implementation are <b>NOT</b> made
available via the errno variable.  Additionally, for the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
class of functions, error codes are <b>NOT</b> made available via the h_errno
variable.  Instead, error codes are accessed by using the 
<a href="#GetLastError">WSAGetLastError()</a>
API.  This function is provided in Windows Sockets as a precursor (and
eventually an alias) for the Win32 function <b>GetLastError()</b>.  This is
intended to provide a reliable way for a thread in a multi-threaded process to
obtain per-thread error information.<p>

For compatibility with BSD, an application may choose to include a line of the
form:</p><p>


</p><pre>#define errno WSAGetLastError()
</pre>
<p>
This will allow networking code which was written to use the global errno to
work correctly in a single-threaded environment.  There are, obviously, some
drawbacks.  If a source file includes code which inspects errno for both socket
and non-socket functions, this mechanism cannot be used.  Furthermore, it is
not possible for an application to assign a new value to errno.  (In Windows
Sockets the function 
<a href="#SetLastError">WSASetLastError()</a>
may be used for this purpose.)</p><p>

	<b>TYPICAL BSD STYLE:</b>

</p><pre>r = recv(...);
if (r == -1
    &amp;&amp; errno == EWOULDBLOCK)
	{...}
</pre>
<p>
	<b>PREFERRED STYLE:</b>

</p><pre>r = recv(...);
if (r == -1       /* (but see below) */
    &amp;&amp; WSAGetLastError() == EWOULDBLOCK)
	{...}
</pre>
Although
error constants consistent with 4.3 Berkeley Sockets are provided for
compatibility purposes, applications should, where possible, use the "WSA"
error code definitions.  For example, a more accurate version of the above
source code fragment is:<p>


</p><pre>r = recv(...);
if (r == -1
    &amp;&amp; WSAGetLastError() == <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>)
	{...}
</pre>
<p>

</p><hr><h3><a name="Deviation_Pointers">Pointers</a></h3>

All pointers used by applications with Windows Sockets should be FAR.  To
facilitate this, data type definitions such as LPHOSTENT are provided.<p>


</p><hr><h3><a name="Deviation_RenamedFunctions">Renamed functions</a></h3>

In two cases it was necessary to rename functions which are used in Berkeley
Sockets in order to avoid clashes with other APIs.<p>

<b>close() &amp; </b>
<a href="#CloseSocket">closesocket()</a>
In Berkeley Sockets, sockets are represented by standard file descriptors, and
so the <b>close()</b> function can be used to close sockets as well as regular
files.  While nothing in the Windows Sockets API prevents an implementation
from using regular file handles to identify sockets, nothing requires it
either.  Socket descriptors are not presumed to correspond to regular file
handles, and file operations such as <b>read()</b>, <b>write()</b>, and
<b>close()</b> cannot be assumed to work correctly when applied to socket
descriptors..  Sockets must be closed by using the 
<a href="#CloseSocket">closesocket()</a>
routine.  Using the <b>close()</b> routine to close a socket is incorrect and
the effects of doing so are undefined by this specification.</p><p>

<b>ioctl() &amp; </b>
<a href="#IOCTLSocket">ioctlsocket()</a></p><p>
Various C language run-time systems use the <b>ioctl()</b> routine for purposes
unrelated to Windows Sockets.  For this reason we have defined the routine 
<a href="#IOCTLSocket">ioctlsocket()</a>
which is used to handle socket functions which in the Berkeley Software
Distribution are performed using <b>ioctl()</b> and <b>fcntl()</b>.</p><p>


</p><hr><h3><a name="Deviation_BlockingRoutines">Blocking routines &amp; EINPROGRESS</a></h3>

Although blocking operations on sockets are supported under Windows Sockets,
their use is strongly discouraged.  Programmers who are constrained to use
blocking mode -- for example, as part of an existing application which is to be
ported -- should be aware of the semantics of blocking operations in Windows
Sockets.  See 
<a href="#Overview_BlockingNonBlocking">Blocking/Non
blocking &amp; Data Volatility</a> for more details.<p>


</p><hr><h3><a name="Deviation_MaxSockets">Maximum number of sockets supported</a></h3>

The maximum number of sockets supported by a particular Windows Sockets
supplier is implementation specific.  An application should make no assumptions
about the availability of a certain number of sockets.  This topic is addressed
further in the section on 
<a href="#Startup">WSAStartup()</a>.
However, independent of the number of sockets supported by a particular
implementation is the issue of the maximum number of sockets which an
application can actually make use of.<p>

The maximum number of sockets which a Windows Sockets application can make use
of is determined at compile time by the manifest constant FD_SETSIZE.  This
value is used in constructing the fd_set structures used in 
<a href="#Select">select()</a>.
The default value in 
<a href="#WinsockH">winsock.h</a>
is 64.  If an application is designed to be capable of working with more than
64 sockets, the implementor should define the manifest FD_SETSIZE in every
source file <u>before</u> including 
<a href="#WinsockH">winsock.h</a>.
One way of doing this may be to include the definition within the compiler
options in the makefile, for example adding -DFD_SETSIZE=128 as an option to
the compiler command line for Microsoft C.  It must be emphasized that defining
FD_SETSIZE as a particular value has no effect on the actual number of sockets
provided by a Windows Sockets implementation.</p><p>


</p><hr><h3><a name="Deviation_IncludeFiles">Include files</a></h3>

For ease of portability of existing Berkeley sockets based source code, a
number of standard Berkeley include files are supported.  However, these
Berkeley header files merely include the 
<a href="#WinsockH">winsock.h</a>
include file, and it is therefore sufficient (and recommended) that Windows
Sockets application source files should simply include 
<a href="#WinsockH">winsock.h</a>.<p>


</p><hr><h3><a name="Deviation_ReturnValues">Return values on API failure</a></h3>

The manifest constant SOCKET_ERROR is provided for checking API failure.
Although use of this constant is not mandatory, it is recommended.  The
following example illustrates the use of the SOCKET_ERROR constant:<p>

<b>	TYPICAL BSD STYLE:</b>

</p><pre>r = recv(...);
if (r == -1     /* or r &lt; 0 */
    &amp;&amp; errno == EWOULDBLOCK)
	{...}
</pre>
<b>
PREFERRED STYLE:</b>

<pre>r = recv(...);
if (r == SOCKET_ERROR
    &amp;&amp; WSAGetLastError() == <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>)
	{...}
</pre>

<hr><h2><a name="Prog_RawSockets">Raw Sockets</a></h2>

The Windows Sockets specification does not mandate that a Windows Sockets DLL
support raw sockets, that is, sockets opened with SOCK_RAW.  However, a Windows
Sockets DLL is allowed and encouraged to supply raw socket support.  A Windows
Sockets-compliant application that wishes to use raw sockets should attempt to
open the socket with the <b>socket()</b> call (see section 4.1.23), and if it
fails either attempt to use another socket type or indicate the failure to the
user.<p>

</p><hr><h2><a name="Prog_MultithreadedWindows">Windows Sockets in Multithreaded Versions of Windows</a></h2>

The Windows Sockets interface is designed to work for both single-threaded
versions of Windows (such as Windows 3.1) and future multithreaded versions of
Windows (such as Windows NT).  In a multithreaded environment the sockets
interface is basically the same, but the author of a multithreaded application
must be aware that it is the responsibility of the application, not the Windows
Sockets implementation, to synchronize access to a socket between threads.
This is the same rule as applies to other forms of I/O such as file I/O.
Failure to synchronize calls on a socket leads to unpredictable results; for
example if there are two simultaneous calls to send(), there is no guarantee as
to the order in which the data will be sent.  <p>

Closing a socket in one thread that has an outstanding blocking call on the
same socket in another thread will cause the blocking call to fail with
<a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>, just as if the operation were cancelled.  This also applies if there
is a 
<a href="#Select">select()</a>
call outstanding and the application closes one of the sockets being
selected.</p><p>

There is no default blocking hook installed in preemptive multithreaded
versions of Windows.  This is because the machine will not be blocked if a
single application is waiting for an operation to complete and hence not
calling PeekMessage() or GetMessage() which cause the application to yield in
nonpremptive Windows.  However, for backwards compatibility the
WSASetBlockingHook() call is implemented in multithreaded versions of Windows,
and any application whose behavior depends on the default blocking hook may
install their own blocking hook which duplicates the default hook's semantics,
if desired.

</p><hr><h1><a name="SocketLibraryOverview">Socket Library Overview</a></h1>

<hr><h2><a name="Overview_SocketFunctions">Socket Functions</a></h2>

The Windows Sockets specification includes the following Berkeley-style socket
routines:<p>

<a href="#Accept">accept()</a>
An incoming connection is acknowledged and associated with an immediately
created socket.  The original socket is returned to the listening state.</p><p>
<a href="#Bind">bind()</a>
Assign a local name to an unnamed socket.</p><p>
<a href="#CloseSocket">closesocket()</a>
Remove a socket descriptor from the per-process object reference table.  Only
blocks if SO_LINGER is set.</p><p>
<a href="#Connect">connect()</a>
Initiate a connection on the specified socket.</p><p>
<a href="#GetPeerName">getpeername()</a>
Retrieve the name of the peer connected to the specified socket descriptor.</p><p>
<a href="#GetSockName">getsockname()</a>
Retrieve the current name for the specified socket</p><p>
<a href="#GetSockOpt">getsockopt()</a>
Retrieve options associated with the specified socket descriptor.</p><p>
<a href="#HtoNL">htonl()</a>
Convert a 32-bit quantity from host byte order to network byte order.</p><p>
<a href="#HtoNS">htons()</a>
Convert a 16-bit quantity from host byte order to network byte order.</p><p>
<a href="#InetAddr">inet_addr()</a>
Converts a character string representing a number in the Internet standard ``.''
notation to an Internet address value.</p><p>
<a href="#InetNtoA">inet_ntoa()</a>
Converts an Internet address value to an ASCII string in ``.'' notation i.e.
``a.b.c.d''.</p><p>
<a href="#IOCTLSocket">ioctlsocket()</a>
Provide control for descriptors.</p><p>
<a href="#Listen">listen()</a>
Listen for incoming connections on a specified socket.</p><p>
<a href="#NtoHL">ntohl()</a>
Convert a 32-bit quantity from network byte order to host byte order.</p><p>
<a href="#NtoHS">ntohs()</a>
Convert a 16-bit quantity from network byte order to host byte order.</p><p>
<a href="#RECV">recv()*</a>
Receive data from a connected socket.</p><p>
<a href="#RecvFrom">recvfrom()*</a>
Receive data from either a connected or unconnected socket.</p><p>
<a href="#Select">select()*</a>
Perform synchronous I/O multiplexing.</p><p>
<a href="#Send">send()*</a>
Send data to a connected socket.</p><p>
<a href="#SendTo">sendto()*</a>
Send data to either a connected or unconnected socket.</p><p>
<a href="#SetSockOpt">setsockopt()</a>
Store options associated with the specified socket descriptor.</p><p>
<a href="#Shutdown">shutdown()</a>
Shut down part of a full-duplex connection.</p><p>
<a href="#Socket">socket()</a>
Create an endpoint for communication and return a socket descriptor.</p><p>

* The routine can block if acting on a blocking socket.</p><p>

</p><hr><h3><a name="Overview_BlockingNonBlocking">Blocking/Non blocking &amp; Data Volatility</a></h3>

One major issue in porting applications from a Berkeley sockets environment to
a Windows environment involves "blocking"; that is, invoking a function which
does not return until the associated operation is completed.  The problem
arises when the operation may take an arbitrarily long time to complete: an
obvious example is a 
<a href="#Recv">recv()</a>
which may block until data has been received from the peer system.  The default
behavior within the Berkeley sockets model is for a socket to operate in a
blocking mode unless the programmer explicitly requests that operations be
treated as non-blocking.  <b><i>It is strongly recommended that programmers use
the nonblocking (asynchronous) operations if at all possible, as they work
significantly better within the nonpreemptive Windows environment.  Use
blocking operations only if absolutely necessary, and carefully read and
understand this section if you must use blocking operations.</i></b><p>

Even on a blocking socket, some operations (e.g. 
<a href="#Bind">bind()</a>,
<a href="#GetSockOpt">getsockopt()</a>,
<a href="#GetPeerName">getpeername()</a>)
can be completed immediately.  For such operations there is no difference
between blocking and non-blocking operation.  Other operations (e.g. 
<a href="#Recv">recv()</a>)
may be completed immediately or may take an arbitrary time to complete,
depending on various transport conditions.  When applied to a blocking socket,
these operations are referred to as blocking operations.  All routines which
can block are listed with an asterisk in the tables above and below.</p><p>

Within a Windows Sockets implementation, a blocking operation which cannot be
completed immediately is handled as follows.  The DLL initiates the operation,
and then enters a loop in which it dispatches any Windows messages (yielding
the processor to another thread if necessary) and then checks for the
completion of the Windows Sockets function.  If the function has completed, or
if 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
has been invoked, the blocking function completes with an appropriate result.
Refer to  
<a href="#SetBlockingHook">WSASetBlockingHook()</a>,
for a complete description of this mechanism, including pseudocode for the
various functions.</p><p>

If a Windows message is received for a process for which a blocking operation
is in progress, there is a risk that the application will attempt to issue
another Windows Sockets call.  Because of the difficulty of managing this
condition safely, the Windows Sockets specification does not support such
application behavior.  Two functions are provided to assist the programmer in
this situation.  
<a href="#IsBlocking">WSAIsBlocking()</a>
may be called to determine whether or not a blocking Windows Sockets call is in
progress.  
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
may be called to cancel an in-progress blocking call, if any.  <b>Any other
Windows Sockets function which is called in this situation will fail with the
error <a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>.</b>  It should be emphasized that this restriction
applies to both blocking and non-blocking operations.</p><p>

Although this mechanism is sufficient for simple applications, it cannot
support the complex message-dispatching requirements of more advanced
applications (for example, those using the MDI model).  For such applications,
the Windows Sockets API includes the function 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>,
which allows the programmer to define a special routine which will be called
instead of the default message dispatch routine described above.</p><p>

The Windows Sockets DLL will call the blocking hook function only if all of the
following are true: the routine is one which is defined as being able to block,
the specified socket is a blocking socket, and the request cannot be completed
immediately.  (A socket is set to blocking by default, but the IOCTL FIONBIO
and  
<a href="#AsyncSelect">WSAAsyncSelect()</a>
both set a socket to nonblocking mode.)  If an application uses only
non-blocking sockets and uses the 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
and/or the 
<a href="#Overview_DatabaseFunctions">WSAAsyncGetXByY()</a>
routines instead of 
<a href="#Select">select()</a>
and the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
routines, then the blocking hook will never be called and the application does
not need to be concerned with the reentrancy issues the blocking hook can
introduce.</p><p>

If an application invokes an asynchronous or non-blocking operation which takes
a pointer to a memory object (e.g. a buffer, or a global variable) as an
argument, it is the responsibility of the application to ensure that the object
is available to the Windows Sockets implementation throughout the operation.

The application must not invoke any Windows function which might affect the
mapping or addressability of the memory involved.  In a multithreaded system,
the application is also responsible for coordinating access to the object using
appropriate synchronization mechanisms.  A Windows Sockets implementation
cannot, and will not, address these issues.  The possible consequences of
failing to observe these rules are beyond the scope of this specification.</p><p>

</p><hr><h2><a name="Overview_DatabaseFunctions">Database Functions</a></h2>

The Windows Sockets specification defines the following "database" routines.
As noted earlier, a Windows Sockets supplier may choose to implement these in a
manner which does not depend on local database files.  The pointer returned by
certain database routines such as 
<a href="#GetHostByName">gethostbyname()</a>
points to a structure which is allocated by the Windows Sockets library.  The
data which is pointed to is volatile and is good only until the next Windows
Sockets API call from that thread.  Additionally, the application must never
attempt to modify this structure or to free any of its components.  Only one
copy of this structure is allocated for a thread, and so the application should
copy any information which it needs before issuing any other Windows Sockets
API calls.<p>

</p><p>
<a href="#GetHostByAddr">gethostbyaddr()*</a>
Retrieve the name(s) and address corresponding to a network address.</p><p>
<a href="#GetHostName">gethostname()</a>
Retrieve the name of the local host.</p><p>
<a href="#GetHostByName">gethostbyname()*</a>
Retrieve the name(s) and address corresponding to a host name.</p><p>
<a href="#GetProtoByName">getprotobyname()*</a>
Retrieve the protocol name and number corresponding to a protocol name.</p><p>
<a href="#GetProtoByNumber">getprotobynumber()*</a>
Retrieve the protocol name and number corresponding to a protocol number.</p><p>
<a href="#GetServByName">getservbyname()*</a>
Retrieve the service name and port corresponding to a service name.</p><p>
<a href="#GetServByPort">getservbyport()*</a>
Retrieve the service name and port corresponding to a port.</p><p>

* The routine can block under some circumstances.</p><p>

</p><hr><h2><a name="Overview_WindowsSpecific">Microsoft Windows-specific Extension Functions</a></h2>

The Windows Sockets specification provides a number of extensions to the
standard set of Berkeley Sockets routines.  Principally, these extended APIs
allow message-based, asynchronous access to network events.  While use of this
extended API set is not mandatory for socket-based programming (with the
exception of 
<a href="#Startup">WSAStartup()</a>
and 
<a href="#Cleanup">WSACleanup()</a>),
it is recommended for conformance with the Microsoft Windows programming
paradigm.<p>

<a href="#Windows_AsyncSelect">Asynchronous
select() Mechanism</a></p><p>
<a href="#Windows_AsyncSupport">Asynchronous
Support Routines</a></p><p>
<a href="#Windows_HookingBlocking">Hooking
Blocking Methods</a></p><p>
<a href="#Windows_ErrorHandling">Error
Handling</a></p><p>
<a href="#Windows_Intermediate">Accessing
a Windows Sockets DLL from an Intermediate DLL</a></p><p>
<a href="#Windows_InternalMessage#s">Internal
Use of Messages by Windows Sockets Implementations</a></p><p>
<a href="#Windows_PrivateAPIs">Private
API Interfaces</a></p><p>

</p><p>
<a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a>
A set of functions which provide asynchronous</p><p>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a>
versions of the standard Berkeley</p><p>
<a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a>
<b>getXbyY()</b> functions.  For example, the</p><p>
<a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a>
<b>WSAAsyncGetHostByName()</b> function provides an asynchronous message
based</p><p>
<a href="#AsyncGetServByName">WSAAsyncGetServByName()</a>
implementation of the standard Berkeley</p><p>
<a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a>
<b>gethostbyname()</b> function.</p><p>
<a href="#AsyncSelect">WSAAsyncSelect()</a>
Perform asynchronous version of <b>select()</b></p><p>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
Cancel an outstanding instance of a <b>WSAAsyncGetXByY()</b> function.</p><p>
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
Cancel an outstanding "blocking" API call</p><p>
<a href="#Cleanup">WSACleanup()</a>
Sign off from the underlying Windows Sockets DLL.</p><p>
<a href="#GetLas#tError">WSAGetLastError()</a>
Obtain details of last Windows Sockets API error</p><p>
<a href="#IsBlocking">WSAIsBlocking()</a>
Determine if the underlying Windows Sockets DLL is already blocking an existing
call for this thread</p><p>
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
"Hook" the blocking method used by the underlying Windows Sockets
implementation</p><p>
<a href="#SetLastError">WSASetLastError()</a>
Set the error to be returned by a subsequent <b>WSAGetLastError()</b></p><p>
<a href="#Startup">WSAStartup()</a>
Initialize the underlying Windows Sockets DLL.</p><p>
<a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>
Restore the original blocking function</p><p>


</p><hr><h3><a name="Windows_AsyncSelect">Asynchronous select() Mechanism</a></h3>

The 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
API allows an application to register an interest in one or many network
events.  This API is provided to supersede the need to do polled network I/O.
Any situation in which 
<a href="#Select">select()</a>
or non-blocking I/O routines (such as 
<a href="#Send">send()</a>
and 
<a href="#Recv">recv()</a>)
are either already used or are being considered is usually a candidate for the 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
API.  When declaring interest in such condition(s), you supply a window handle
to be used for notification.  The corresponding window then receives
message-based notification of the conditions in which you declared an
interest.<p>

<a href="#AsyncSelect">WSAAsyncSelect()</a>
allows interest to be declared in the following conditions for a particular
socket:</p><p>
</p><ul>
<li> Socket readiness for reading
</li><li> Socket readiness for writing
</li><li> Out-of-band data ready for reading
</li><li> Socket readiness for accepting incoming connection
</li><li> Completion of non-blocking <a href="#Connect">connect()</a>
</li><li> Connection closure<p>
</p></li></ul>

<hr><h3><a name="Windows_AsyncSupport">Asynchronous Support Routines</a></h3>

The asynchronous "database" functions allow applications to request information
in an asynchronous manner.  Some network implementations and/or configurations
perform network based operations to resolve such requests.  The
<b>WSAAsyncGetXByY()</b> functions allow application developers to request
services which would otherwise block the operation of the whole Windows
environment if the standard Berkeley function were used.  The 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
function allows an application to cancel any outstanding asynchronous
request.<p>


</p><hr><h3><a name="Windows_HookingBlocking">Hooking Blocking Methods</a></h3>

As noted in 
<a href="#Overview_BlockingNonBlocking">Blocking/Non
blocking &amp; Data Volatility</a>, Windows Sockets implements blocking
operations in such a way that Windows message processing can continue, which
may result in the application which issued the call receiving a Windows
message.  In certain situations an application may want to influence or change
the way in which this pseudo-blocking process is implemented.  The 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
provides the ability to substitute a named routine which the Windows Sockets
implementation is to use when relinquishing the processor during a "blocking"
operation.<p>


</p><hr><h3><a name="Windows_ErrorHandling">Error Handling</a></h3>

For compatibility with thread-based environments, details of API errors are
obtained through the 
<a href="#GetLastError">WSAGetLastError()</a>
API.  Although the accepted "Berkeley-Style" mechanism for obtaining
socket-based network errors is via "errno", this mechanism cannot guarantee the
integrity of an error ID in a multi-threaded environment.  
<a href="#GetLastError">WSAGetLastError()</a>
allows you to retrieve an error code on a per thread basis.<p>

<a href="#GetLastError">WSAGetLastError()</a>
returns error codes which avoid conflict with standard Microsoft C error codes.
Certain error codes returned by certain Windows Sockets routines fall into the
standard range of error codes as defined by Microsoft C.  If you are NOT using
an application development environment which defines error codes consistent
with Microsoft C, you are advised to use the Windows Sockets error codes
prefixed by "WSA" to ensure accurate error code detection.</p><p>

Note that this specification defines a recommended set of error codes, and
lists the possible errors which may be returned as a result of each function.
It may be the case in some implementations that other Windows Sockets error
codes will be returned in addition to those listed, and applications should be
prepared to handle errors other than those enumerated under each API
description.  However a Windows Sockets implementation must not return any
value which is not enumerated in the table of legal Windows Sockets errors
given in 
<a href="#ErrorCodes">Error
Codes</a>.</p><p>

</p><hr><h3><a name="Windows_Intermediate">Accessing a Windows Sockets DLL from an Intermediate DLL</a></h3>

A Windows Sockets DLL may be accessed both directly from an application and
through an "intermediate" DLL.  An example of such an intermediate DLL would be
a virtual network API layer that supports generalized network functionality for
applications and uses Windows Sockets.  Such a DLL could be used by several
applications simultaneously, and the DLL must take special precautions with
respect to the <b>WSAStartup() </b>and<b> WSACleanup() </b>calls to ensure that
these routines are called in the context of each task that will make Windows
Sockets calls.  This is because the Windows Sockets DLL will need a call to
<b>WSAStartup() </b>for each task in order to set up task-specific data
structures, and a call to <b>WSACleanup() </b>to free any resources allocated
for the task.  <p>

There are (at least) two ways to accomplish this.  The simplest method is for
the intermediate DLL to have calls similiar to 
<a href="#Startup">WSAStartup()</a>
and
<a href="#Cleanup">WSACleanup()</a>
that applications call as appropriate.  The DLL would then call 
<a href="#Startup">WSAStartup()</a>
or
<a href="#Cleanup">WSACleanup()</a>
from within these routines.  Another mechanism is for the intermediate DLL
to build a table of task handles, which are obtained from the
<b>GetCurrentTask() </b>Windows API, and at each entry point into the
intermediate DLL check whether 
<a href="#Startup">WSAStartup()</a>
has been called for the current task, then call 
<a href="#Startup">WSAStartup()</a>
if necessary.</p><p>

If a DLL makes a blocking call and does not install its own blocking hook, then
the DLL author must be aware that control may be returned to the application
either by an application-installed blocking hook or by the default blocking
hook.  Thus, it is possible that the application will cancel the DLL's blocking
operation via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>.
If this occurs, the DLL's blocking operation will fail with the error code
<a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>, and the DLL must return control to the calling task as quickly as
possible, as the used has likely pressed a cancel or close button and the task
has requested control of the CPU.  It is recommended that DLLs which make
blocking calls install their own blocking hooks with 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
to prevent unforeseen interactions between the application and the
DLL.<i></i></p><p>
<i></i></p><p>
<i></i>Note that this is not necessary for DLLs in Windows NT because of its
different process and DLL structure.  Under Windows NT, the intermediate DLL
could simply call 
<a href="#Sta#rtup">WSAStartup()</a>
in its DLL initialization routine, which is called whenever a new process
which uses the DLL starts.</p><p>


</p><hr><h3><a name="Windows_InternalMessages">Internal use of Messages by Windows Sockets Implementations</a></h3>

In order to implement Windows Sockets purely as a DLL, it may be necessary for
the DLL to post messages internally for communication and timing.  This is
perfectly legal; however, a Windows Sockets DLL must not post messages to a
window handle opened by a client application except for those messages
requested by the application.  A Windows Sockets DLL that needs to use messages
for its own purposes must open a hidden window and post any necessary messages
to the handle for that window.<p>


</p><hr><h3><a name="Windows_PrivateAPIs">Private API Interfaces</a></h3>

The 
<a href="#Notes_DLLOrdinals">winsock.def</a>
file lists the ordinals defined for the Windows Sockets APIs.  In addition to
the ordinal values listed, all ordinals 999 and below are reserved for future
Windows Sockets use.  It may be convenient for a Windows Sockets implementation
to export additional, private interfaces from the Windows Sockets DLL.  This is
perfectly acceptable, as long as the ordinals for these exports are above 1000.
Note that any application that uses a particular Windows Sockets DLL's private
APIs will most likely not work on any other vendor's Windows Sockets
implementation.  Only the APIs defined in this document are guaranteed to be
present in every Windows Sockets implementation.<p>

If an application uses private interfaces of a particular vendor's Windows
Sockets DLL, it is recommended that the DLL not be statically linked with the
application but rather dynamically loaded with the Windows routines
<b>LoadLibrary()</b> and <b>GetProcAddress().</b>  This allows the application
to give an informative error message if it is run on a system with a Windows
Sockets DLL that does not support the same set of extended functionality.

</p><hr><h1><a name="SocketLibraryReference">Socket Library Reference</a></h1>

<hr><h2><a name="Ref_SocketRoutines">Socket Routines</a></h2>

This chapter presents the socket library routines in alphabetical order, and
describes each routine in detail.  <p>

In each routine it is indicated that the header file 
<a href="#WinsockH">winsock.h</a>
must be included.  
<a href="#HeaderFiles">Header
Files</a> lists the Berkeley-compatible header files which are supported.
These are provided for compatibility purposes only, and each of them will
simply include 
<a href="#WinsockH">winsock.h</a>.
The Windows header file <b>windows.h</b> is also needed, but <b>winsock.h</b>
will include it if necessary.</p><p>

</p><hr><h3>
<a name="Accept">accept()</a></h3>
<h4>Description</h4>
Accept a connection on a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>SOCKET PASCAL FAR accept ( SOCKET </b><i>s</i><b>, struct sockaddr FAR *
</b><i>addr<b>,</b></i><b> int FAR * </b><i>addrlen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket which is listening for connections after
a <b>listen</b>().
</dd><dt><i>addr</i>
</dt><dd>An optional pointer to a buffer which receives the address of the
connecting entity, as known to the communications layer.  The exact format of
the <i>addr</i> argument is determined by the address family established when
the socket was created.
</dd><dt><i>addrlen</i>
</dt><dd>A optional pointer to an integer which contains the length of the address
<i>addr</i>.</dd></dl>
<h4>Remarks</h4>
This routine extracts the first connection on the queue of
pending connections on <i>s</i>, creates a new socket with the same properties
as <i>s</i> and returns a handle to the new socket.  If no pending connections
are present on the queue, and the socket is not marked as non-blocking,
<b>accept()</b> blocks the caller until a connection is present.  If the socket
is marked non-blocking and no pending connections are present on the queue,
<b>accept()</b> returns an error as described below.  The accepted socket may
not be used to accept more connections.  The original socket remains open.
<p>
The argument <i>addr</i> is a result parameter that is filled in with the
address of the connecting entity, as known to the communications layer.  The
exact format of the <i>addr</i> parameter is determined by the address family
in which the communication is occurring.  The <i>addrlen</i> is a value-result
parameter; it should initially contain the amount of space pointed to by
<i>addr</i>; on return it will contain the actual length (in bytes) of the
address returned.  This call is used with connection-based socket types such as
SOCK_STREAM.  If <i>addr</i> and/or <i>addrlen</i> are equal to NULL, then no
information about the remote address of the accepted socket is returned.</p><p>


</p><h4>Return Value</h4>
If no error occurs, <b>accept</b>() returns a value of type
SOCKET which is a descriptor for the accepted packet.  Otherwise, a value of
INVALID_SOCKET is returned, and a specific error code may be retrieved by
calling 
<a href="#GetLastError">WSAGetLastError()</a>.<p>

The integer referred to by <i>addrlen</i> initially contains the amount of
space pointed to by <i>addr</i>.  On return it will contain the actual length
in bytes of the address returned.

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>addrlen</i> argument is too small (less than the sizeof a struct
sockaddr).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets call is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>
<a href="#Listen">listen()</a>
was not invoked prior to <b>accept()</b>.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>
</dt><dd>The queue is empty upon entry to <b>accept()</b> and there are no
descriptors available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No buffer space is available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>The referenced socket is not a type that supports connection-oriented
service.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as non-blocking and no connections are present to be
accepted.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#Listen">listen()</a><b>,
</b>
<a href="#Select">select()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

</p><hr><h3>
<a name="Bind">bind()</a></h3>
<h4>Description</h4>
Associate a local address with a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR bind ( SOCKET </b><i>s<b>,</b></i><b> const struct sockaddr
FAR * </b><i>name</i><b>, int </b><i>namelen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying an unbound socket.
</dd><dt><i>name</i>
</dt><dd>The address to assign to the socket.  The sockaddr structure is defined as
follows:</dd></dl>

<pre>
	struct sockaddr {
		u_short	sa_family;
		char	sa_data[14];
	};
</pre>
<dl>
<dt><i>namelen</i>
</dt><dd>The length of the <i>name</i>.</dd></dl>
<h4>Remarks</h4>
This routine is used on an unconnected datagram or stream
socket, before subsequent 
<a href="#Connect">connect()</a>s
or 
<a href="#Listen">listen()</a>s.
When a socket is created with 
<a href="#Socket">socket()</a>,
it exists in a name space (address family), but it has no name assigned.
<b>bind</b>() establishes the local association (host address/port number) of
the socket by assigning a local name to an unnamed socket.<p>

In the Internet address family, a name consists of several components.  For
SOCK_DGRAM and SOCK_STREAM, the name consists of three parts: a host address,
the protocol number (set implicitly to UDP or TCP, respectively), and a port
number which identifies the application.  If an application does not care what
address is assigned to it, it may specify an Internet address equal to
INADDR_ANY, a port equal to 0, or both.  If the Internet address is equal to
INADDR_ANY, any appropriate network interface will be used; this simplifies
application programming in the presence of multi-homed hosts.  If the port is
specified as 0, the Windows Sockets implementation will assign a unique port to
the application with a value between 1024 and 5000.  The application may use 
<a href="#GetSockName">getsockname()</a>
after <b>bind()</b> to learn the address that has been assigned to it, but note
that <b>getsockname()</b> will not necessarily fill in the Internet address
until the socket is connected, since several Internet addresses may be valid if
the host is multi-homed.</p><p>

If an application desires to bind to an arbitrary port outside of the range
1024 to 5000, such as the case of rsh which must bind to any reserved port,
code similar to the following may be used:


</p><pre>    SOCKADDR_IN sin;
    SOCKET s;
    u_short alport = IPPORT_RESERVED;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    for (;;) {
        sin.sin_port = htons(alport);
        if (bind(s, (LPSOCKADDR)&amp;sin, sizeof (sin)) == 0) {
            /* it worked */
        }
        if ( GetLastError() != <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>) {
            /* fail */
        }
        alport--;
        if (alport == IPPORT_RESERVED/2 ) {
            /* fail--all unassigned reserved ports are */
            /* in use. */
        }
    }
</pre>

<h4>Return Value</h4>
If no error occurs, <b>bind()</b> returns 0.  Otherwise, it
returns SOCKET_ERROR, and a specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a> 
</dt><dd>The specified address is already in use.  (See the SO_REUSEADDR socket
option under 
<a href="#SetSockOpt">setsockopt()</a>.)
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>namelen</i> argument is too small (less than the size of a struct
sockaddr).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets call is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
</dt><dd>The specified address family is not supported by 
</dd><dt>this protocol.
</dt><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket is already bound to an address.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>Not enough buffers available, too many connections.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.</dd></dl>
<b>See Also</b>	
<a href="#Connect">connect()</a><b>,</b>
<a href="#Listen">listen()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>,</b>
<a href="#SetSockOpt">setsockopt()</a><b>,</b>
<a href="#Socket">socket()</a><b>,</b>
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a><b>.</b><p>

</p><hr><h3>
<a name="CloseSocket">closesocket()</a></h3>
<h4>Description</h4>
Close a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int FAR PASCAL closesocket ( SOCKET </b><i>s</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.</dd></dl>
<h4>Remarks</h4>
This function closes a socket.  More precisely, it releases the
socket descriptor <i>s</i>, so that further references to <i>s</i> will fail
with the error <a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>.  If this is the last reference to the underlying
socket, the associated naming information and queued data are discarded.<p>

The semantics of <b>closesocket</b>() are affected by the socket options
SO_LINGER and SO_DONTLINGER as follows:

</p><pre><b>Option		Interval	Type of close		Wait for close?</b>
---------------	---------------	-----------------------	----------------
SO_DONTLINGER	Don't care	Graceful		No

SO_LINGER	Zero		Hard			No

SO_LINGER	Non-zero	Graceful		Yes
</pre><p>
If SO_LINGER is set (i.e. the <i>l_onoff</i> field of the linger structure is
non-zero; see 
<a href="#Prog_SocketOptions">Socket
Options</a>, 
<a href="#GetSockOpt">getsockopt()</a>
and 
<a href="#SetSockOpt">setsockopt()</a>)
with a zero timeout interval (<i>l_linger</i> is zero), <b>closesocket()</b> is
not blocked even if queued data has not yet been sent or acknowledged.  This is
called a "hard" close, because the socket is closed immediately, and any unsent
data is lost.  Any 
<a href="#Recv">recv()</a>
call on the remote side of the circuit can fail with <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>.</p><p>

If SO_LINGER is set with a non-zero timeout interval, the <b>closesocket()</b>
call blocks until the remaining data has been sent or until the timeout
expires.  This is called a graceful disconnect.  Note that if the socket is set
to non-blocking and SO_LINGER is set to a non-zero timeout, the call to
<b>closesocket() </b>will fail with an error of <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>.

If SO_DONTLINGER is set on a stream socket (i.e. the <i>l_onoff</i> field of
the linger structure is zero; see 
<a href="#Prog_SocketOptions">Socket
Options</a>, 
<a href="#GetSockOpt">getsockopt()</a>
and 
<a href="#SetSockOpt">setsockopt()</a>),
the <b>closesocket()</b> call will return immediately.  However, any data
queued for transmission will be sent if possible before the underlying socket
is closed.  This is also called a graceful disconnect.  Note that in this case
the Windows Sockets implementation may not release the socket and other
resources for an arbitrary period, which may affect applications which expect
to use all available sockets.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>closesocket()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>
<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets call is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a><b>.</b>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as nonblocking and SO_LINGER is set to a nonzero
timeout value.
</dd><dt></dt></dl><p>
</p><h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#IOCTLSocket">ioctlsocket()</a><b>,
</b>
<a href="#SetSockOpt">setsockopt()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

</p><hr><h3>
<a name="Connect">connect()</a></h3>
<h4>Description</h4>
Establish a connection to a peer.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR connect ( SOCKET </b><i>s</i><b>, const struct sockaddr FAR
* </b><i>name</i><b>, int </b><i>namelen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying an unconnected socket.
</dd><dt><i>name</i>
</dt><dd>The name of the peer to which the socket is to be connected.
</dd><dt><i>namelen</i>
</dt><dd>The length of the <i>name</i>.</dd></dl>
<h4>Remarks</h4>
This function is used to create a connection to the specified
foreign association.  The parameter <i>s</i> specifies an unconnected datagram
or stream socket  If the socket is unbound, unique values are assigned to the
local association by the system, and the socket is marked as bound.  Note that
if the address field of the <i>name</i> structure is all zeroes,
<b>connect()</b> will return the error <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>.
<p>
For stream sockets (type SOCK_STREAM), an active connection is initiated to the
foreign host using <i>name</i> (an address in the name space of the socket).
When the socket call completes successfully, the socket is ready to
send/receive data.  </p><p>

For a datagram socket (type SOCK_DGRAM), a default destination is set, which
will be used on subsequent 
<a href="#Send">send()</a>
and 
<a href="#Recv">recv()</a>
calls.</p><p>

On a non-blocking socket, if the return value is SOCKET_ERROR an application
should call 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>
If this indicates an error code of <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>, then your application can
either:</p><p>

</p><ol>
<li> Use <b>select()</b> to determine the completion of the connection request
by checking if the socket is writeable, or

</li><li> If your application is using the message-based
<a href="#AsyncSelect">WSAAsyncSelect()</a> to indicate interest in connection
events, then your application will receive an FD_CONNECT message when the
connect operation is complete.
</li></ol>

<h4>Return Value</h4>
If no error occurs, <b>connect()</b> returns 0.  Otherwise,
it returns SOCKET_ERROR, and a specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b><p>

On a blocking socket, the return value indicates success or failure of the
connection attempt.</p><p>

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>
</dt><dd>The specified address is already in use.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets call is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>
</dt><dd>The specified address is not available from the local machine.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
</dt><dd>Addresses in the specified family cannot be used with this socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>
</dt><dd>The attempt to connect was forcefully rejected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDREQ">WSAEDESTADDREQ</a>
</dt><dd>A destination address is required.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>namelen</i> argument is incorrect.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket is not already bound to an address.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>
</dt><dd>The socket is already connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>
</dt><dd>No more file descriptors are available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>
</dt><dd>The network can't be reached from this host at this time.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No buffer space is available.  The socket cannot be connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>
</dt><dd>Attempt to connect timed out without establishing a connection
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a> 
</dt><dd>The socket is marked as non-blocking and the connection cannot be completed
immediately.  It is possible to 
<a href="#Select">select()</a>
the socket while it is connecting by <b>select()</b>ing it for writing.</dd></dl>
<h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>,
</b>
<a href="#Select">socket()</a>,
and 
<a href="#AsyncSelect">WSAAsyncSelect</a><b>.</b><p>

</p><hr><h3>
<a name="GetPeerName">getpeername()</a></h3>
<h4>Description</h4>
Get the address of the peer to which a socket is
connected.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR getpeername(SOCKET </b><i>s</i><b>, struct sockaddr FAR *
</b><i>name</i><b>, int FAR * </b><i>namelen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a connected socket.
</dd><dt><i>name</i>
</dt><dd>The structure which is to receive the name of the peer.
</dd><dt><i>namelen</i>
</dt><dd>A pointer to the size of the <i>name</i> structure.</dd></dl>
<h4>Remarks</h4>
<b>getpeername()</b> retrieves the name of the peer connected to
the socket <i>s</i> and stores it in the struct sockaddr identified by
<i>name</i>.  It is used on a connected datagram or stream socket.

On return, the <i>namelen</i> argument contains the actual size of the name
returned in bytes.
<p>

</p><h4>Return Value</h4>
If no error occurs, <b>getpeername()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The namelen argument is not large enough.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets call is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.</dd></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>.</b><p>

</p><hr><h3>
<a name="GetSockName">getsockname()</a></h3>
<h4>Description</h4>
Get the local name for a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR getsockname(SOCKET </b>s<b>, struct sockaddr FAR *
</b><i>name</i><b>, int FAR * </b><i>namelen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a bound socket.
</dd><dt><i>name</i>
</dt><dd>Receives the address (name) of the socket.
</dd><dt><i>namelen</i>
</dt><dd>The size of the <i>name</i> buffer.</dd></dl>
<h4>Remarks</h4>
<b>getsockname()</b> retrieves the current name for the
specified socket descriptor in <i>name</i>.  It is used on a bound and/or
connected socket specified by the <i>s</i> parameter.  The local association is
returned.  This call is especially useful when a 
<a href="#Connect">connect()</a>
call has been made without doing a 
<a href="#Bind">bind()</a>
first; this call provides the only means by which you can determine the local
association which has been set by the system.<p>

	On return, the <i>namelen</i> argument contains the actual size of the name
returned in bytes.
</p><p>
If a socket was bound to INADDR_ANY, indicating that any of the host's IP
addresses should be used for the socket, <b>getsockname()</b> will not
necessarily return information about the host IP address, unless the socket has
been connected with 
<a href="#Connect">connect()</a>
or 
<a href="#Accept">accept()</a><b>.</b>
A Windows Sockets application must not assume that the IP address will be
changed from INADDR_ANY unless the socket is connected.  This is because for a
multi-homed host the IP address that will be used for the socket is unknown
unless the socket is connected.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>getsockname()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>namelen</i> argument is not large enough.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket has not been bound to an address with 
<a href="#Bind">bind()</a><b>.</b></dd></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#GetPeerName">getpeername()</a><b>.</b><p>

</p><hr><h3>
<a name="GetSockOpt">getsockopt()</a></h3>
<h4>Description</h4>
Retrieve a socket option.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR getsockopt ( SOCKET </b><i>s</i><b>, int
</b><i>level</i><b>, int </b><i>optname</i><b>, char FAR *
</b><i>optval</i><b>, int FAR * </b><i>optlen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.
</dd><dt><i>level</i>
</dt><dd>The level at which the option is defined; the only supported <i>levels</i>
are SOL_SOCKET and IPPROTO_TCP.
</dd><dt><i>optname</i>
</dt><dd>The socket option for which the value is to be retrieved.
</dd><dt><i>optval</i>
</dt><dd>A pointer to the buffer in which the value for the requested option is to
be returned.
</dd><dt><i>optlen</i>
</dt><dd>A pointer to the size of the <i>optval</i> buffer.</dd></dl>
<h4>Remarks</h4>
<b>getsockopt()</b> retrieves the current value for a socket
option associated with a socket of any type, in any state, and stores the
result in <i>optval</i>.  Options may exist at multiple protocol levels, but
they are always present at the uppermost ``socket'' level.  Options affect
socket operations, such as whether an operation blocks or not, the routing of
packets, out-of-band data transfer, etc.

The value associated  with the selected option is returned in the buffer
<i>optval</i>.  The integer pointed to by  <i>optlen</i> should originally
contain the size of this buffer; on return, it will be set to the size of the
value returned.  For SO_LINGER, this will be the size of  a struct linger; for
all other options it will be the size of an integer.<p>

If the option was never set with 
<a href="#SetSockOpt">setsockopt()</a><b>,</b>
then <b>getsockopt()</b> returns the default value for the option.</p><p>

The following options are supported for <b>getsockopt()</b>.  The <b>Type</b>
identifies the type of data addressed by <i>optval</i>.  The TCP_NODELAY option
uses level IPPROTO_TCP, all other options use level SOL_SOCKET.

</p><pre><b><u>Value		Type		Meaning</u></b>
---------------	---------------	-----------------------------------------------
SO_ACCEPTCONN	BOOL		Socket is <a href="#Listen">listen()</a>ing.

SO_BROADCAST	BOOL		Socket is configured for the transmission of
				broadcast messages.

SO_DEBUG	BOOL		Debugging is enabled.  

SO_DONTLINGER	BOOL		If true, the SO_LINGER option is disabled..

SO_DONTROUTE	BOOL		Routing is disabled.

SO_ERROR	int		Retrieve error status and clear.

SO_KEEPALIVE	BOOL		Keepalives are being sent.

SO_LINGER	struct linger	Returns the current linger options.
		FAR *

SO_OOBINLINE	BOOL		Out-of-band data is being received in the
				normal data stream.  

SO_RCVBUF	int		Buffer size for receives

SO_REUSEADDR	BOOL		The socket may be bound to an address which
				is already in use.

SO_SNDBUF	int		Buffer size for sends

SO_TYPE		int		The type of the socket (e.g. SOCK_STREAM).  

TCP_NODELAY	BOOL		Disables the Nagle algorithm for send
				coalescing.
</pre>

BSD options not supported for <b>getsockopt()</b> are:

<pre><b><u>Value		Type		Meaning</u></b>
---------------	---------------	-----------------------------------------------
SO_RCVLOWAT	int		Receive low water mark

SO_RCVTIMEO	int		Receive timeout

SO_SNDLOWAT	int		Send low water mark

SO_SNDTIMEO	int		Send timeout

IP_OPTIONS			Get options in IP header.

TCP_MAXSEG	int		Get TCP maximum segment size.
</pre>
<p>
Calling <b>getsockopt()</b> with an unsupported option will result in an error
code of <a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a> being returned from 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>getsockopt()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>optlen</i> argument was invalid.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>
</dt><dd>The option is unknown or unsupported.  In particular, SO_BROADCAST is not
supported on sockets of type SOCK_STREAM, while SO_ACCEPTCON, SO_DONTLINGER,
SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type
SOCK_DGRAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>
</dt><dd>The option is unknown or unsupported.  In particular, SO_BROADCAST is not
supported on sockets of type SOCK_STREAM, while SO_ACCEPTCONN, SO_DONTLINGER,
SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type
SOCK_DGRAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.</dd></dl>
<h4>See Also</h4>
<a href="#SetSockOpt">setsockopt()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>,
</b>
<a href="#Socket">socket()</a><b>.</b><p>

</p><hr><h3>
<a name="HtoNL">htonl()</a></h3>
<h4>Description</h4>
Convert a <b>u_long </b>from host to network byte
order.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>u_long PASCAL FAR htonl ( u_long </b><i>hostlong</i><b>);</b>
</p><dl>
<dt><i>hostlong</i>
</dt><dd>A 32-bit number in host byte order.</dd></dl>
<h4>Remarks</h4>
This routine takes a 32-bit number in host byte order and
returns a 32-bit number in network byte order.
<p>

</p><h4>Return Value</h4>
<b>htonl()</b> returns the value in network byte order.

<h4>See Also</h4>
<a href="#HtoNS">htons()</a><b>,
</b>
<a href="#NtoHL">ntohl()</a><b>,
</b>
<a href="#NtoHS">ntohs()</a><b>.</b><p>

</p><hr><h3>
<a name="HtoNS">htons()</a></h3>
<h4>Description</h4>
Convert a <b>u_short </b>from host to network byte
order.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>u_short PASCAL FAR htons ( u_short </b><i>hostshort </i><b>);</b>
</p><dl>
<dt><i>hostshort</i>
</dt><dd>A 16-bit number in host byte order.</dd></dl>
<h4>Remarks</h4>
This routine takes a 16-bit number in host byte order and
returns a 16-bit number in network byte order.
<p>

</p><h4>Return Value</h4>
<b>htons()</b> returns the value in network byte order.

<h4>See Also</h4>
<a href="#HtoNL">htonl()</a><b>,
</b>
<a href="#NtoHL">ntohl()</a><b>,
</b>
<a href="#NtoHS">ntohs()</a><b>.</b><p>

</p><hr><h3>
<a name="InetAddr">inet_addr()</a></h3>
<h4>Description</h4>
Convert a string containing a dotted address into an
<b>in_addr</b>.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>unsigned long PASCAL FAR inet_addr ( const char FAR * </b><i>cp
</i><b>);</b>
</p><dl>
<dt><i>cp</i>
</dt><dd>A character string representing a number expressed in the Internet standard
``.'' notation.</dd></dl>
<h4>Remarks</h4>
This function interprets the character string specified by the
<i>cp</i> parameter.  This string represents a numeric Internet address
expressed in the Internet standard ``.'' notation.  The value returned is a
number suitable for use as an Internet address.  All Internet addresses are
returned in network order (bytes ordered from left to right).

<u>Internet Addresses</u><p>

Values specified using the ``.'' notation take one of the following forms:</p><p>
</p><ul>
<li>a.b.c.d
</li><li>a.b.c
</li><li>a.b
</li><li>a
</li></ul>
<p>
When four parts are specified, each is interpreted as a byte of data and
assigned, from left to right, to the four bytes of an Internet address.  Note
that when an Internet address is viewed as a 32-bit integer quantity on the
Intel architecture, the bytes referred to above appear as ``d.c.b.a''.  That is,
the bytes on an Intel processor are ordered from right to left.</p><p>

Note: The following notations are only used by Berkeley, and nowhere else on
the Internet.  In the interests of compatibility with their software, they are
supported as specified.</p><p>

When a three part address is specified, the last part is interpreted as a
16-bit quantity and placed in the right most two bytes of the network address.
This makes the three part address format convenient for specifying Class B
network addresses as ``128.net.host''.</p><p>

When a two part address is specified, the last part is interpreted as a 24-bit
quantity and placed in the right most three bytes of the network address.  This
makes the two part address format convenient for specifying Class A network
addresses as ``net.host''.</p><p>

When only one part is given, the value is stored directly in the network
address without any byte rearrangement.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>inet_addr()</b> returns an unsigned
long containing a suitable binary representation of the Internet address given.
If the passed-in string does not contain a legitimate Internet address, for
example if a portion of an ``a.b.c.d'' address exceeds 255, <b>inet_addr()
</b>returns the value INADDR_NONE.

<h4>See Also</h4>
<a href="#InetNtoA">inet_ntoa()</a><b>.</b><p>

</p><hr><h3>
<a name="InetNtoA">inet_ntoa()</a></h3>
<h4>Description</h4>
Convert a network address into a string in dotted
format.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>char FAR * PASCAL FAR inet_ntoa ( struct in_addr </b><i>in
</i><b>);</b>
</p><dl>
<dt><i>in</i>
</dt><dd>A structure which represents an Internet host address.</dd></dl>
<h4>Remarks</h4>
This function takes an Internet address structure specified by
the <i>in</i> parameter.  It returns an ASCII string representing the address
in ``.''  notation as ``a.b.c.d''.  Note that the string returned by
<b>inet_ntoa()</b> resides in memory which is allocated by the Windows Sockets
implementation.  The application should not make any assumptions about the way
in which the memory is allocated.  The data is guaranteed to be valid until the
next Windows Sockets API call within the same thread, but no longer.
<p>

</p><h4>Return Value</h4>
If no error occurs, <b>inet_ntoa()</b> returns a char
pointer to a static buffer containing the text address in standard ``.''
notation.  Otherwise, it returns NULL.  The data should be copied before
another Windows Sockets call is made.

<h4>See Also</h4>
<a href="#InetAddr">inet_addr()</a><b>.</b><p>

</p><hr><h3>
<a name="IOCTLSocket">ioctlsocket()</a></h3>
<h4>Description</h4>
Control the mode of a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR ioctlsocket ( SOCKET </b><i>s</i><b>, long
</b><i>cmd</i><b>, u_long FAR * </b><i>argp</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.
</dd><dt><i>cmd</i>
</dt><dd>The command to perform on the socket <i>s</i>.
</dd><dt><i>argp</i>
</dt><dd>A pointer to a parameter for <i>cmd</i>.</dd></dl>
<h4>Remarks</h4>
This routine may be used on any socket in any state.  It is used
to get or retrieve operating parameters associated with the socket, independent
of the protocol and communications subsystem.  The following commands are
supported:<p>

</p><dl>
<dt> <i>FIONBIO</i>
</dt><dd> Enable or disable non-blocking mode on the socket <i>s</i>.  <i>argp</i>
points at an <b>unsigned long</b>, which is non-zero if non-blocking mode is to
be enabled and zero if it is to be disabled.  When a socket is created, it
operates in blocking mode (i.e. non-blocking mode is disabled).  This is
consistent with BSD sockets.

<br> The <a href="#AsyncSelect">WSAAsyncSelect()</a> routine automatically sets
a socket to nonblocking mode.  If <b>WSAAsyncSelect() </b>has been issued on a
socket, then any attempt to use <b>ioctlsocket() </b>to set the socket back to
blocking mode will fail with <a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>.  To set the socket back to blocking
mode, an application must first disable <b>WSAAsyncSelect() </b>by calling
<b>WSAAsyncSelect() </b>with the <i>lEvent</i> parameter equal to 0.

</dd><dt> <i>FIONREAD</i>
</dt><dd> Determine the amount of data which can be read atomically from socket
<i>s</i>.  <i>argp</i> points at an <b>unsigned long</b> in which
<b>ioctlsocket()</b> stores the result.  If <i>s</i> is of type SOCK_STREAM,
FIONREAD returns the total amount of data which may be read in a single
<b>recv()</b>; this is normally the same as the total amount of data queued on
the socket.  If <i>s</i> is of type SOCK_DGRAM, FIONREAD returns the size of
the first datagram queued on the socket.

</dd><dt> <i>SIOCATMARK</i>
</dt><dd> Determine whether or not all out-of-band data has been read.  This applies
only to a socket of type SOCK_STREAM which has been configured for in-line
reception of any out-of-band data (SO_OOBINLINE).  If no out-of-band data is
waiting to be read, the operation returns TRUE.  Otherwise it returns FALSE,
and the next <a href="#Recv">recv()</a> or <a href="#RecvFrom">recvfrom()</a>
performed on the socket will retrieve some or all of the data preceding the
"mark"; the application should use the SIOCATMARK operation to determine
whether any remains.  If there is any normal data preceding the "urgent" (out
of band) data, it will be received in order.  (Note that a <a href="#Recv">recv()</a> or <a href="#RecvFrom">recvfrom()</a> will never mix
out-of-band and normal data in the same call.)  <i>argp</i> points at a
<b>BOOL</b> in which <b>ioctlsocket()</b> stores the result.
</dd></dl>

<h4>Compatibility</h4>
This function is a subset of <b>ioctl()</b> as used in
Berkeley sockets.  In particular, there is no command which is equivalent to
FIOASYNC, while SIOCATMARK is the only socket-level command which is
supported.<p>


</p><h4>Return Value</h4>
Upon successful completion, the <b>ioctlsocket()</b>
returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific
error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd><i>cmd</i> is not a valid command, or <i>argp</i> is not an acceptable
parameter for <i>cmd</i>, or the command is not applicable to the type of
socket supplied
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor <i>s</i> is not a socket.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#SetSockOpt">setsockopt()</a><b>,
</b>
<a href="#GetSockOpt">getsockopt()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

</p><hr><h3>
<a name="Listen">listen()</a></h3>
<h4>Description</h4>
Establish a socket to listen for incoming
connection.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR listen(SOCKET </b><i>s</i><b>, int </b><i>backlog
</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a bound, unconnected socket.
</dd><dt><i>backlog</i>
</dt><dd>The maximum length to which the queue of pending connections may grow.</dd></dl>
<h4>Remarks</h4>
To accept connections, a socket is first created with 
<a href="#Socket">socket()</a>,
a backlog for incoming connections is specified with <b>listen</b>(), and then
the connections are accepted with 
<a href="#Accept">accept()</a>.

<b>listen</b>() applies only to sockets that support connections, i.e. those
of type SOCK_STREAM.  The socket <i>s</i> is put into ``passive'' mode where
incoming connections are acknowledged and queued pending acceptance by the
process.<p>

This function is typically used by servers that could have more than one
connection request at a time: if a connection request arrives with the queue
full, the client will receive an error with an indication of <a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>.

<b>listen</b>() attempts to continue to function rationally when there are no
available descriptors.  It will accept connections until the queue is emptied.
If descriptors become available, a later call to <b>listen</b>() or 
<a href="#Accept">accept()</a>
will re-fill the queue to the current or most recent ``backlog'', if possible,
and resume listening for incoming connections.</p><p>


</p><h4>Compatibility</h4>
<i>backlog</i> is currently limited (silently) to 5.  As
in 4.3BSD, illegal values (less than 1 or greater than 5) are replaced by the
nearest legal value.

<h4>Return Value</h4>
If no error occurs, <b>listen()</b> returns 0.  Otherwise,
a value of SOCKET_ERROR is returned, and a specific error code may be retrieved
by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>
</dt><dd>An attempt has been made to <b>listen()</b> on an address in use.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>An invalid argument was given.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket has not been bound with 
<a href="#Bind">bind()</a>
or is already connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>
</dt><dd>The socket is already connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>
</dt><dd>No more file descriptors are available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No buffer space is available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>The referenced socket is not of a type that supports the <b>listen()</b>
operation.</dd></dl>
<h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
 </b>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#Socket">socket()</a><b>.</b><p>

</p><hr><h3>
<a name="NtoHL">ntohl()</a></h3>
<h4>Description</h4>
Convert a <b>u_long</b> from network to host byte
order.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>u_long PASCAL FAR ntohl ( u_long </b><i>netlong</i><b>);</b>
</p><dl>
<dt><i>netlong</i>
</dt><dd>A 32-bit number in network byte order.</dd></dl>
<h4>Remarks</h4>
This routine takes a 32-bit number in network byte order and
returns a 32-bit number in host byte order.
<p>

</p><h4>Return Value</h4>
<b>ntohl()</b> returns the value in host byte order.

<h4>See Also</h4>
<a href="#HtoNL">htonl()</a><b>,
</b>
<a href="#HtoNS">htons()</a><b>,
</b>
<a href="#NtoHS">ntohs()</a><b>.</b><p>

</p><hr><h3>
<a name="NtoHS">ntohs()</a></h3>
<h4>Description</h4>
Convert a <b>u_short </b>from network to host byte
order.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>u_short PASCAL FAR ntohs ( u_short </b><i>netshort </i><b>);</b>
</p><dl>
<dt><i>netshort</i>
</dt><dd>A 16-bit number in network byte order.</dd></dl>
<h4>Remarks</h4>
This routine takes a 16-bit number in network byte order and
returns a 16-bit number in host byte order.
<p>

</p><h4>Return Value</h4>
<b>ntohs()</b> returns the value in host byte order.

<h4>See Also</h4>
<a href="#HtoNL">htonl()</a><b>,
</b>
<a href="#HtoNS">htons()</a><b>,
</b>
<a href="#NtoHL">ntohl()</a><b>.</b><p>

</p><hr><h3>
<a name="Recv">recv()</a></h3>
<h4>Description</h4>
Receive data from a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR recv ( int </b><i>s</i><b>, char FAR * </b><i>buf</i><b>,
int </b><i>len</i><b>, int </b><i>flags</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a connected socket.
</dd><dt><i>buf</i>
</dt><dd>A buffer for the incoming data.
</dd><dt><i>len</i>
</dt><dd>The length of <i>buf</i>.
</dd><dt><i>flags</i>
</dt><dd>Specifies the way in which the call is made.</dd></dl>
<h4>Remarks</h4>
This function is used on connected datagram or stream sockets
specified by the <i>s</i> parameter and is used to read incoming data.<p>

For sockets of type SOCK_STREAM, as much information as is currently available
up to the size of the buffer supplied is returned.  If the socket has been
configured for in-line reception of out-of-band data (socket option
SO_OOBINLINE) and out-of-band data is unread, only out-of-band data will be
returned.  The application may use the 
<a href="#IOCTLSocket">ioctlsocket()</a>
SIOCATMARK to determine whether any more out-of-band data remains to be read.</p><p>

For datagram sockets, data is extracted from the first enqueued datagram, up to
the size of the size of the buffer supplied.  If the datagram is larger than
the buffer supplied, the excess data is lost, and <b>recv()</b> returns the
error <a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>.

If no incoming data is available at the socket, the <b>recv()</b> call waits
for data to arrive unless the socket is non-blocking.  In this case a value of
SOCKET_ERROR is returned with the error code set to <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>.  The 
<a href="#Select">select()</a>
or 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
calls may be used to determine when more data arrives.

If the socket is of type SOCK_STREAM and the remote side has shut down the
connection gracefully, a <b>recv()</b> will complete immediately with 0 bytes
received.  If the connection has been abortively disconnected, a <b>recv()
</b>will fail with the error <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>.</p><p>
<i></i></p><p>
<i>Flags</i> may be used to influence the behavior of the function invocation
beyond the options specified for the associated socket.  That is, the semantics
of this function are determined by the socket options and the <i>flags</i>
parameter.  The latter is constructed by or-ing any of the following values:

</p><dl>
<dt> MSG_PEEK
</dt><dd> Peek at the incoming data.  The data is copied into the buffer but is not
removed from the input queue.
</dd><dt> MSG_OOB
</dt><dd> Process out-of-band data (See <a href="#Sockets_OutOfBand">Out of Band
Data</a> for a discussion of this topic.)
</dd></dl>

<h4>Return Value</h4>
If no error occurs, <b>recv()</b> returns the number of
bytes received.  If the connection has been closed, it returns 0.  Otherwise, a
value of SOCKET_ERROR is returned, and a specific error code may be retrieved
by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>
</dt><dd>The socket has been shutdown; it is not possible to <b>recv()</b> on a
socket after 
<a href="#Shutdown">shutdown()</a>
has been invoked with <i>how</i> set to 0 or 2.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as non-blocking and the receive operation would block.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>
</dt><dd>The datagram was too large to fit into the specified buffer and was
truncated.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket has not been bound with <b>bind().</b>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
</dt><dd>The virtual circuit was aborted due to timeout or other failure.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>
</dt><dd>The virtual circuit was reset by the remote side.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#RecvFrom">recvfrom()</a><b>,
</b>
<a href="#Send">send()</a><b>,
</b>
<a href="#Select">select()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>,
</b>
<a href="#Socket">socket()</a><b>.</b><p>

</p><hr><h3>
<a name="RecvFrom">recvfrom()</a></h3>
<h4>Description</h4>
Receive a datagram and store the source address.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR recvfrom ( int </b><i>s</i><b>, char FAR *
</b><i>buf</i><b>, int </b><i>len</i><b>, int </b><i>flags</i><b>, struct
sockaddr FAR * </b><i>from</i><b>, int FAR * </b><i>fromlen
</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a bound socket.
</dd><dt><i>buf</i>
</dt><dd>A buffer for the incoming data.
</dd><dt><i>len</i>
</dt><dd>The length of <i>buf</i>.
</dd><dt><i>flags</i>
</dt><dd>Specifies the way in which the call is made.
</dd><dt><i>from</i>
</dt><dd>An optional pointer to a buffer which will hold the source address upon
return.
</dd><dt><i>fromlen</i>
</dt><dd>An optional pointer to the size of the <i>from</i> buffer.</dd></dl>
<h4>Remarks</h4>
This function is used to read incoming data on a (possibly
connected) socket and capture the address from which the data was sent.<p>

For sockets of type SOCK_STREAM, as much information as is currently available
up to the size of the buffer supplied is returned.  If the socket has been
configured for in-line reception of out-of-band data (socket option
SO_OOBINLINE) and out-of-band data is unread, only out-of-band data will be
returned.  The application may use the 
<a href="#IOCTLSocket">ioctlsocket()</a>
SIOCATMARK to determine whether any more out-of-band data remains to be read.
The <i>from </i>and <i>fromlen </i>parameters are ignored for SOCK_STREAM
sockets.</p><p>

For datagram sockets, data is extracted from the first enqueued datagram, up to
the size of the size of the buffer supplied.  If the datagram is larger than
the buffer supplied, the buffer is filled with the first part of the message,
the excess data is lost, and <b>recvfrom() </b>returns the error code
<a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>.

If <i>from</i> is non-zero, and the socket is of type SOCK_DGRAM, the network
address of the peer which sent the data is copied to the corresponding struct
sockaddr.  The value pointed to by <i>fromlen</i> is initialized to the size of
this structure, and is modified on return to indicate the actual size of the
address stored there.</p><p>

If no incoming data is available at the socket, the <b>recvfrom()</b> call
waits for data to arrive unless the socket is non-blocking.  In this case a
value of SOCKET_ERROR is returned with the error code set to <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>.
The 
<a href="#Select">select()</a>
or 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
calls may be used to determine when more data arrives.

If the socket is of type SOCK_STREAM and the remote side has shut down the
connection gracefully, a <b>recvfrom()</b> will complete immediately with 0
bytes received.  If the connection has been abortively disconnected, a
<b>recvfrom() </b>will fail with the error <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>.</p><p>
<i></i></p><p>
<i>Flags</i> may be used to influence the behavior of the function invocation
beyond the options specified for the associated socket.  That is, the semantics
of this function are determined by the socket options and the <i>flags</i>
parameter.  The latter is constructed by or-ing any of the following values:

</p><dl>
<dt>MSG_PEEK
</dt><dd>Peek at the incoming data.  The data is copied into the buffer but is not
removed from the input queue.
</dd><dt>MSG_OOB
</dt><dd>Process out-of-band data (See 
<a href="#Sockets_OutOfBand">Out
of Band Data</a> for a discussion of this topic.)
</dd></dl>

<h4>Return Value</h4>
If no error occurs, <b>recvfrom()</b> returns the number of
bytes received.  If the connection has been closed, it returns 0.  Otherwise, a
value of SOCKET_ERROR is returned, and a specific error code may be retrieved
by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>fromlen</i> argument was invalid: the <i>from</i> buffer was too
small to accommodate the peer address.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket has not been bound with 
<a href="#Bind">bind()</a>.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected (SOCK_STREAM only).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>
</dt><dd>The socket has been shutdown; it is not possible to <b>recvfrom()</b> on a
socket after 
<a href="#Shutdown">shutdown()</a>
has been invoked with <i>how</i> set to 0 or 2.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as non-blocking and the <b>recvfrom()</b> operation
would block.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>
</dt><dd>The datagram was too large to fit into the specified buffer and was
truncated.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
</dt><dd>The virtual circuit was aborted due to timeout or other failure.
</dd><dt>WSCONNRESET
</dt><dd>The virtual circuit was reset by the remote side.</dd></dl>
<h4>See Also</h4>
<a href="#Recv">recv()</a><b>,
</b>
<a href="#Send">send()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

</p><hr><h3>
<a name="Select">select()</a></h3>
<h4>Description</h4>
Determine the status of one or more sockets, waiting if
necessary.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>long PASCAL FAR select ( int </b><i>nfds</i><b>, fd_set FAR *
</b><i>readfds</i><b>, fd_set FAR * </b><i>writefds</i><b>, fd_set FAR *
</b><i>exceptfds</i><b>, const struct timeval FAR * </b><i>timeout
</i><b>);</b>
</p><dl>
<dt><i>nfds</i>
</dt><dd>This argument is ignored and included only for the sake of compatibility.
</dd><dt><i>readfds</i>
</dt><dd>An optional pointer to a set of sockets to be checked for readability.
</dd><dt><i>writefds</i>
</dt><dd>An optional pointer to a set of sockets to be checked for writeability
</dd><dt><i>exceptfds</i>
</dt><dd>An optional pointer to a set of sockets to be checked for errors.
</dd><dt><i>timeout</i>
</dt><dd>The maximum time for <b>select()</b> to wait, or NULL for blocking
operation.</dd></dl>
<h4>Remarks</h4>
This function is used to determine the status of one or more
sockets.  For each socket, the caller may request information on read, write or
error status.  The set of sockets for which a given status is requested is
indicated by an fd_set structure.  Upon return, the structure is updated to
reflect the subset of these sockets which meet the specified condition, and
<b>select()</b> returns the number of sockets meeting the conditions.  A set of
macros is provided for manipulating an fd_set.  These macros are compatible
with those used in the Berkeley software, but the underlying representation is
completely different.  
<p>
The parameter <i>readfds</i> identifies those sockets which are to be checked
for readability.  If the socket is currently 
<a href="#Listen">listen()</a>ing,
it will be marked as readable if an incoming connection request has been
received, so that an 
<a href="#Accept">accept()</a>
is guaranteed to complete without blocking.  For other sockets, readability
means that queued data is available for reading or,  for sockets of type
SOCK_STREAM, that the virtual socket corresponding to the socket has been
closed, so that a 
<a href="#Recv">recv()</a>
or 
<a href="#RecvFrom">recvfrom()</a>
is guaranteed to complete without blocking.  If the virtual circuit was closed
gracefully, then a 
<a href="#Recv">recv()</a>
will return immediately with 0 bytes read; if the virtual circuit was
closed abortively, then a 
<a href="#Recv">recv()</a>
will complete immediately with the error code <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>.  The presence
of out-of-band data will be checked if the socket option SO_OOBINLINE has been
enabled (see 
<a href="#SetSockOpt">setsockopt()</a>).</p><p>

The parameter <i>writefds</i> identifies those sockets which are to be checked
for writeability.  If a socket is 
<a href="#Connect">connect()</a>ing
(non-blocking), writeability means that the connection establishment is
complete.  For other sockets, writeability means that a 
<a href="#Send">send()</a>
or 
<a href="#SendTo">sendto()</a>
will complete without blocking.  [It is not specified how long this guarantee
can be assumed to be valid, particularly in a multithreaded environment.]</p><p>

The parameter <i>exceptfds</i> identifies those sockets which are to be checked
for the presence of out-of-band data or any exceptional error conditions.  Note
that out-of-band data will only be reported in this way if the option
SO_OOBINLINE is FALSE.  For a SOCK_STREAM, the breaking of the connection by
the peer or due to KEEPALIVE failure will be indicated as an exception.  This
specification does not define which other errors will be included.  If a socket
is <b>connect()</b>ing (non-blocking), failure of the connect attempt is
indicated in <i>exceptfds.</i></p><p>

Any of <i>readfds</i>, <i>writefds</i>, or <i>exceptfds</i> may be given as
NULL if no descriptors are of interest.

Four macros are defined in the header file <b>winsock.h</b> for manipulating
the descriptor sets.  The variable FD_SETSIZE determines the maximum number of
descriptors in a set.  (The default value of FD_SETSIZE is 64, which may be
modified by #defining FD_SETSIZE to another value before #including
<b>winsock.h</b>.)  Internally, an fd_set is represented as an array of
SOCKETs; the last valid entry is followed by an element set to INVALID_SOCKET.
The macros are:</p><p>

</p><dl>
<dt><b>FD_CLR(</b><i>s</i><b>, *</b><i>set</i><b>)</b>
</dt><dd>Removes the descriptor <i>s</i> from <i>set</i>.
</dd><dt><b>FD_ISSET(</b><i>s</i><b>, *</b><i>set</i><b>)</b>
</dt><dd>Nonzero if <i>s</i> is a member of the <i>set</i>, zero otherwise.
</dd><dt><b>FD_SET(</b><i>s</i><b>, *</b><i>set</i><b>)</b>
</dt><dd>	Adds descriptor <i>s</i> to <i>set</i>.
</dd><dt><b>FD_ZERO(*</b><i>set</i><b>)</b>
</dt><dd>	Initializes the <i>set</i> to the NULL set.
</dd><dt></dt></dl>The parameter <i>timeout</i> controls how long the <b>select()</b> may
take to complete.  If <i>timeout</i> is a null pointer, <b>select()</b> will
block indefinitely until at least one descriptor meets the specified criteria.
Otherwise, <i>timeout</i> points to a struct timeval which specifies the
maximum time that <b>select()</b> should wait before returning.  If the timeval
is initialized to {0, 0}, <b>select()</b> will return immediately; this is used
to "poll" the state of the selected sockets.  If this is the case, then the
<b>select() </b>call is considered nonblocking and the standard assumptions for
nonblocking calls apply.  For example, the blocking hook must not be called,
and the Windows Sockets implementation must not yield.
<p>

</p><h4>Return Value</h4>
<b>select()</b> returns the total number of descriptors
which are ready and contained in the fd_set structures, or 0 if the time limit
expired, or SOCKET_ERROR if an error occurred.  If the return value is
SOCKET_ERROR, 
<a href="#GetLastError">WSAGetLastError()</a>
may be used to retrieve a specific error code.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The <i>timeout</i> value is not valid.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>One of the descriptor sets contains an entry which is not a
socket.</dd></dl><p>
</p><h4>See Also</h4>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>,
</b>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#Recv">recv()</a><b>,
</b>
<a href="#RecvFrom">recvfrom()</a><b>,
</b>
<a href="#Send">send()</a><b>.</b><p>

</p><hr><h3>
<a name="Send">send()</a></h3>
<h4>Description</h4>
Send data on a connected socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR send ( SOCKET </b><i>s</i><b>, const char FAR *
</b><i>buf</i><b>, int </b><i>len</i><b>, int </b><i>flags
</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a connected socket.
</dd><dt><i>buf</i>
</dt><dd>A buffer containing the data to be transmitted.
</dd><dt><i>len</i>
</dt><dd>The length of the data in <i>buf</i>.
</dd><dt><i>flags</i>
</dt><dd>Specifies the way in which the call is made.</dd></dl>
<h4>Remarks</h4>
<b>send</b>() is used on connected datagram or stream sockets
and is used to write outgoing data on a socket.  For datagram sockets, care
must be taken not to exceed the maximum IP packet size of the underlying
subnets, which is given by the <i>iMaxUdpDg</i> element in the WSAData
structure returned by 
<a href="#Startup">WSAStartup()</a>.
If the data is too long to pass atomically through the underlying protocol the
error <a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a> is returned, and no data is transmitted.

Note that the successful completion of a <b>send()</b> does not indicate that
the data was successfully delivered.<p>

If no buffer space is available within the transport system to hold the data to
be transmitted, <b>send</b>() will block unless the socket has been placed in a
non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of
bytes written may be between 1 and the requested length, depending on buffer
availability on both the local and foreign hosts.  The 
<a href="#Select">select()</a>
call may be used to determine when it is possible to send more data.</p><p>

<i>Flags</i> may be used to influence the behavior of the function invocation
beyond the options specified for the associated socket.  That is, the semantics
of this function are determined by the socket options and the <i>flags</i>
parameter.  The latter is constructed by or-ing any of the following values:

</p><dl>
<dt> MSG_DONTROUTE
</dt><dd> Specifies that the data should not be subject to routing.  A Windows
Sockets supplier may choose to ignore this flag; see also the discussion of the
SO_DONTROUTE option in <a href="#Prog_SocketOptions">Socket Options</a>.

</dd><dt> MSG_OOB
</dt><dd> Send out-of-band data (SOCK_STREAM only; see also <a href="#Sockets_OutOfBand">Out of Band Data</a>)
</dd></dl>

<h4>Return Value</h4>
If no error occurs, <b>send()</b> returns the total number
of characters sent.  (Note that this may be less than the number indicated by
<i>len</i>.) Otherwise, a value of SOCKET_ERROR is returned, and a specific
error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt>WSAEACCES
</dt><dd>The requested address is a broadcast address, but the appropriate flag was
not set.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>buf</i> is not in a valid part of the user address space.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>
</dt><dd>The connection must be reset because the Windows Sockets implementation
dropped it.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>The Windows Sockets implementation reports a buffer deadlock.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>
</dt><dd>The socket has been shutdown; it is not possible to <b>send()</b> on a
socket after 
<a href="#Shutdown">shutdown()</a>
has been invoked with how set to 1 or 2.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as non-blocking and the requested operation would
block.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>
</dt><dd>The socket is of type SOCK_DGRAM, and the datagram is larger than the
maximum supported by the Windows Sockets implementation.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket has not been bound with 
<a href="#Bind">bind()</a><b>.</b>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
</dt><dd>The virtual circuit was aborted due to timeout or other failure.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>
</dt><dd>The virtual circuit was reset by the remote side.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#Recv">recv()</a><b>,
</b>
<a href="#RecvFrom">recvfrom()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#SendTo">sendto()</a><b>,
</b>
<a href="#Startup">WSAStartup()</a><b>.</b><p>

</p><hr><h3>
<a name="SendTo">sendto()</a></h3>
<h4>Description</h4>
Send data to a specific destination.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR sendto ( SOCKET </b><i>s</i><b>, const char FAR *
</b><i>buf</i><b>, int </b><i>len</i><b>, int </b><i>flags</i><b>, const struct
sockaddr FAR * </b><i>to</i><b>, int </b><i>tolen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.
</dd><dt><i>buf</i>
</dt><dd>A buffer containing the data to be transmitted.
</dd><dt><i>len</i>
</dt><dd>The length of the data in <i>buf</i>.
</dd><dt><i>flags</i>
</dt><dd>Specifies the way in which the call is made.
</dd><dt><i>to</i>
</dt><dd>A optional pointer to the address of the target socket.
</dd><dt><i>tolen</i>
</dt><dd>The size of the address in <i>to</i>.</dd></dl>
<h4>Remarks</h4>
<b>sendto</b>() is used on datagram or stream sockets and is
used to write outgoing data on a socket.  For datagram sockets, care must be
taken not to exceed the maximum IP packet size of the underlying subnets, which
is given by the <i>iMaxUdpDg</i> element in the WSAData structure returned by 
<a href="#Startup">WSAStartup()</a>.
If the data is too long to pass atomically through the underlying protocol the
error <a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a> is returned, and no data is transmitted.

Note that the successful completion of a <b>sendto()</b> does not indicate that
the data was successfully delivered.<p>

<b>sendto()</b> is normally used on a SOCK_DGRAM socket to send a datagram to a
specific peer socket identified by the <i>to</i> parameter.  On a SOCK_STREAM
socket, the <i>to</i> and <i>tolen </i>parameters are ignored; in this case the
<b>sendto()</b> is equivalent to 
<a href="#Send">send()</a>.</p><p>

To send a broadcast (on a SOCK_DGRAM only), the address in the <i>to</i>
parameter should be constructed using the special IP address INADDR_BROADCAST
(defined in <b>winsock.h</b>) together with the intended port number.  It is
generally inadvisable for a broadcast datagram to exceed the size at which
fragmentation may occur, which implies that the data portion of the datagram
(excluding headers) should not exceed 512 bytes.</p><p>

If no buffer space is available within the transport system to hold the data to
be transmitted, <b>sendto</b>() will block unless the socket has been placed in
a non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of
bytes written may be between 1 and the requested length, depending on buffer
availability on both the local and foreign hosts.  The 
<a href="#Select">select()</a>
call may be used to determine when it is possible to send more data.</p><p>

<i>Flags</i> may be used to influence the behavior of the function invocation
beyond the options specified for the associated socket.  That is, the semantics
of this function are determined by the socket options and the <i>flags</i>
parameter.  The latter is constructed by or-ing any of the following values:

</p><dl>
<dt> MSG_DONTROUTE
</dt><dd> Specifies that the data should not be subject to routing.  A Windows
Sockets supplier may choose to ignore this flag; see also the discussion of the
SO_DONTROUTE option in <a href="#Prog_SocketOptions">Socket Options</a>.

</dd><dt> MSG_OOB
</dt><dd> Send out-of-band data (SOCK_STREAM only; see also <a href="#Sockets_OutOfBand">Out of Band Data</a>)
</dd></dl>

<h4>Return Value</h4>
If no error occurs, <b>sendto()</b> returns the total
number of characters sent.  (Note that this may be less than the number
indicated by <i>len</i>.) Otherwise, a value of SOCKET_ERROR is returned, and a
specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt>WSAEACCES
</dt><dd>The requested address is a broadcast address, but the appropriate flag was
not set.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>buf</i> or <i>to</i> are not in a valid part of the user address
space, or the to argument is too small (less than the sizeof a struct sockaddr).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>
</dt><dd>The connection must be reset because the Windows Sockets implementation
dropped it.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>The Windows Sockets implementation reports a buffer deadlock.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected (SOCK_STREAM only).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
</dt><dd>MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>
</dt><dd>The socket has been shutdown; it is not possible to <b>sendto()</b> on a
socket after 
<a href="#Shutdown">shutdown()</a>
has been invoked with how set to 1 or 2.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The socket is marked as non-blocking and the requested operation would
block.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>
</dt><dd>The socket is of type SOCK_DGRAM, and the datagram is larger than the
maximum supported by the Windows Sockets implementation.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
</dt><dd>The virtual circuit was aborted due to timeout or other failure.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>
</dt><dd>The virtual circuit was reset by the remote side.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>
</dt><dd>The specified address is not available from the local machine.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
</dt><dd>Addresses in the specified family cannot be used with this socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDRREQ">WSAEDESTADDRREQ</a>
</dt><dd>A destination address is required.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>
</dt><dd>The network can't be reached from this host at this time.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#Recv">recv()</a><b>,
</b>
<a href="#RecvFrom">recvfrom()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#Send">send()</a><b>,
</b>
<a href="#Startup">WSAStartup()</a><b>.</b><p>

</p><hr><h3>
<a name="SetSockOpt">setsockopt()</a></h3>
<h4>Description</h4>
Set a socket option.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR setsockopt ( SOCKET </b><i>s</i><b>, int
</b><i>level</i><b>, int </b><i>optname</i><b>, const char FAR *
</b><i>optval</i><b>, int </b><i>optlen</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.
</dd><dt><i>level</i>
</dt><dd>The level at which the option is defined; the only supported <i>levels</i>
are SOL_SOCKET and IPPROTO_TCP.
</dd><dt><i>optname</i>
</dt><dd>The socket option for which the value is to be set.
</dd><dt><i>optval</i>
</dt><dd>A pointer to the buffer in which the value for the requested option is
supplied.
</dd><dt><i>optlen</i>
</dt><dd>The size of the <i>optval</i> buffer.</dd></dl>
<h4>Remarks</h4>
<b>setsockopt()</b> sets the current value for a socket option
associated with a socket of any type, in any state.  Although options may exist
at multiple protocol levels, this specification only defines options that exist
at the uppermost ``socket'' level.  Options affect socket operations, such as
whether expedited data is received in the normal data stream, whether broadcast
messages may be sent on the socket, etc.  

There are two types of socket options: Boolean options that enable or disable a
feature or behavior, and options which require an integer value or structure.
To enable a Boolean option, <i>optval</i> points to a nonzero integer.  To
disable the option <i>optval</i> points to an integer equal to zero.
<i>optlen</i> should be equal to sizeof(int) for Boolean options.  For other
options, <i>optval</i> points to the an integer or structure that contains the
desired value for the option, and <i>optlen</i> is the length of the integer or
structure.<p>

SO_LINGER controls the action taken when unsent data is queued on a socket and a 
<a href="#CloseSocket">closesocket()</a>
is performed.  See 
<a href="#CloseSocket">closesocket()</a>
for a description of the way in which the SO_LINGER settings affect the
semantics of 
<a href="#CloseSocket">closesocket()</a>.
The application sets the desired behavior by creating a <i>struct linger</i>
(pointed to by the <i>optval</i> argument) with the following elements:</p><p>


</p><pre>struct linger {
	int	l_onoff;
	int	l_linger;
}
</pre>
<p>
To enable SO_LINGER, the application should set <i>l_onoff</i> to a non-zero
value, set <i>l_linger</i> to 0 or the desired timeout (in seconds), and call
<b>setsockopt()</b>.  To enable SO_DONTLINGER (i.e. disable SO_LINGER)
<i>l_onoff</i> should be set to zero and <b>setsockopt()</b> should be
called.</p><p>

By default, a socket may not be bound (see 
<a href="#Bind">bind()</a>)
to a local address which is already in use.  On occasions, however, it may be
desirable to "re-use" an address in this way.  Since every connection is
uniquely identified by the combination of local and remote addresses, there is
no problem with having two sockets bound to the same local address as long as
the remote addresses are different.  To inform the Windows Sockets
implementation that a 
<a href="#Bind">bind()</a>
on a socket should not be disallowed because the desired address is already in
use by another socket, the application should set the SO_REUSEADDR socket
option for the socket before issuing the 
<a href="#Bind">bind()</a>.
Note that the option is interpreted only at the time of the 
<a href="#Bind">bind()</a>:
it is therefore unnecessary (but harmless) to set the option on a socket which
is not to be bound to an existing address, and setting or resetting the option
after the 
<a href="#Bind">bind()</a>
has no effect on this or any other socket..</p><p>

An application may request that the Windows Sockets implementation enable the
use of "keep-alive" packets on TCP connections by turning on the SO_KEEPALIVE
socket option.  A Windows Sockets implementation need not support the use of
keep-alives: if it does, the precise semantics are implementation-specific but
should conform to section 4.2.3.6 of RFC 1122: <i>Requirements for Internet
Hosts -- Communication Layers</i>.  If a connection is dropped as the result of
"keep-alives" the error code <a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a> is returned to any calls in progress
on the socket, and any subsequent calls will fail with <a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>.  </p><p>

The TCP_NODELAY option disables the Nagle algorithm.  The Nagle algorithm is
used to reduce the number of small packets sent by a host by buffering
unacknowledged send data until a full-size packet can be sent.  However, for
some applications this algorithm can impede performance, and TCP_NODELAY may be
used to turn it off.  Application writers should not set TCP_NODELAY unless the
impact of doing so is well-understood and desired, since setting TCP_NODELAY
can have a significant negative impact of network performance.  TCP_NODELAY is
the only supported socket option which uses <i>level</i> IPPROTO_TCP; all other
options use level SOL_SOCKET.</p><p>

Windows Sockets suppliers are encouraged (but not required) to supply output
debug information if the SO_DEBUG option is set by an application.  The
mechanism for generating the debug information and the form it takes are beyond
the scope of this specification.

The following options are supported for <b>setsockopt()</b>.  The <u>Type</u>
identifies the type of data addressed by <i>optval</i>.

</p><pre><b><u>Value		Type		Meaning</u></b>
--------------- ---------------	-----------------------------------------------
SO_BROADCAST	BOOL		Allow transmission of broadcast messages on the
				socket.

SO_DEBUG	BOOL		Record debugging information.  

SO_DONTLINGER	BOOL		Don't block close waiting for unsent data to be
				sent.  Setting this option is equivalent to
				setting SO_LINGER with <i>l_onoff</i> set to
				zero.

SO_DONTROUTE	BOOL		Don't route: send directly to interface.

SO_KEEPALIVE	BOOL		Send keepalives

SO_LINGER	struct linger	Linger on close if unsent data is present
		FAR *

SO_OOBINLINE	BOOL		Receive out-of-band data in the normal data
				stream.  

SO_RCVBUF	int		Specify buffer size for receives

SO_REUSEADDR	BOOL		Allow the socket to be bound to an address
				which is already in use.  (See <a href="#Bind">bind()</a>.)

SO_SNDBUF	int		Specify buffer size for sends

TCP_NODELAY	BOOL		Disables the Nagle algorithm for send
				coalascing.
</pre><p>

BSD options not supported for <b>setsockopt()</b> are:</p><p>

</p><pre><b><u>Value		Type		Meaning</u></b>
--------------- ---------------	-----------------------------------------------
SO_ACCEPTCON	BOOL		Socket is listening

SO_ERROR	int		Get error status and clear

SO_RCVLOWAT	int		Receive low water mark

SO_RCVTIMEO	int		Receive timeout

SO_SNDLOWAT	int		Send low water mark

SO_SNDTIMEO	int		Send timeout

SO_TYPE		int		Type of the socket

IP_OPTIONS			Set options field in IP header.
</pre><p>

</p><h4>Return Value</h4>
If no error occurs, <b>setsockopt()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd><i>optval</i> is not in a valid part of the process address  space.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd><i>level</i> is not valid, or the information in optval is not valid.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>
</dt><dd>Connection has timed out when SO_KEEPALIVE is set.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>
</dt><dd>The option is unknown or unsupported.  In particular, SO_BROADCAST is not
supported on sockets of type SOCK_STREAM, while SO_DONTLINGER, SO_KEEPALIVE,
SO_LINGER and SO_OOBINLINE are not supported on sockets of type SOCK_DGRAM.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>Connection has been reset when SO_KEEPALIVE is set.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.</dd></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#GetSockOpt">getsockopt()</a><b>,
</b>
<a href="#IOCTLSocket">ioctlsocket()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

</p><hr><h3>
<a name="ShutDown">shutdown()</a></h3>
<h4>Description</h4>
Disable sends and/or receives on a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR shutdown ( SOCKET </b><i>s</i><b>, int </b><i>how
</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying a socket.
</dd><dt><i>how</i>
</dt><dd>A flag that describes what types of operation will no longer be
allowed.</dd></dl>
<h4>Remarks</h4>
<b>shutdown</b>() is used on all types of sockets to disable
reception, transmission, or both.<p>

If <i>how</i> is 0, subsequent receives on the socket will be disallowed.  This
has no effect on the lower protocol layers.  For TCP, the TCP window is not
changed and incoming data will be accepted (but not acknowledged) until the
window is exhausted.  For UDP, incoming datagrams are accepted and queued.  In
no case will an ICMP error packet be generated.</p><p>

If <i>how</i> is 1, subsequent sends are disallowed.  For TCP sockets, a FIN
will be sent.</p><p>

Setting <i>how</i> to 2 disables both sends and receives as described above.

Note that <b>shutdown()</b> does not close the socket, and resources attached
to the socket will not be freed until 
<a href="#CloseSocket">closesocket()</a>
is invoked.</p><p>


</p><h4>Comments</h4>
<b>shutdown()</b> does not block regardless of the SO_LINGER
setting on the socket.
<p>
An application should not rely on being able to re-use a socket after it has
been shut down.  In particular, a Windows Sockets implementation is not
required to support the use of 
<a href="#Connect">connect()</a>
on such a socket.

</p><h4>Return Value</h4>
If no error occurs, <b>shutdown()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>how is not valid.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected (SOCK_STREAM only).
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is not a socket.</dd></dl>
<h4>See Also</h4>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#Socket">socket()</a><b>.</b><p>

</p><hr><h3>
<a name="Socket">socket()</a></h3>
<h4>Description</h4>
Create a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>SOCKET PASCAL FAR socket ( int </b><i>af</i><b>, int </b><i>type</i><b>,
int </b><i>protocol</i><b>);</b>
</p><dl>
<dt><i>af</i>
</dt><dd>An address format specification.  The only format currently supported is
PF_INET, which is the ARPA Internet address format.
</dd><dt><i>type</i>
</dt><dd>A type specification for the new socket.
</dd><dt><i>protocol</i>
</dt><dd>A particular protocol to be used with the socket, or 0 if the caller does
not wish to specify a protocol.</dd></dl>
<h4>Remarks</h4>
<b>socket()</b> allocates a socket descriptor of the specified
address family, data type and protocol, as well as related resources.  If a
protocol is not specified (i.e. equal to 0), the default for the specified
connection mode is used.

Only a single protocol exists to support a particular socket type using a given
address format.  However, the address family may be given as AF_UNSPEC
(unspecified), in which case the <i>protocol</i> parameter must be specified.
The protocol number to use is particular to the ``communication domain'' in
which communication is to take place.<p>

The following <i>type</i> specifications are supported:</p><p>

</p><dl>
<dt> SOCK_STREAM
</dt><dd> Provides sequenced, reliable, two-way, connection-based byte streams with
an out-of-band data transmission mechanism.  Uses TCP for the Internet address
family.

</dd><dt> SOCK_DGRAM
</dt><dd> Supports datagrams, which are connectionless, unreliable buffers of a
fixed (typically small) maximum length.  Uses UDP for the Internet address
family.
</dd></dl>

Sockets of type SOCK_STREAM are full-duplex byte streams.  A stream socket must
be in a connected state before any data may be sent or received on it.  A
connection to another socket is created with a 
<a href="#Connect">connect()</a>
call.  Once connected, data may be transferred using 
<a href="#Send">send()</a>
and 
<a href="#Recv">recv()</a>
calls.  When a session has been completed, a 
<a href="#CloseSocket">closesocket()</a>
must be performed.  Out-of-band data may also be transmitted as described in 
<a href="#Send">send()</a>
and received as described in 
<a href="#Recv">recv()</a>.<p>

The communications protocols used to implement a SOCK_STREAM ensure that data
is not lost or duplicated.  If data for which the peer protocol has buffer
space cannot be successfully transmitted within a reasonable length of time,
the connection is considered broken and subsequent calls will fail with the
error code set to <a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>.</p><p>

SOCK_DGRAM sockets allow sending and receiving of datagrams to and from
arbitrary peers using 
<a href="#SendTo">sendto()</a>
and 
<a href="#RecvFrom">recvfrom()</a>.
If such a socket is 
<a href="#Connect">connect()</a>ed
to a specific peer, datagrams may be send to that peer 
<a href="#Send">send()</a>
and may be received from (only) this peer using 
<a href="#Recv">recv()</a>.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>socket()</b> returns a descriptor
referencing the new socket.  Otherwise, a value of INVALID_SOCKET is returned,
and a specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
</dt><dd>The specified address family is not supported..
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>
</dt><dd>No more file descriptors are available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No buffer space is available.  The socket cannot be created.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEPROTONOSUPPORT">WSAEPROTONOSUPPORT</a>
</dt><dd>The specified protocol is not supported.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEPROTOTYPE">WSAEPROTOTYPE</a>
</dt><dd>The specified protocol is the wrong type for this socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAESOCKTNOSUPPORT">WSAESOCKTNOSUPPORT</a>
</dt><dd>The specified socket type is not supported in this address family.</dd></dl>
<h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>,
</b>
<a href="#GetSockOpt">getsockopt()</a><b>,
</b>
<a href="#SetSockOpt">setsockopt()</a><b>,
</b>
<a href="#Listen">listen()</a><b>,
</b>
<a href="#Recv">recv()</a><b>,
</b>
<a href="#RecvFrom">recvfrom()</a><b>,
</b>
<a href="#Select">select()</a><b>,
</b>
<a href="#Send">send()</a><b>,
</b>
<a href="#SendTo">sendto()</a><b>,
</b>
<a href="#Shutdown">shutdown()</a><b>,
</b>
<a href="#IOCTLSocket">ioctlsocket()</a><b>.</b>
<hr><h2>
<a name="Ref_DatabaseRoutines">Database Routines</a></h2>
<a href="#GetHostByAddr">gethostbyaddr()</a><p>
<a href="#GetHostByName">gethostbyname()</a></p><p>
<a href="#GetHostName">gethostname()</a></p><p>
<a href="#GetProtoByName">getprotobyname()</a></p><p>
<a href="#GetProtoByNumber">getprotobynumber()</a></p><p>
<a href="#GetServByName">getservbyname()</a></p><p>
<a href="#GetServByPort">getservbyport()</a></p><p>

</p><hr><h3>
<a name="GetHostByAddr">gethostbyaddr()</a></h3>
<h4>Description</h4>
Get host information corresponding to an address.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct hostent FAR * PASCAL FAR gethostbyaddr ( const char FAR *
</b><i>addr</i><b>, int </b><i>len</i><b>, int </b><i>type
</i><b>);</b>
</p><dl>
<dt><i>addr</i>
</dt><dd>A pointer to an address in network byte order.
</dd><dt><i>len</i>
</dt><dd>The length of the address, which must be 4 for PF_INET addresses.
</dd><dt><i>type</i>
</dt><dd>The type of the address, which must be PF_INET.</dd></dl>
<h4>Remarks</h4>
<b>gethostbyaddr</b>() returns a pointer to the following
structure which contains the name(s) and address which correspond to the given
address.  <p>


</p><pre>struct hostent {
	char FAR *	h_name;
	char FAR * FAR *h_aliases;
	short		h_addrtype;
	short		h_length;
	char FAR * FAR *h_addr_list;
};
</pre>

The members of this structure are:

<dl>
<dt> <i>h_name</i>
</dt><dd> Official name of the host (PC).

</dd><dt> <i>h_aliases</i>
</dt><dd> A NULL -terminated array of alternate names.

</dd><dt> <i>h_addrtype</i>
</dt><dd> The type of address being returned; for Windows Sockets this is always
PF_INET.

</dd><dt> <i>h_length</i>
</dt><dd> The length, in bytes, of each address; for PF_INET, this is always 4.

</dd><dt> <i>h_addr_list</i>
</dt><dd> A NULL-terminated list of addresses for the host.  Addresses are returned
in network byte order.
</dd></dl>

The macro h_addr is defined to be h_addr_list[0] for compatibility with older
software.<p>

The pointer which is returned points to a structure which is allocated by the
Windows Sockets implementation.  The application must never attempt to modify
this structure or to free any of its components.  Furthermore, only one copy of
this structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API
calls.</p><p>


</p><h4>Return Value</h4>
If no error occurs, <b>gethostbyaddr()</b> returns a
pointer to the hostent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a><b>,
</b>
<a href="#GetHostByName">gethostbyname()</a><b>,</b><p>

</p><hr><h3>
<a name="GetHostByName">gethostbyname()</a></h3>
<h4>Description</h4>
Get host information corresponding to a hostname.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct hostent FAR * PASCAL FAR gethostbyname ( const char FAR *
</b><i>name</i><b>);</b>
</p><dl>
<dt><i>name</i>
</dt><dd>A pointer to the name of the host.</dd></dl>
<h4>Remarks</h4>
<b>gethostbyname</b>() returns a pointer to a hostent structure
as described under 
<a href="#GetHostByAddr">gethostbyaddr()</a>.
The contents of this structure correspond to the hostname <i>name</i>.

The pointer which is returned points to a structure which is allocated by the
Windows Sockets implementation.  The application must never attempt to modify
this structure or to free any of its components.  Furthermore, only one copy of
this structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API
calls.<p>

A <b>gethostbyname() </b>implementation must not resolve IP address strings
passed to it.  Such a request should be treated exactly as if an unknown host
name were passed.  An application with an IP address string to resolve should
use 
<a href="#InetAddr">inet_addr()</a>
to convert the string to an IP address, then 
<a href="#GetHostByAddr">gethostbyaddr()</a>
to obtain the hostent structure.</p><p>


</p><h4>Return Value</h4>
If no error occurs, <b>gethostbyname()</b> returns a
pointer to the hostent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a><b>,
</b>
<a href="#GetHostByAddr">gethostbyaddr()</a><p>

</p><hr><h3>
<a name="GetHostName">gethostname()</a></h3>
<h4>Description</h4>
Return the standard host name for the local
machine.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR gethostname ( char FAR * </b><i>name</i><b>, int
</b><i>namelen</i><b> );</b>
</p><dl>
<dt><i>name</i>
</dt><dd>A pointer to a buffer that will receive the host name.
</dd><dt><i>namelen</i>
</dt><dd>The length of the buffer.
</dd><dt></dt></dl>
<h4>Remarks</h4>
This routine returns the name of the local host into
the buffer specified by the <i>name </i>parameter.  The host name is returned
as a null-terminated string.  The form of the host name is dependent on the
Windows Sockets implementation--it may be a simple host name, or it may be a
fully qualified domain name.  However, it is guaranteed that the name returned
will be successfully parsed by <b>gethostbyname() </b>and
<b>WSAAsyncGetHostByName().</b><p>

</p><h4>Return Value</h4>
If no error occurs, <b>gethostname() </b>reutrns 0,
otherwise it returns SOCKET_ERROR and a specific error code may be retrieved by
calling 
<a href="#GetLastError">WSAGetLastError()</a>.<p>

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The <i>namelen </i>parameter is too small
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful <b>WSAStartup() </b>must occur before using
this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the
network subsystem has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd></dl>
<h4>See Also</h4>
<a href="#GetHostByName">gethostbyname()</a><b>,
</b>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a><b>.</b><p>

</p><hr><h3>
<a name="GetProtoByName">getprotobyname()</a></h3>
<h4>Description</h4>
Get protocol information corresponding to a protocol
name.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct protoent FAR * PASCAL FAR getprotobyname ( const char FAR *
</b><i>name</i><b>);</b>
</p><dl>
<dt><i>name</i>
</dt><dd>A pointer to a protocol name.</dd></dl>
<h4>Remarks</h4>
<b>getprotobyname</b>() returns a pointer to the following
structure which contains the name(s) and protocol number which correspond to
the given protocol <i>name</i>.  


<pre>struct protoent {
	char FAR *	p_name;
	char FAR * FAR *p_aliases;
	short		p_proto;
};
</pre>

The members of this structure are:

<dl>
<dt> <i>p_name</i>
</dt><dd> Official name of the protocol.

</dd><dt> <i>p_aliases</i>
</dt><dd> A NULL-terminated array of alternate names.

</dd><dt> <i>p_proto</i>
</dt><dd> The protocol number, in host byte order.
</dd></dl>

<p>
The pointer which is returned points to a structure which is allocated by the
Windows Sockets library.  The application must never attempt to modify this
structure or to free any of its components.  Furthermore only one copy of this
structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API calls.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>getprotobyname()</b> returns a
pointer to the protoent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a><b>,
</b>
<a href="#GetProtoByNumber">getprotobynumber()</a><b>.</b><p>

</p><hr><h3>
<a name="GetProtoByNumber">getprotobynumber()</a></h3>
<h4>Description</h4>
Get protocol information corresponding to a protocol
number.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct protoent FAR * PASCAL FAR getprotobynumber ( int </b><i>number
</i><b>);</b>
</p><dl>
<dt><i>number</i>
</dt><dd>A protocol number, in host byte order.</dd></dl>
<h4>Remarks</h4>
This function returns a pointer to a protoent structure as
described above in <b>getprotobyname()</b>.  The contents of the structure
correspond to the given protocol number.

The pointer which is returned points to a structure which is allocated by the
Windows Sockets implementation.  The application must never attempt to modify
this structure or to free any of its components.  Furthermore, only one copy of
this structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API calls.
<p>

</p><h4>Return Value</h4>
If no error occurs, <b>getprotobynumber()</b> returns a
pointer to the protoent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a><b>,
</b>
<a href="#GetProtoByName">getprotobyname()</a><p>

</p><hr><h3>
<a name="GetServByName">getservbyname()</a></h3>
<h4>Description</h4>
Get service information corresponding to a service name and
protocol.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct servent FAR * PASCAL FAR getservbyname ( const char FAR *
</b><i>name</i><b>, const char FAR * </b><i>proto</i><b>);</b>
</p><dl>
<dt><i>name</i>
</dt><dd>A pointer to a service name.
</dd><dt><i>proto</i>
</dt><dd>An optional pointer to a protocol name.  If this is NULL,
<b>getservbyname()</b> returns the first service entry for which the
<i>name</i> matches the s_name or one of the s_aliases.  Otherwise
<b>getservbyname()</b> matches both the <i>name </i>and the <i>proto</i>.</dd></dl>
<h4>Remarks</h4>
<b>getservbyname()</b> returns a pointer to the following
structure which contains the name(s) and service number which correspond to the
given service <i>name</i>.  <p>


</p><pre>struct servent {
	char FAR *	s_name;
	char FAR * FAR *s_aliases;
	short		s_port;
	char FAR *	s_proto;
};
</pre>

The members of this structure are:

<dl>
<dt> <i>s_name</i>
</dt><dd> Official name of the service.

</dd><dt> <i>s_aliases</i>
</dt><dd> A NULL-terminated array of alternate names.

</dd><dt> <i>s_port</i>
</dt><dd> The port number at which the service may be contacted.  Port numbers are
in network byte order.

</dd><dt> <i>s_proto</i>
</dt><dd> The name of the protocol to use when contacting the service.
</dd></dl>

<p>
The pointer which is returned points to a structure which is allocated by the
Windows Sockets library.  The application must never attempt to modify this
structure or to free any of its components.  Furthermore only one copy of this
structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API calls.
</p><p>

</p><h4>Return Value</h4>
If no error occurs, <b>getservbyname()</b> returns a
pointer to the servent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful <b>WSAStartup()</b> must occur before using
this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
</dd><dt></dt></dl><p>
<b>See Also</b>	
<a href="#AsyncGetServByName">WSAAsyncGetServByName()</a>,
<a href="#GetServByPort">getservbyport()</a></p><p>

</p><hr><h3><a name="GetServByPort">getservbyport()</a></h3>

<h4>Description</h4>
Get service information corresponding to a port and
protocol.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>struct servent FAR * PASCAL FAR getservbyport ( int </b><i>port</i><b>,
const char FAR * </b><i>proto</i><b>);</b>
</p><dl>
<dt><i>port</i>
</dt><dd>The port for a service, in network byte order.
</dd><dt><i>proto</i>
</dt><dd>An optional pointer to a protocol name.  If this is NULL,
<b>getservbyport()</b> returns the first service entry for which the <i>port
</i>matches the s_port.  Otherwise <b>getservbyport()</b> matches both the
<i>port</i> and the <i>proto</i>.</dd></dl>
<h4>Remarks</h4>
<b>getservbyport()</b> returns a pointer a servent structure as
described above for 
<a href="#GetServByName">getservbyname()</a>.

The pointer which is returned points to a structure which is allocated by the
Windows Sockets implementation.  The application must never attempt to modify
this structure or to free any of its components.  Furthermore, only one copy of
this structure is allocated per thread, and so the application should copy any
information which it needs before issuing any other Windows Sockets API calls.
<p>

</p><h4>Return Value</h4>
If no error occurs, <b>getservbyport()</b> returns a
pointer to the servent structure described above.  Otherwise it returns a NULL
pointer and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b><p>

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>
</dt><dd>The (blocking) call was canceled via <b>WSACancelBlockingCall()</b>
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a><b>,
</b>
<a href="#GetServByName">getservbyname()</a>

<hr><h2><a name="Ref_WindowsExtensions">Microsoft Windows-specific Extensions</a></h2>

<a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a><p>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a></p><p>
<a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a></p><p>
<a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a></p><p>
<a href="#AsyncGetServByName">WSAAsyncGetServByName()</a></p><p>
<a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a></p><p>
<a href="#AsyncSelect">WSAAsyncSelect()</a></p><p>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a></p><p>
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a></p><p>
<a href="#Cleanup">WSACleanup()</a></p><p>
<a href="#GetLastError">WSAGetLastError()</a></p><p>
<a href="#IsBlocking">WSAIsBlocking()</a></p><p>
<a href="#SetBlockingHook">WSASetBlockingHook()</a></p><p>
<a href="#SetLastError">WSASetLastError()</a></p><p>
<a href="#Startup">WSAStartup()</a></p><p>
<a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>

</p><hr><h3>
<a name="AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a></h3>
<h4>Description</h4>
Get host information corresponding to an address -
asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetHostByAddr ( HWND </b><i>hWnd</i><b>, unsigned
int </b><i>wMsg</i><b>, const char FAR * </b><i>addr</i><b>, int
</b><i>len</i><b>, int </b><i>type</i><b>, char FAR * </b><i>buf</i><b>, int
</b><i>buflen</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>addr</i>
</dt><dd>Apointer to the network address for the host.  Host addresses are
stored in network byte order.
</dd><dt><i>len</i>
</dt><dd>The length of the address, which must be 4 for PF_INET.
</dd><dt><i>type</i>
</dt><dd>The type of the address, which must be PF_INET.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the hostent data.  Note that this
must be larger than the size of a hostent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a hostent structure but any and all of the data which is referenced by members
of the hostent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of 
<a href="#GetHostByAddr">gethostbyaddr()</a>,
and is used to retrieve host name and address information corresponding to a
network address.  The Windows Sockets implementation initiates the operation
and returns to the caller immediately, passing back an <b>asynchronous task
handle</b> which the application may use to identify the operation.  When the
operation is completed, the results (if any) are copied into the buffer
provided by the caller and a message is sent to the application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a hostent structure.
To access the elements of this structure, the original buffer address should be
cast to a hostent structure pointer and accessed as appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetHostByAddr() </b>function call with a buffer large enough to
receive all the desired  information (i.e.  no smaller than the low 16 bits of
<i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <u>not</u> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetHostByAddr()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetHostByAddr()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a hostent structure together with the
contents of data areas referenced by members of the same hostent structure.  To
avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a buffer
of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl>
<h4>See Also</h4>
<a href="#GetHostByAddr">gethostbyaddr()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncGetHostByName">WSAAsyncGetHostByName()</a></h3>
<h4>Description</h4>
Get host information corresponding to a hostname -
asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetHostByName ( HWND </b><i>hWnd</i><b>, unsigned
int </b><i>wMsg</i><b>, const char FAR * </b><i>name</i><b>, char FAR *
</b><i>buf</i><b>, int </b><i>buflen</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>name</i>
</dt><dd>Apointer to the name of the host.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the hostent data.  Note that this
must be larger than the size of a hostent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a hostent structure but any and all of the data which is referenced by members
of the hostent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of
<b>gethostbyname()</b>, and is used to retrieve host name and address
information corresponding to a hostname.  The Windows Sockets implementation
initiates the operation and returns to the caller immediately, passing back an
<b>asynchronous task handle</b> which the application may use to identify the
operation.  When the operation is completed, the results (if any) are copied
into the buffer provided by the caller and a message is sent to the
application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a hostent structure.
To access the elements of this structure, the original buffer address should be
cast to a hostent structure pointer and accessed as appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetHostByName() </b>function call with a buffer large enough to
receive all the desired  information (i.e. no smaller than the low 16 bits of
<i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  
</p><p>

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <u>not</u> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetHostByName()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetHostByName()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a hostent structure together with the
contents of data areas referenced by members of the same hostent structure.  To
avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a buffer
of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl>
<h4>See Also</h4>
<a href="#GetHostByName">gethostbyname()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncGetProtoByName">WSAAsyncGetProtoByName()</a></h3>
<h4>Description</h4>
Get protocol information corresponding to a protocol name -
asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetProtoByName ( HWND </b><i>hWnd</i><b>,
unsigned int </b><i>wMsg</i><b>, const char FAR * </b><i>name</i><b>, char FAR
* </b><i>buf</i><b>, int </b><i>buflen</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>name</i>
</dt><dd>Apointer to the protocol name to be resolved.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the protoent data.  Note that this
must be larger than the size of a protoent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a protoent structure but any and all of the data which is referenced by members
of the protoent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of 
<a href="#GetProtoByName">getprotobyname()</a>,
and is used to retrieve the protocol name and number corresponding to a
protocol name.  The Windows Sockets implementation initiates the operation and
returns to the caller immediately, passing back an <b>asynchronous task
handle</b> which the application may use to identify the operation.  When the
operation is completed, the results (if any) are copied into the buffer
provided by the caller and a message is sent to the application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a protoent
structure.  To access the elements of this structure, the original buffer
address should be cast to a protoent structure pointer and accessed as
appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetProtoByName() </b>function call with a buffer large enough to
receive all the desired  information (i.e.  no smaller than the low 16 bits of
<i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  
</p><p>

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <u>not</u> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetProtoByName()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetProtoByName()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a protoent structure together with the
contents of data areas referenced by members of the same protoent structure.
To avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a
buffer of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl>
<h4>See Also</h4>
<a href="#GetProtoByName">getprotobyname()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a></h3>
<h4>Description</h4>
Get protocol information corresponding to a protocol number
- asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetProtoByNumber ( HWND </b><i>hWnd</i><b>,

unsigned int </b><i>wMsg</i><b>, int </b><i>number</i><b>, char FAR *
</b><i>buf</i><b>, int </b><i>buflen</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>number</i>
</dt><dd>The protocol number to be resolved, in host byte order.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the protoent data.  Note that this
must be larger than the size of a protoent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a protoent structure but any and all of the data which is referenced by members
of the protoent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of 
<a href="#GetProtoByNumber">getprotobynumber()</a>,
and is used to retrieve the protocol name and number corresponding to a
protocol number.  The Windows Sockets implementation initiates the operation
and returns to the caller immediately, passing back an <b>asynchronous task
handle</b> which the application may use to identify the operation.  When the
operation is completed, the results (if any) are copied into the buffer
provided by the caller and a message is sent to the application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a protoent
structure.  To access the elements of this structure, the original buffer
address should be cast to a protoent structure pointer and accessed as
appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetProtoByNumber() </b>function call with a buffer large enough
to receive all the desired  information (i.e. no smaller than the low 16 bits
of <i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  
</p><p>

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <u>not</u> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetProtoByNumber()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetProtoByNumber()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a protoent structure together with the
contents of data areas referenced by members of the same protoent structure.
To avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a
buffer of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl><b>See Also
</b>
<a href="#GetProtoByNumber">getprotobynumber()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncGetServByName">WSAAsyncGetServByName()</a></h3>
<h4>Description</h4>
Get service information corresponding to a service name and
port -- asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetServByName ( HWND </b><i>hWnd</i><b>, unsigned
int </b><i>wMsg</i><b>, const char FAR * </b><i>name</i><b>, const char FAR *
</b><i>proto</i><b>, char FAR * </b><i>buf</i><b>, int </b><i>buflen
</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>name</i>
</dt><dd>A pointer to a service name.
</dd><dt><i>proto</i>
</dt><dd>A pointer to a protocol name.  This may be NULL, in which case
<b>WSAAsyncGetServByName()</b> will search for the first service entry for
which <i>s_name</i> or one of the <i>s_aliases</i> matches the given
<i>name</i>.  Otherwise <b>WSAAsyncGetServByName()</b> matches both <i>name</i>
and <i>proto</i>.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the servent data.  Note that this
must be larger than the size of a servent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a servent structure but any and all of the data which is referenced by members
of the servent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of 
<a href="#GetServByName">getservbyname()</a>,
and is used to retrieve service information corresponding to a service name.
The Windows Sockets implementation initiates the operation and returns to the
caller immediately, passing back an <b>asynchronous task handle</b> which the
application may use to identify the operation.  When the operation is
completed, the results (if any) are copied into the buffer provided by the
caller and a message is sent to the application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a hostent structure.
To access the elements of this structure, the original buffer address should be
cast to a hostent structure pointer and accessed as appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetServByName() </b>function call with a buffer large enough to
receive all the desired  information (i.e. no smaller than the low 16 bits of
<i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  
</p><p>

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <b>not</b> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetServByName()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetHostByAddr()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a hostent structure together with the
contents of data areas referenced by members of the same hostent structure.  To
avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a buffer
of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl><p>
</p><h4>See Also</h4>
<a href="#GetServByName">getservbyname()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncGetServByPort">WSAAsyncGetServByPort()</a></h3>
<h4>Description</h4>
Get service information corresponding to a port and protocol
- asynchronous version.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>HANDLE PASCAL FAR WSAAsyncGetServByPort ( HWND </b><i>hWnd</i><b>, unsigned
int </b><i>wMsg</i><b>, int </b><i>port</i><b>, const char FAR *
</b><i>proto</i><b>, char FAR * </b><i>buf</i><b>, int </b><i>buflen
</i><b>);</b>
</p><dl>
<dt><i>hWnd</i>
</dt><dd>The handle of the window which should receive a message when the
asynchronous request completes.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when the asynchronous request completes.
</dd><dt><i>port</i>
</dt><dd>The port for the service, in network byte order.
</dd><dt><i>proto</i>
</dt><dd>A pointer to a protocol name.  This may be NULL, in which case
<b>WSAAsyncGetServByPort()</b> will search for the first service entry for
which <i>s_port</i> match the given <i>port</i>.  Otherwise
<b>WSAAsyncGetServByPort()</b> matches both <i>port</i> and <i>proto</i>.
</dd><dt><i>buf</i>
</dt><dd>A pointer to the data area to receive the servent data.  Note that this
must be larger than the size of a servent structure.  This is because the data
area supplied is used by the Windows Sockets implementation to contain not only
a servent structure but any and all of the data which is referenced by members
of the servent structure.  It is recommended that you supply a buffer of
MAXGETHOSTSTRUCT bytes.
</dd><dt><i>buflen</i>
</dt><dd>The size of data area <i>buf</i> above.</dd></dl>
<h4>Remarks</h4>
This function is an asynchronous version of 
<a href="#GetServByPort">getservbyport()</a>,
and is used to retrieve service information corresponding to a port number.
The Windows Sockets implementation initiates the operation and returns to the
caller immediately, passing back an <b>asynchronous task handle</b> which the
application may use to identify the operation.  When the operation is
completed, the results (if any) are copied into the buffer provided by the
caller and a message is sent to the application's window.

When the asynchronous operation is complete the application's window
<i>hWnd</i> receives message <i>wMsg</i>.  The <i>wParam</i> argument contains
the asynchronous task handle as returned by the original function call.  The
high 16 bits of <i>lParam</i> contain any error code.  The error code may be
any error as defined in <b>winsock.h</b>.  An error code of zero indicates
successful completion of the asynchronous operation.  On successful completion,
the buffer supplied to the original function call contains a servent structure.
To access the elements of this structure, the original buffer address should be
cast to a servent structure pointer and accessed as appropriate.<p>

Note that if the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>, it indicates that the size of the
buffer specified by <i>buflen</i> in the original call was too small to contain
all the resultant information.  In this case, the low 16 bits of <i>lParam</i>
contain the size of buffer required to supply ALL the requisite information.
If the application decides that the partial data is inadequate, it may reissue
the <b>WSAAsyncGetServByPort() </b>function call with a buffer large enough to
receive all the desired  information (i.e. no smaller than the low 16 bits of
<i>lParam</i>).</p><p>

The error code and buffer length should be extracted from the <i>lParam</i>
using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
<b>winsock.h</b> as:</p><p>


</p><pre>#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  
</p><p>

</p><h4>Return Value</h4>
The return value specifies whether or not the asynchronous
operation was successfully initiated.  Note that it does <b>not</b> imply
success or failure of the operation itself.

If the operation was successfully initiated, <b>WSAAsyncGetServByPort()</b>
returns a nonzero value of type HANDLE which is the asynchronous task handle
for the request.  This value can be used in two ways.  It can be used to cancel
the operation using 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>.
It can also be used to match up asynchronous operations and completion
messages, by examining the <i>wParam</i> message argument.<p>

If the asynchronous operation could not be initiated,
<b>WSAAsyncGetServByPort()</b> returns a zero value, and a specific error
number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.</p><p>

</p><h4>Comments</h4>
The buffer supplied to this function is used by the Windows
Sockets implementation to construct a servent structure together with the
contents of data areas referenced by members of the same servent structure.  To
avoid the <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a> error noted above, the application should provide a buffer
of at least MAXGETHOSTSTRUCT bytes (as defined in <b>winsock.h</b>).

<h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets implementation
to ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when
constructing the <i>lParam</i> in the message.

</p><h4>Error Codes</h4>
The following error codes may be set when an application
window receives a message.  As described above, they may be extracted from the
<i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No/insufficient buffer space is available
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>
</dt><dd>Authoritative Answer Host not found.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>
</dt><dd>Non-Authoritative Host not found, or SERVERFAIL.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
</dt><dd>Non recoverable errors, FORMERR, REFUSED, NOTIMP.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
</dt><dd>Valid name, no data record of requested type.
</dd><dt></dt></dl>The following errors may occur at the time of the function call, and
indicate that the asynchronous operation could not be initiated.
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
</dt><dd>The asynchronous operation cannot be scheduled at this time due to resource
or other constraints within the Windows Sockets implementation.</dd></dl>
<h4>See Also</h4>
<a href="#GetServByPort">getservbyport()</a><b>,
</b>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a><p>

</p><hr><h3>
<a name="AsyncSelect">WSAAsyncSelect()</a></h3>
<h4>Description</h4>
Request event notification for a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSAAsyncSelect ( SOCKET </b><i>s</i><b>, HWND
</b><i>hWnd</i><b>, unsigned int </b><i>wMsg</i><b>, long </b><i>lEvent
</i><b>);</b>
</p><dl>
<dt><i>s</i>
</dt><dd>A descriptor identifying the socket for which event notification is
required.
</dd><dt><i>hWnd</i>
</dt><dd>A handle identifying the window which should receive a message when a
network event occurs.
</dd><dt><i>wMsg</i>
</dt><dd>The message to be received when a network event occurs.
</dd><dt><i>lEvent</i>
</dt><dd>A bitmask which specifies a combination of network events in which the
application is interested.</dd></dl>
<h4>Remarks</h4>
This function is used to request that the Windows Sockets DLL
should send a message to the window <i>hWnd</i> whenever it detects any of the
network events specified by the <i>lEvent</i> parameter.  The message which
should be sent is specified by the <i>wMsg</i> parameter.  The socket for which
notification is required is identified by <i>s</i>.

The <i>lEvent</i> parameter is constructed by or'ing any of the values
specified in the following list.

<dl>
<dt> FD_READ
</dt><dd> Want to receive notification of readiness for reading

</dd><dt> FD_WRITE
</dt><dd> Want to receive notification of readiness for writing

</dd><dt> FD_OOB
</dt><dd> Want to receive notification of the arrival of out-of-band data

</dd><dt> FD_ACCEPT
</dt><dd> Want to receive notification of incoming connections

</dd><dt> FD_CONNECT
</dt><dd> Want to receive notification of completed connection

</dd><dt> FD_CLOSE
</dt><dd> Want to receive notification of socket closure
</dd></dl>

Issuing a <b>WSAAsyncSelect()</b> for a socket cancels any previous
<b>WSAAsyncSelect()</b> for the same socket.  For example, to receive
notification for both reading and writing, the application must call
<b>WSAAsyncSelect()</b> with both FD_READ and FD_WRITE, as follows:<p>


</p><pre>rc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);
</pre>
<p>
It is not possible to specify different messages for different events.  The
following code will <b>not</b> work; the second call will cancel the effects of
the first, and only FD_WRITE events will be reported with message wMsg2:</p><p>


</p><pre>rc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);
rc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);
</pre>
<p>
To cancel all notification -- i.e., to indicate that the Windows Sockets
implementation should send no further messages related to network events on the
socket -- <i>lEvent</i> should be set to zero.  </p><p>


</p><pre>rc = WSAAsyncSelect(s, hWnd, 0, 0);
</pre>
<p>
Although in this instance <b>WSAAsyncSelect()</b> immediately disables event
message posting for the socket, it is possible that messages may be waiting in
the application's message queue.  The application must therefore be prepared to
receive network event messages even after cancellation.  Closing a socket with 
<a href="#CloseSocket">closesocket()</a>
also cancels <b>WSAAsyncSelect()</b> message sending, but the same caveat
about messages in the queue prior to the 
<a href="#CloseSocket">closesocket()</a>
still applies.</p><p>

Since an 
<a href="#Accept">accept()</a><b>'</b>ed
socket has the same properties as the listening socket used to accept it, any
<b>WSAAsyncSelect() </b>events set for the listening socket apply to the
accepted socket.  For example, if a listening socket has <b>WSAAsyncSelect()
</b>events FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that
listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE events with
the same <i>wMsg</i> value used for messages.  If a different <i>wMsg</i> or
events are desired, the application should call <b>WSAAsyncSelect()</b>,
passing the accepted socket and the desired new information.</p><p>

[Note: There is a timing window between the 
<a href="#Accept">accept()</a>
call and the call to <b>WSAAsyncSelect() </b>to change the events or
<i>wMsg</i>.  An application which desires a different <i>wMsg</i> for the
listening and 
<a href="#Accept">accept()</a>'ed
sockets should ask for only FD_ACCEPT events on the listening socket, then set
appropriate events after the 
<a href="#Accept">accept()</a>.
Since FD_ACCEPT is never sent for a connected socket and FD_READ, FD_WRITE,
FD_OOB, and FD_CLOSE are never sent for listening sockets, this will not impose
difficulties.]</p><p>

When one of the nominated network events occurs on the specified socket
<i>s</i>, the application's window <i>hWnd</i> receives message <i>wMsg</i>.
The <i>wParam</i> argument identifies the socket on which a network event has
occurred.  The low word of <i>lParam</i> specifies the network event that has
occurred.  The high word of <i>lParam</i> contains any error code.  The error
code be any error as defined in <b>winsock.h</b>.</p><p>

The error and event codes may be extracted from the <i>lParam</i> using the
macros WSAGETSELECTERROR and WSAGETSELECTEVENT, defined in <b>winsock.h</b>
as:</p><p>


</p><pre>#define WSAGETSELECTERROR(lParam)            HIWORD(lParam)
#define WSAGETSELECTEVENT(lParam)            LOWORD(lParam)
</pre>
<p>
The use of these macros will maximize the portability of the source code for
the application.  </p><p>

The possible network event codes which may be returned are as follows:</p><p>

</p><dl>
<dt> FD_READ
</dt><dd> Socket <i>s</i> ready for reading

</dd><dt> FD_WRITE
</dt><dd> Socket <i>s</i> ready for writing

</dd><dt> FD_OOB
</dt><dd> Out-of-band data ready for reading on socket <i>s</i>.

</dd><dt> FD_ACCEPT
</dt><dd> Socket <i>s</i> ready for accepting a new incoming connection

</dd><dt> FD_CONNECT
</dt><dd> Connection on socket <i>s</i> completed

</dd><dt> FD_CLOSE
</dt><dd> Connection identified by socket <i>s</i> has been closed
</dd></dl>

<h4>Return Value</h4>
The return value is 0 if the application's declaration of
interest in the network event set was successful.  Otherwise the value
SOCKET_ERROR is returned, and a specific error number may be retrieved by
calling <b>WSAGetLastError()</b>.

<h4>Comments</h4>
Although <b>WSAAsyncSelect()</b> can be called with interest in
multiple events, the application window will receive a single message for each
network event.

As in the case of the <b>select()</b> function, <b>WSAAsyncSelect()</b> will
frequently be used to determine when a data transfer operation (<b>send()</b>
or <b>recv()</b>) can be issued with the expectation of immediate success.
Nevertheless, a robust application must be prepared for the possibility that it
may receive a message and issue a Windows Sockets API call which returns
<a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a> immediately.  For example, the following sequence of events is
possible:

<ol>
<li> data arrives on socket <b>s</b>; Windows Sockets posts
<b>WSAAsyncSelect</b> message

</li><li> application processes some other message

</li><li> while processing, application issues an
<a href="#IOCTLSocket">ioctlsocket(s, FIONREAD...)</a> and notices that
there is data ready to be read

</li><li> application issues a <a href="#Recv">recv(s,...)</a> to read the
data

</li><li> application loops to process next message, eventually reaching the
<b>WSAAsyncSelect</b> message indicating that data is ready to read

</li><li> application issues <a href="#Recv">recv(s,...)</a>, which fails
with the error <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>.
</li></ol><p>

Other sequences are possible.  </p><p>

The Windows Sockets DLL will not continually flood an application with messages
for a particular network event.  Having successfully posted notification of a
particular event to an application window, no further message(s) for that
network event will be posted to the application window until the application
makes the function call which implicitly re-enables notification of that
network event.

</p><dl>
<dt> FD_READ
</dt><dd> <a href="#Recv">recv()</a> or <a href="#RecvFrom">recvfrom()</a><p>

</p></dd><dt> FD_WRITE
</dt><dd> <a href="#Send">send()</a> or <a href="#SendTo">sendto()</a><p>

</p></dd><dt> FD_OOB
</dt><dd> <a href="#Recv">recv()</a><p>

</p></dd><dt> FD_ACCEPT
</dt><dd> <a href="#Accept">accept()</a><p>

</p></dd><dt> FD_CONNECT
</dt><dd> NONE<p>

</p></dd><dt> FD_CLOSE
</dt><dd> NONE
</dd></dl>

Any call to the reenabling routine, even one which fails, results in reenabling
of message posting for the relevent event.<p>

For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is
"level-triggerred."  This means that if the reenabling routine is called and
the relevent event is still valid after the call, a <b>WSAAsyncSelect()
</b>message is posted to the application.  This allows an application to be
event-driven and not concern itself with the amount of data that arrives at any
one time.  Consider the following sequence:</p><p>

</p><ol>
<li>Windows Sockets DLL receives 100 bytes of data on socket <b>s </b>and posts
an FD_READ message.

</li><li>The application issues <b>recv( s, buffptr, 50, 0)</b> to read 50 bytes.

</li><li>The Windows Sockets DLL posts another FD_READ message since there is still
data to be read.
</li></ol>
<p>
With these semantics, an application need not read all available data
in response to an FD_READ message--a single 
<a href="#Recv">recv()</a>
in response to each FD_READ message is appropriate.  If an application
issues multiple 
<a href="#Recv">recv()</a>
calls in response to a single FD_READ, it may receive multiple FD_READ
messages.  Such an application may wish to disable FD_READ messages before
starting the 
<a href="#Recv">recv()</a>
calls by calling <b>WSAAsyncSelect() </b>with the FD_READ event not set.</p><p>

If an event is true when the application initially calls
<b>WSAAsyncSelect()</b> or when the reenabling function is called, then a
message is posted as appropriate.  For example, if an application calls 
<a href="#Listen">listen()</a>,
a connect attempt is made, then the application calls <b>WSAAsyncSelect()
</b>specifying that it wants to receive FD_ACCEPT messages for the socket, the
Windows Sockets implementation posts an FD_ACCEPT message immediately.</p><p>

The FD_WRITE event is handled slightly differently.  An FD_WRITE message is
posted when a socket is first connected with 
<a href="#Connect">connect()</a>
or accepted with 
<a href="#Accept">accept()</a>,
and then after a 
<a href="#Send">send()</a>
or 
<a href="#SendTo">sendto()</a>
fails with <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a> and buffer space becomes available.  Therefore,
an application can assume that sends are possible starting from the first
FD_WRITE message and lasting until a send returns <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>.  After such a
failure the application will be notified that sends are again possible with an
FD_WRITE message.</p><p>

The FD_OOB event is used only when a socket is configured to receive
out-of-band data separately.  If the socket is configured to receive
out-of-band data in-line, the out-of-band (expedited) data is treated as normal
data and the application should register an interest in, and will  receive,
FD_READ events, <u>not</u> FD_OOB events.  An application may set or inspect
the way in which out-of-band data is to be handled by using 
<a href="#SetSockOpt">setsockopt()</a>
or 
<a href="#GetSockOpt">getsockopt</a>
for the SO_OOBINLINE option.</p><p>

The error code in an FD_CLOSE message indicates whether the socket close was
graceful or abortive.  If the error code is 0, then the close was graceful; if
the error code is <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>, then the socket's virtual socket was
abortively disconnected.  This only applies to sockets of type SOCK_STREAM.  </p><p>

The FD_CLOSE message is posted when a close indication is received for the
virtual circuit corresponding to the socket.  In TCP terms, this means that the
FD_CLOSE is posted when the connection goes into the FIN WAIT or CLOSE WAIT
states.  This results from the remote end performing a 
<a href="#ShutDown">shutdown()</a>
on the send side or a 
<a href="#CloseSocket">closesocket()</a>.</p><p>

Please note your application will receive ONLY an FD_CLOSE message to indicate
closure of a virtual circuit. It will NOT receive an FD_READ message to
indicate this condition.</p><p>

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>Indicates that one of the specified parameters was invalid
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt>Additional error codes may be set when an application window receives a
message.  This error code is extracted from the <i>lParam</i> in the reply
message using the WSAGETSELECTERROR macro.  Possible error codes for each
network event are:</dt></dl><b>Event: FD_CONNECT</b>
<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>
</dt><dd>The specified address is already in use.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>
</dt><dd>The specified address is not available from the local machine.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
</dt><dd>Addresses in the specified family cannot be used with this socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>
</dt><dd>The attempt to connect was forcefully rejected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDRREQ">WSAEDESTADDRREQ</a>
</dt><dd>A destination address is required.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>
</dt><dd>The namelen argument is incorrect.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The socket is already bound to an address.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>
</dt><dd>The socket is already connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>
</dt><dd>No more file descriptors are available.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>
</dt><dd>The network can't be reached from this host at this time.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
</dt><dd>No buffer space is available.  The socket cannot be connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
</dt><dd>The socket is not connected.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
</dt><dd>The descriptor is a file, not a socket.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>
</dt><dd>Attempt to connect timed out without establishing a connection</dd></dl><p>
<b>Event: FD_CLOSE</b>
</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>
</dt><dd>The connection is reset by the remote side.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
</dt><dd>The connection was aborted due to timeout or other failure.</dd></dl><p>
<b>Event: FD_READ</b><br>
<b>Event: FD_WRITE</b><br>
<b>Event: FD_OOB</b><br>
<b>Event: FD_ACCEPT</b>
</p><h4>Error Code</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt></dt></dl><h4>Notes For
Windows Sockets
Suppliers</h4>

It is the responsibility of the Windows Sockets Supplier to
ensure that messages are successfully posted to the application.  If a
<b>PostMessage()</b> operation fails, the Windows Sockets implementation
<b>must</b> re-post that message as long as the window exists.
<p>
Windows Sockets suppliers should use the WSAMAKESELECTREPLY macro when
constructing the <i>lParam</i> in the message.

When a socket is closed, the Windows Sockets Supplier should purge any messages
remaining for posting to the application window.  However the application must
be prepared to receive, and discard, any messages which may have been posted
prior to the 
<a href="#CloseSocket">closesocket()</a>.

</p><h4>See Also</h4>
<a href="#Select">select()</a><p>

</p><hr><h3>
<a name="CancelAsyncRequest">WSACancelAsyncRequest()</a></h3>
<h4>Description</h4>
Cancel an incomplete asynchronous operation.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSACancelAsyncRequest ( HANDLE </b><i>hAsyncTaskHandle
</i><b>);</b>
</p><dl>
<dt><i>hAsyncTaskHandle</i>
</dt><dd>Specifies the asynchronous operation to be canceled.</dd></dl>
<h4>Remarks</h4>
The <b>WSACancelAsyncRequest()</b> function is used to cancel an
asynchronous operation which was initiated by one of the
<b>WSAAsyncGetXByY()</b> functions such as 
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a>.
The operation to be canceled is identified by the <i>hAsyncTaskHandle</i>
parameter, which should be set to the asynchronous task handle as returned by
the initiating function.

<b>Return Value</b>	The value returned by
<b>WSACancelAsyncRequest()</b> is 0 if the operation was successfully canceled.
Otherwise the value SOCKET_ERROR is returned, and a specific error number may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Comments</h4>
An attempt to cancel an existing asynchronous
<b>WSAAsyncGetXByY()</b> operation can fail with an error code of <a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>
for two reasons.  Firstly, the original operation has already completed and the
application has dealt with the resultant message.  Secondly, the original
operation has already completed but the resultant message is still waiting in
the application window queue.<p>

</p><h4>Notes For
Windows Sockets
Suppliers</h4>

It is unclear whether the application can usefully distinguish
between <a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a> and <a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>, since in both cases the error indicates that
there is no asynchronous operation in progress with the indicated handle.
[Trivial exception: 0 is always an invalid asynchronous task handle.]  The
Windows Sockets specification does not prescribe how a conformant Windows
Sockets implementation should distinguish between the two cases.  For maximum
portability, a Windows Sockets application should treat the two errors as
equivalent.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>Indicates that the specified asynchronous task handle was invalid
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>
</dt><dd>The asynchronous routine being canceled has already completed.
</dd><dt></dt></dl>
<h4>See Also</h4>
<a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a><b>,
</b>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a><b>,
</b>
<a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a><b>,
</b>
<a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a><b>,
</b>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a><b>,
</b>
<a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a><b>,
</b>
<a href="#AsyncGetServByName">WSAAsyncGetServByName()</a><b>.</b><p>

</p><hr><h3>
<a name="CancelBlockingCall">WSACancelBlockingCall()</a></h3>
<h4>Description</h4>
Cancel a blocking call which is currently in progress.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSACancelBlockingCall ( void );</b>

</p><h4>Remarks</h4>
This function cancels any outstanding blocking operation for
this task.  It is normally used in two situations:

<ol>
<li> An application is processing a message which has been received while a
blocking call is in progress.  In this case,
<a href="#IsBlocking">WSAIsBlocking()</a> will be true.<p>

</p></li><li> A blocking call is in progress, and Windows Sockets has called back to the
application's "blocking hook" function (as established by 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>).
</li></ol>

<p>
In each case, the original blocking call will terminate as soon as possible
with the error <a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>.  (In (1), the termination will not take place until
Windows message scheduling has caused control to revert to the blocking routine
in Windows Sockets.  In (2), the blocking call will be terminated as soon as
the blocking hook function completes.)</p><p>

In the case of a blocking 
<a href="#Connect">connect()</a>
operation, the Windows Sockets implementation will terminate the blocking call
as soon as possible, but it may not be possible for the socket resources to be
released until the connection has completed (and then been reset) or timed out.
This is likely to be noticeable only if the application immediately tries to
open a new socket (if no sockets are available), or to 
<a href="#Connect">connect()</a>
to the same peer.</p><p>

Cancelling an 
<a href="#Accept">accept()</a>
or a 
<a href="#Select">select()</a>
call does not adversely impact the sockets passed to these calls.  Only the
particular call fails; any operation that was legal before the cancel is legal
after the cancel, and the state of the socket is not affected in any way.</p><p>

Cancelling any operation other than 
<a href="#Accept">accept()</a>
and 
<a href="#Select">select()</a>
can leave the socket in an indeterminate state.  If an application cancels
a blocking operation on a socket, the only operation that the application can
depend on being able to perform on the socket is a call to 
<a href="#CloseSocket">closesocket()</a>,
although other operations may work on some Windows Sockets implementations.  If
an application desires maximum portability, it must be careful not to depend on
performing operations after a cancel.  An application may reset the connection
by setting the timeout on SO_LINGER to 0.</p><p>

If a cancel operation comprimised the integrity of a SOCK_STREAM's data stream
in any way, the Windows Sockets implementation must reset the connection and
fail all future operations other than 
<a href="#CloseSocket">closesocket()</a>
with <a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>.

</p><h4>Return Value</h4>
The value returned by <b>WSACancelBlockingCall()</b> is 0
if the operation was successfully canceled.  Otherwise the value SOCKET_ERROR
is returned, and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<b>Comments	</b>Note that it is possible that the network operation completes
before the <b>WSACancelBlockingCall()  </b>is processed, for example if data is
received into the user buffer at interrupt time while the application is in a
blocking hook.  In this case, the blocking operation will return successfully
as if <b>WSACancelBlockingCall() </b>had never been called.  Note that the
<b>WSACancelBlockingCall() </b>still succeeds in this case; the only way to
know with certainty that an operation was actually cancelled is to check for a
return code of <a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a> from the blocking call.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>Indicates that there is no outstanding blocking call.
</dd></dl>

<hr><h3><a name="Cleanup">WSACleanup()</a></h3>

<h4>Description</h4>
Terminate use of the Windows Sockets DLL.<p>

<code>	 #include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSACleanup ( void );</b>
</p><h4>Remarks</h4>
An application is required to perform a (successful) 
<a href="#Startup">WSAStartup()</a>
call before it can use Windows Sockets services.  When it has completed the use
of Windows Sockets, the application must call <b>WSACleanup()</b> to deregister
itself from a Windows Sockets implementation and allow the implementation to
free any resources allocated on behalf of the application or DLL.  Any open
SOCK_STREAM sockets that are connected when <b>WSACleanup() </b>is called are
reset; sockets which have been closed with 
<a href="#CloseSocket">closesocket()</a>
but which still have pending data to be sent are not affected--the pending
data is still sent.

<p>There must be a call to <b>WSACleanup() </b>for every call to 
<a href="#Startup">WSAStartup()</a>
made by a task.  Only the final <b>WSACleanup() </b>does the actual
cleanup; the preceding calls simply decrement an internal reference count in
the Windows Sockets DLL.  A naive application may ensure that <b>WSACleanup()
</b>was called enough times by calling <b>WSACleanup() </b>in a loop until it
returns <a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>.

</p><h4>Return Value</h4>
The return value is 0 if the operation was successful.
Otherwise the value SOCKET_ERROR is returned, and a specific error number may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.<p>

<b>Comments	</b>Attempting to call <b>WSACleanup()</b> from within a blocking
hook and then failing to check the return code is a common Windows Sockets
programming error.  If an application needs to quit while a blocking call is
outstanding, the application must first cancel the blocking call with 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
then issue the <b>WSACleanup() </b>call once control has been returned to the
application.</p><p>

</p><h4>Notes For
Windows Sockets
Suppliers</h4>

Well-behaved Windows Sockets applications will make a
<b>WSACleanup()</b> call to indicate deregistration from a Windows Sockets
implementation.  This function can thus, for example, be utilized to free up
resources allocated to the specific application.<p>

A Windows Sockets implementation must be prepared to deal with an application
which terminates without invoking <b>WSACleanup()</b> -- for example, as a
result of an error.</p><p>

In a multithreaded environment, <b>WSACleanup()</b> terminates Windows Sockets
operations for all threads. </p><p>

A Windows Sockets implementation must ensure that <b>WSACleanup()</b> leaves
things in a state in which the application can invoke <b>WSAStartup()</b> to
re-establish Windows Sockets usage.

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.</dd></dl>
<h4>See Also</h4>
<a href="#Startup">WSAStartup()</a><p>

</p><hr><h3>
<a name="GetLastError">WSAGetLastError()</a></h3>
<h4>Description</h4>
Get the error status for the last operation which
failed.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSAGetLastError ( void );</b>

</p><h4>Remarks</h4>
This function returns the last network error that occurred.
When a particular Windows Sockets API function indicates that an error has
occurred, this function should be called to retrieve the appropriate error code.

<h4>Return Value</h4>
The return value indicates the error code for the last
Windows Sockets API routine performed by this thread.

<h4>Notes For
Windows Sockets
Suppliers</h4>

The use of the <b>WSAGetLastError()</b> function to retrieve
the last error code, rather than relying on a global error variable (cf.
<i>errno</i>), is required in order to provide compatibility with future
multi-threaded environments.  
<p>
Note that in a Win16 environment <b>WSAGetLastError()</b> is used to retrieve
only Windows Sockets API errors.  In a Win32 environment,
<b>WSAGetLastError()</b> will invoke <b>GetLastError()</b>, which is used to
retrieve the error status for all Win32 API functions on a per-thread basis.
For portability, an application should use <b>WSAGetLastError()</b>
<b>immediately</b> after the Windows Sockets API function which failed.

</p><h4>See Also</h4>
<a href="#SetLastError">WSASetLastError()</a><p>

</p><hr><h3>
<a name="IsBlocking">WSAIsBlocking()</a></h3>
<h4>Description</h4>
Determine if a blocking call is in progress.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>BOOL PASCAL FAR WSAIsBlocking ( void );</b>

</p><h4>Remarks</h4>
This function allows a task to determine if it is executing
while waiting for a previous blocking call to complete.

<h4>Return Value</h4>
The return value is TRUE if there is an outstanding
blocking function awaiting completion.  Otherwise, it is FALSE.

<h4>Comments</h4>
Although a call issued on a blocking socket appears to an
application program as though it "blocks", the Windows Sockets DLL has to
relinquish the processor to allow other applications to run.  This means that
it is possible for the application which issued the blocking call to be
re-entered, depending on the message(s) it receives.  In this instance, the
<b>WSAIsBlocking()</b> function can be used to ascertain whether the task has
been re-entered while waiting for an outstanding blocking call to complete.
Note that Windows Sockets prohibits more than one outstanding call per thread.

<h4>Notes For
Windows Sockets
Suppliers</h4>

A Windows Sockets implementation must prohibit more than one
outstanding blocking call per thread.<p>

</p><hr><h3>
<a name="SetBlockingHook">WSASetBlockingHook()</a></h3>
<h4>Description</h4>
Establish an application-specific blocking hook function.<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>FARPROC PASCAL FAR WSASetBlockingHook ( FARPROC</b> <i>lpBlockFunc
</i><b>);</b>

</p><dl>
<dt><i>lpBlockFunc</i>
</dt><dd>A pointer to the procedure instance address of the blocking function to be
installed.</dd></dl>
<h4>Remarks</h4>
This function installs a new function which a Windows Sockets
implementation should use to implement blocking socket function calls.

A Windows Sockets implementation includes a default mechanism by which blocking
socket functions are implemented.  The function <b>WSASetBlockingHook()</b>
gives the application the ability to execute its own function at "blocking"
time in place of the default function.<p>

When an application invokes a blocking Windows Sockets API operation, the
Windows Sockets implementation initiates the operation and then enters a loop
which is equivalent to the following pseudocode:</p><p>


</p><pre>for(;;) {
     /* flush messages for good user response */
     while(BlockingHook())
          ;
     /* check for WSACancelBlockingCall() */
     if(operation_cancelled())
          break;
     /* check to see if operation completed */
     if(operation_complete())
          break;     /* normal completion */
}
</pre>
<p>
Note that Windows Sockets implementations may perform the above steps in a
different order; for example, the check for operation complete may occur before
calling the blocking hook.  The default <b>BlockingHook()</b> function is
equivalent to:</p><p>


</p><pre>BOOL DefaultBlockingHook(void) {
     MSG msg;
     BOOL ret;
     /* get the next message if any */
     ret = (BOOL)PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE);
     /* if we got one, process it */
     if (ret) {
          TranslateMessage(&amp;msg);
          DispatchMessage(&amp;msg);
     }
     /* TRUE if we got a message */
     return ret;
}
</pre>
<p>
The <b>WSASetBlockingHook()</b> function is provided to support those
applications which require more complex message processing -- for example, those
employing the MDI (multiple document interface) model.  It is <u>not</u>
intended as a mechanism for performing general applications functions.  In
particular, the only Windows Sockets API function which may be issued from a
custom blocking hook function is 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>,
which will cause the blocking loop to terminate.</p><p>

This function must be implemented on a per-task basis for non-multithreaded
versions of Windows and on a per-thread basis for multithreaded versions of
Windows such as Windows NT.  It thus provides for a particular task or thread
to replace the blocking mechanism without affecting other tasks or threads.</p><p>

In multithreaded versions of Windows, there is no default blocking
hook--blocking calls block the thread that makes the call.  However, an
application may install a specific blocking hook by calling
<b>WSASetBlockingHook().  </b></p><p>
This allows easy portability of applications that depend on the blocking
hook behavior.</p><p>


</p><h4>Return Value</h4>
The return value is a pointer to the procedure-instance of
the previously installed blocking function.  The application or library that
calls the <b>WSASetBlockingHook()</b> function should save this return value so
that it can be restored if necessary.  (If "nesting" is not important, the
application may simply discard the value returned by
<b>WSASetBlockingHook()</b> and eventually use 
<a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>
to restore the default mechanism.)  If the operation fails, a NULL pointer is
returned, and a specific error number may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Notes For
Windows Sockets
Suppliers</h4>

This function must be implemented on a per-thread basis.  It
thus provides for a particular thread to replace the blocking mechanism without
affecting other threads.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
</dt><dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
</dt><dd>A blocking Windows Sockets operation is in progress.</dd></dl>
<h4>See Also</h4>
<a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a><p>

</p><hr><h3>
<a name="SetLastError">WSASetLastError()</a></h3>
<h4>Description</h4>
Set the error code which can be retrieved by
<b>WSAGetLastError()</b>.<p>

<code>	#include &lt;winsock.h&gt;</code></p><p>

<b>void PASCAL FAR WSASetLastError ( int </b><i>iError
</i><b>);</b>

</p><h4>Remarks</h4>
This function allows an application to set the error code to be
returned by a subsequent 
<a href="#GetLastError">WSAGetLastError()</a>
call for the current thread.  Note that any subsequent Windows Sockets routine
called by the application will override the error code as set by this
routine.<p>

</p><dl>
<dt><i>iError</i>
</dt><dd>Specifies the error code to be returned by a subsequent 
<a href="#GetLastError">WSAGetLastError()</a>
call.</dd></dl>

<h4>Notes For
Windows Sockets
Suppliers</h4>

In a Win32 environment, this function will invoke
<b>SetLastError()</b>.<p>

</p><h4>Return Value</h4>
None.<p>

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.</dd></dl>
<h4>See Also</h4>
<a href="#GetLastError">WSAGetLastError()</a><p>

</p><hr><h3>
<a name="Startup">WSAStartup()</a></h3>
<h4>Description</h4>
<p>

<code> 	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSAStartup ( WORD </b><i>wVersionRequired</i><b>, LPWSADATA
</b><i>lpWSAData</i><b> );</b>
</p><dl>
<dt><i>wVersionRequired</i>
</dt><dd>The highest version of Windows Sockets API support that the caller can use.
The high order byte specifies the minor version (revision) number; the
low-order byte specifies the major version number.
</dd><dt><i>lpWSAData</i>
</dt><dd>A pointer to the <b>WSADATA</b> data structure that is to receive details
of the Windows Sockets implementation.</dd></dl>
<h4>Remarks</h4>
This function <b>must</b> be the first Windows Sockets function
called by an application or DLL.  It allows an application to specify the
version of Windows Sockets API required and to retrieve details of the specific
Windows Sockets implementation.  The application may only issue further Windows
Sockets API functions after a successful <b>WSAStartup()</b> invocation.<p>

In order to support future Windows Sockets implementations and applications
which may have functionality differences from Windows Sockets 1.1, a
negotiation takes place in <b>WSAStartup()</b>.  The caller of
<b>WSAStartup()</b> and the Windows Sockets DLL indicate to each other the
highest version that they can support, and each confirms that the other's
highest version is acceptable.  Upon entry to <b>WSAStartup()</b>, the Windows
Sockets DLL examines the version requested by the application.  If this version
is higher than the lowest version supported by the DLL, the call succeeds and
the DLL returns in <i>wHighVersion </i>the highest version it supports and in
<i>wVersion</i> the minimum of its high version and <i>wVersionRequested.
</i>The Windows Sockets DLL then assumes that the application will use
<i>wVersion.</i>  If the <i>wVersion</i> field of the <b>WSADATA</b> structure
is unacceptable to the caller, it should call 
<a href="#Cleanup">WSACleanup()</a>
and either search for another Windows Sockets DLL or fail to initialize.</p><p>

This negotiation allows both a Windows Sockets DLL and a Windows Sockets
application to support a range of Windows Sockets versions.  An application can
successfully utilize a Windows Sockets DLL if there is any overlap in the
version ranges.  The following chart gives examples of how <b>WSAStartup()</b>
works in conjunction with different application and Windows Sockets DLL
versions: </p><p>

</p><pre> 
<b><u>App versions DLL Versions </u><i>wVersionRequested wVersion wHighVersion </i><u>End Result</u></b>
------------ ------------ ----------------- -------- ------------ ----------
1.1	     1.1	  1.1		    1.1	     1.1	  use 1.1<p>
1.0 1.1	     1.0	  1.1		    1.0	     1.0	  use 1.0 
1.0	     1.0 1.1	  1.0		    1.0	     1.1	  use 1.0
1.1	     1.0 1.1	  1.1		    1.1	     1.1	  use 1.1</p><p>
1.1	     1.0	  1.1		    1.0	     1.0	  App fails</p><p>
1.0	     1.1	  1.0		    ---	     ---	  NotSupp</p><p>
1.0 1.1	     1.0 1.1	  1.1		    1.1	     1.1	  use 1.1</p><p>
1.1 2.0	     1.1	  2.0		    1.1	     1.1	  use 1.1
2.0	     1.1	  2.0		    1.1	     1.1	  App fails
</p></pre>
<p>
The following code fragment demonstrates how an application which supports only
version 1.1 of Windows Sockets makes a <b>WSAStartup()</b> call:</p><p>


</p><pre>WORD wVersionRequested;
WSADATA wsaData;
int err;

wVersionRequested = MAKEWORD( 1, 1 );

err = WSAStartup( wVersionRequested, &amp;wsaData );
if ( err != 0 ) {
    /* Tell the user that we couldn't find a useable */
    /* winsock.dll.                                  */
    return;
}

/* Confirm that the Windows Sockets DLL supports 1.1.*/
/* Note that if the DLL supports versions greater    */
/* than 1.1 in addition to 1.1, it will still return */
/* 1.1 in wVersion since that is the version we      */
/* requested.                                        */

if ( LOBYTE( wsaData.wVersion ) != 1 ||
         HIBYTE( wsaData.wVersion ) != 1 ) {
    /* Tell the user that we couldn't find a useable */
    /* winsock.dll.                                  */
    WSACleanup( );
    return;   
}

/* The Windows Sockets DLL is acceptable.  Proceed.  */
</pre>

<p>
And this code fragment demonstrates how a Windows Sockets DLL which
supports only version 1.1 performs the WSAStartup() negotiation:
</p><pre>/* Make sure that the version requested is &gt;= 1.1.   */
/* The low byte is the major version and the high    */
/* byte is the minor version.                        */

if ( LOBYTE( wVersionRequested ) &lt; 1 ||
     ( LOBYTE( wVersionRequested ) == 1 &amp;&amp;
       HIBYTE( wVersionRequested ) &lt; 1 ) {
    return <a href="http://www.sockets.com/err_lst1.htm#WSAVERNOTSUPPORTED">WSAVERNOTSUPPORTED</a>;
}

/* Since we only support 1.1, set both wVersion and  */
/* wHighVersion to 1.1.                              */

lpWsaData-&gt;wVersion = MAKEWORD( 1, 1 );
lpWsaData-&gt;wHighVersion = MAKEWORD( 1, 1 );
</pre>
<p>
Once an application has made a successful <b>WSAStartup()</b> call, it may
proceed to make other Windows Sockets API calls as needed.  When it has
finished using the services of the Windows Sockets DLL, the application must
call 
<a href="#Cleanup">WSACleanup()</a>
in order to allow the DLL to free any resources allocated by the Windows
Sockets DLL for the application.

Details of the actual Windows Sockets implementation are described in the
WSAData structure defined as follows:</p><p>


</p><pre>struct WSAData {
	WORD		wVersion;
	WORD		wHighVersion;
	char		szDescription[WSADESCRIPTION_LEN+1];
	char		szSystemStatus[WSASYSSTATUS_LEN+1];
	unsigned short	iMaxSockets;
	unsigned short	iMaxUdpDg;
	char FAR *	lpVendorInfo
};
</pre>

The members of this structure are:

<dl>

<dt> <i>wVersion</i>
</dt><dd> The version of the Windows Sockets specification that the Windows Sockets
DLL expects the caller to use.

</dd><dt> <i>wHighVersion</i>
</dt><dd> The highest version of the Windows Sockets specification that this DLL can
support (also encoded as above).  Normally this will be the same as wVersion.

</dd><dt> <i>szDescription</i>
</dt><dd> A null-terminated ASCII string into which the Windows Sockets DLL copies a
description of the Windows Sockets implementation, including vendor
identification.  The text (up to 256 characters in length) may contain any
characters, but vendors are cautioned against including control and formatting
characters: the most likely use that an application will put this to is to
display it (possibly truncated) in a status message.

</dd><dt> <i>szSystemStatus</i>
</dt><dd> A null-terminated ASCII string into which the Windows Sockets DLL copies
relevant status or configuration information.  The Windows Sockets DLL should
use this field only if the information might be useful to the user or support
staff: it should not be considered as an extension of the szDescription field.

</dd><dt> <i>iMaxSockets</i>
</dt><dd> The maximum number of sockets which a single process can potentially open.
A Windows Sockets implementation may provide a global pool of sockets for
allocation to any process; alternatively it may allocate per-process resources
for sockets.  The number may well reflect the way in which the Windows Sockets
DLL or the networking software was configured.  Application writers may use
this number as a crude indication of whether the Windows Sockets implementation
is usable by the application.  For example, an X Windows server might check
iMaxSockets when first started: if it is less than 8, the application would
display an error message instructing the user to reconfigure the networking
software.  (This is a situation in which the szSystemStatus text might be
used.)  Obviously there is no guarantee that a particular application can
actually allocate iMaxSockets sockets, since there may be other Windows Sockets
applications in use.

</dd><dt> <i>iMaxUdpDg</i>
</dt><dd> The size in bytes of the largest UDP datagram that can be sent or received
by a Windows Sockets application.  If the implementation imposes no limit,
iMaxUdpDg is zero.  In many implementations of Berkeley sockets, there is an
implicit limit of 8192 bytes on UDP datagrams (which are fragmented if
necessary).  A Windows Sockets implementation may impose a limit based, for
instance, on the allocation of fragment reassembly buffers.  The minimum value
of iMaxUdpDg for a compliant Windows Sockets implementation is 512.  Note that
regardless of the value of iMaxUdpDg, it is inadvisable to attempt to send a
<u>broadcast</u> datagram which is larger than the Maximum Transmission Unit
(MTU) for the network.  (The Windows Sockets API does not provide a mechanism
to discover the MTU, but it must be no less than 512 bytes.)

</dd><dt> <i>lpVendorInfo</i>
</dt><dd> A far pointer to a vendor-specific data structure.  The definition of this
structure (if supplied) is beyond the scope of this specification.
</dd></dl>

An application may call <b>WSAStartup()</b> more than once if it needs to
obtain the WSAData structure information more than once.  However, the
<i>wVersionRequired </i>parameter is assumed to be the same on all calls to
<b>WSAStartup()</b>; that is, an application cannot change the version of
Windows Sockets it expects after the initial call to <b>WSAStartup().</b><p>

There must be one 
<a href="#Cleanup">WSACleanup()</a>
call corresponding to every <b>WSAStartup() </b>call to allow third-party
DLLs to make use of a Windows Sockets DLL on behalf of an application.  This
means, for example, that if an application calls <b>WSAStartup() </b>three
times, it must call 
<a href="#Cleanup">WSACleanup()</a>
three times.  The first two calls to 
<a href="#Cleanup">WSACleanup()</a>
do nothing except decrement an internal counter; the final 
<a href="#Cleanup">WSACleanup()</a>
call does all necessary resource deallocation for the task.</p><p>


</p><h4>Return Value</h4>
<b>WSAStartup()</b> returns zero if successful.  Otherwise
it returns one of the error codes listed below.  Note that the normal mechanism
whereby the application calls 
<a href="#GetLastError">WSAGetLastError()</a>
to determine the error code cannot be used, since the Windows Sockets DLL may
not have established the client data area where the "last error" information is
stored.

<h4>Notes For
Windows Sockets
Suppliers</h4>

Each Windows Sockets application <b>must</b> make a
<b>WSAStartup()</b> call before issuing any other Windows Sockets API calls.
This function can thus be utilized for initialization purposes.
<p>
Further issues are discussed in the notes for 
<a href="#Cleanup">WSACleanup()</a>.

</p><h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSASYSNOTREADY">WSASYSNOTREADY</a>
</dt><dd>Indicates that the underlying network subsystem is not ready
for network communication.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAVERNOTSUPPORTED">WSAVERNOTSUPPORTED</a>
</dt><dd>The version of Windows Sockets API support requested is not provided by
this particular Windows Sockets implementation.
</dd><dt><a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>
</dt><dd>The Windows Sockets version specified by the application is not supported
by this DLL.</dd></dl>
<h4>See Also</h4>
<a href="#Send">send()</a><b>,
</b>
<a href="#SendTo">sendto()</a><b>,
</b>
<a href="#Cleanup">WSACleanup()</a><p>

</p><hr><h3>
<a name="UnhookBlockingHook">WSAUnhookBlockingHook()</a></h3>
<h4>Description</h4>
Restore the default blocking hook function.<p>

<code>	#include &lt;winsock.h&gt;</code></p><p>

<b>int PASCAL FAR WSAUnhookBlockingHook ( void );</b>
</p><h4>Remarks</h4>
This function removes any previous blocking hook that has been
installed and reinstalls the default blocking mechanism.  
<p>
<b>WSAUnhookBlockingHook()</b> will always install the <b>default</b>
mechanism, not the <b>previous</b> mechanism.  If an application wish to nest
blocking hooks -- i.e. to establish a temporary blocking hook function and then
revert to the previous mechanism (whether the default or one established by an
earlier 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>)
- it must save and restore the value returned by 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>;
it cannot use <b>WSAUnhookBlockingHook()</b>.</p><p>

In multithreaded versions of Windows such as Windows NT, there is no default
blocking hook.  Calling <b>WSAUnhookBlockingHook() </b>disables any blocking
hook installed by the application and any blocking calls made block the thread
which made the call.

</p><h4>Return Value</h4>
The return value is 0 if the operation was successful.
Otherwise the value SOCKET_ERROR is returned, and a specific error number may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>
</dt><dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.</dd></dl>
<h4>See Also</h4>
<a href="#SetBlockingHook">WSASetBlockingHook()</a><p>

</p><hr><h1><a name="Appendices">Appendices</a></h1>

<hr><h2><a name="ErrorsAndHeaders">Error Codes and Header Files</a></h2>

<hr><h3><a name="ErrorCodes">Error Codes</a></h3>

The following is a list of possible error codes returned by the 
<a href="#GetLastError">WSAGetLastError()</a>
call, along with their explanations.  The error numbers are consistently set
across all Windows Sockets-compliant implementations.

<pre>Windows Sockets code	Berkeley equivalent	Error	Interpretation
-----------------------	-----------------------	-------	----------------
<a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>		EINTR			10004	As in standard C
WSAEBADF		EBADF			10009	As in standard C
WSEACCES		EACCES			10013	As in standard C
<a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>		EFAULT			10014	As in standard C
<a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>		EINVAL			10022	As in standard C
<a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>		EMFILE			10024	As in standard C
<a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>		EWOULDBLOCK		10035	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>		EINPROGRESS		10036	This error is returned
							if any Windows Sockets
							API function is called
							while a blocking
							function is in
							progress.

<a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>		EALREADY		10037	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>		ENOTSOCK		10038	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDRREQ">WSAEDESTADDRREQ</a>		EDESTADDRREQ		10039	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>		EMSGSIZE		10040	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEPROTOTYPE">WSAEPROTOTYPE</a>		EPROTOTYPE		10041	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>		ENOPROTOOPT		10042	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEPROTONOSUPPORT">WSAEPROTONOSUPPORT</a>	EPROTONOSUPPORT		10043	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAESOCKTNOSUPPORT">WSAESOCKTNOSUPPORT</a>	ESOCKTNOSUPPORT		10044	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>		EOPNOTSUPP		10045	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEPFNOSUPPORT">WSAEPFNOSUPPORT</a>		EPFNOSUPPORT		10046	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>		EAFNOSUPPORT		10047	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>		EADDRINUSE		10048	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>	EADDRNOTAVAIL		10049	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>		ENETDOWN		10050	As in BSD.  This error
							may be reported at any
							time if the Windows
							Sockets implementation
							detects an underlying
							failure.
<a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>		ENETUNREACH		10051	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>		ENETRESET		10052	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>		ECONNABORTED		10053	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>		ECONNRESET		10054	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>		ENOBUFS			10055	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>		EISCONN			10056	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>		ENOTCONN		10057	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>		ESHUTDOWN		10058	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAETOOMANYREFS">WSAETOOMANYREFS</a>		ETOOMANYREFS		10059	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>		ETIMEDOUT		10060	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>		ECONNREFUSED		10061	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAELOOP">WSAELOOP</a>		ELOOP			10062	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAENAMETOOLONG">WSAENAMETOOLONG</a>		ENAMETOOLONG		10063	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTDOWN">WSAEHOSTDOWN</a>		EHOSTDOWN		10064	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTUNREACH">WSAEHOSTUNREACH</a>		EHOSTUNREACH		10065	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSASYSNOTREADY">WSASYSNOTREADY</a>					10091	Returned by <a href="#Startup">WSAStartup()</a>
							indicating that the
							network subsystem is
							unusable.
<a href="http://www.sockets.com/err_lst1.htm#WSAVERNOTSUPPORTED">WSAVERNOTSUPPORTED</a>				10092	Returned by <a href="#Startup">WSAStartup()</a>
							indicating that the
							Windows Sockets DLL
							cannot support this
							app.
<a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>				10093	Returned by any
							function except
							<a href="#Startup">WSAStartup()</a>
							indicating that a
							successful <a href="#Startup">WSAStartup()</a>
							has not yet been
							performed.
<a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>	HOST_NOT_FOUND		11001	As in BSD.
<a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>		TRY_AGAIN		11002	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>		NO_RECOVERY		11003	As in BSD
<a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>		NO_DATA			11004	As in BSD
</pre>

<p>
The first set of definitions is present to resolve contentions between standard
C error codes which may be defined inconsistently between various C
compilers.</p><p>

The second set of definitions provides Windows Sockets versions of regular
Berkeley Sockets error codes.</p><p>

The third set of definitions consists of extended Windows Sockets-specific
error codes.</p><p>

The fourth set of errors are returned by Windows Sockets 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
and <b>WSAAsyncGetXByY()</b> functions, and correspond to the errors which in
Berkeley software would be returned in the <i>h_errno</i> variable.  They
correspond to various failures which may be returned by the Domain Name
Service.  If the Windows Sockets implementation  does not use the DNS, it will
use the most appropriate code.  In general, a Windows Sockets application
should interpret <a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a> and <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a> as indicating that the key
(name, address, etc.) was not found,, while <a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a> and <a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>
suggest that the name service itself is non-operational.</p><p>

The error numbers are derived from the 
<a href="#H">winsock.h</a>
header file, and are based on the fact that Windows Sockets error numbers are
computed by adding 10000 to the "normal" Berkeley error number.</p><p>

Note that this table does not include all of the error codes defined in
<b>winsock.h</b>.  This is because it includes only errors which might
reasonably be returned by a Windows Sockets implementation: <b>winsock.h</b>,
on the other hand, includes a full set of BSD definitions to ensure
compatibility with ported software.

</p><hr><h3><a name="HeaderFiles">Header Files</a></h3>

<a href="#BerkeleyHeaders">Berkeley Header Files</a><p>
<a href="#WinsockH">Windows Sockets Header File -- winsock.h</a></p><p>

</p><h4><a name="RTFToC99">Berkeley Header Files</a></h4>

A Windows Sockets supplier who provides a development kit to support the
development of Windows Sockets applications must supply a set of vestigial
header files with names that match a number of the header files in the Berkeley
software distribution.  These files are provided for source code compatibility
only, and each consists of three lines:<p>


</p><pre>#ifndef _WINSOCKAPI_
#include &lt;winsock.h&gt;
#endif
</pre>
<p>
The header files provided for compatibility are:</p><p>
</p><ul>
<li><b>netdb.h</b>
</li><li><b>arpa/inet.h</b>
</li><li><b>sys/time.h</b>
</li><li><b>sys/socket.h</b>
</li><li><b>netinet/in.h</b>
</li></ul>
<p>
The file 
<a href="#WinsockH">winsock.h</a>
contains all of the type and structure definitions, constants, macros, and
function prototypes used by the Windows Sockets specification.  An application
writer may choose to ignore the compatibility headers and include
<b>winsock.h</b> in each source file.</p><p>

</p><p>

</p><h4><a name="WinsockH">Windows Sockets Header File -- winsock.h</a></h4>

<p>
The <b>winsock.h</b> header file includes a number of types and definitions
from the standard Windows header file <b>windows.h</b>.  The <b>windows.h</b>
in the Windows 3.0 SDK (Software Developer's Kit) lacks a #include guard, so if
you need to include <b>windows.h</b> as well as <b>winsock.h</b>, you should
define the symbol _INC_WINDOWS before #including <b>winsock.h</b>, as follows:

</p><pre>#include &lt;windows.h&gt;
#define _INC_WINDOWS
#include &lt;winsock.h&gt;
</pre>

Users
of the SDK for Windows 3.1 and later need not do this.<p>

A Windows Sockets DLL vendor <b>MUST NOT</b> make any modifications to this
header file which could impact binary compatibility of Windows Sockets
applications.  The constant values, function parameters and return codes, and
the like must remain consistent across all Windows Sockets DLL vendors.</p><p>

</p><pre>/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include &lt;windows.h&gt;
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be &gt;= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_short fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i &lt; ((fd_set FAR *)(set))-&gt;fd_count ; __i++) { \
        if (((fd_set FAR *)(set))-&gt;fd_array[__i] == fd) { \
            while (__i &lt; ((fd_set FAR *)(set))-&gt;fd_count-1) { \
                ((fd_set FAR *)(set))-&gt;fd_array[__i] = \
                    ((fd_set FAR *)(set))-&gt;fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))-&gt;fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))-&gt;fd_count &lt; FD_SETSIZE) \
        ((fd_set FAR *)(set))-&gt;fd_array[((fd_set FAR *)(set))-&gt;fd_count++]=fd;\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))-&gt;fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)fd, (fd_set FAR *)set)

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for &gt;= or &lt;=.
 */
#define timerisset(tvp)         ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec || \
         (tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec)
#define timerclear(tvp)         (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be &lt; 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &amp;
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|(x&lt;&lt;8)|y)

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&amp;IOCPARM_MASK)&lt;&lt;16)|(x&lt;&lt;8)|y)

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&amp;IOCPARM_MASK)&lt;&lt;16)|(x&lt;&lt;8)|y)

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports &lt; IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp &amp; ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) &amp; 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) &amp; 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) &amp; 0xc0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff    
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS      1               /* set/get IP per-packet options */

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */

#define AF_MAX          18

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEINTR">WSAEINTR</a>                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEFAULT">WSAEFAULT</a>               (WSABASEERR+14)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEINVAL">WSAEINVAL</a>               (WSABASEERR+22)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEMFILE">WSAEMFILE</a>               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>          (WSABASEERR+35)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>          (WSABASEERR+36)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>             (WSABASEERR+37)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>             (WSABASEERR+38)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDRREQ">WSAEDESTADDRREQ</a>         (WSABASEERR+39)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>             (WSABASEERR+40)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEPROTOTYPE">WSAEPROTOTYPE</a>           (WSABASEERR+41)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>          (WSABASEERR+42)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEPROTONOSUPPORT">WSAEPROTONOSUPPORT</a>      (WSABASEERR+43)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAESOCKTNOSUPPORT">WSAESOCKTNOSUPPORT</a>      (WSABASEERR+44)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>           (WSABASEERR+45)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEPFNOSUPPORT">WSAEPFNOSUPPORT</a>         (WSABASEERR+46)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>         (WSABASEERR+47)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>           (WSABASEERR+48)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>        (WSABASEERR+49)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>             (WSABASEERR+50)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>          (WSABASEERR+51)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>            (WSABASEERR+52)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>         (WSABASEERR+53)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>           (WSABASEERR+54)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>              (WSABASEERR+55)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>              (WSABASEERR+56)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>             (WSABASEERR+57)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>            (WSABASEERR+58)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAETOOMANYREFS">WSAETOOMANYREFS</a>         (WSABASEERR+59)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>            (WSABASEERR+60)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>         (WSABASEERR+61)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAELOOP">WSAELOOP</a>                (WSABASEERR+62)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENAMETOOLONG">WSAENAMETOOLONG</a>         (WSABASEERR+63)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTDOWN">WSAEHOSTDOWN</a>            (WSABASEERR+64)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTUNREACH">WSAEHOSTUNREACH</a>         (WSABASEERR+65)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAENOTEMPTY">WSAENOTEMPTY</a>            (WSABASEERR+66)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEPROCLIM%3EWSAEPROCLIM%3C/a%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%28WSABASEERR+67%29#define%20%3CA%20HREF=" err_lst1.htm#wsaeusers="">WSAEUSERS</a>               (WSABASEERR+68)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEDQUOT">WSAEDQUOT</a>               (WSABASEERR+69)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAESTALE">WSAESTALE</a>               (WSABASEERR+70)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAEREMOTE">WSAEREMOTE</a>              (WSABASEERR+71)

/*
 * Extended Windows Sockets error constant definitions
 */
#define <a href="http://www.sockets.com/err_lst1.htm#WSASYSNOTREADY">WSASYSNOTREADY</a>          (WSABASEERR+91)
#define <a href="http://www.sockets.com/err_lst1.htm#WSAVERNOTSUPPORTED">WSAVERNOTSUPPORTED</a>      (WSABASEERR+92)
#define <a href="http://www.sockets.com/err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</a>       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define <a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>       (WSABASEERR+1001)
#define HOST_NOT_FOUND          <a href="http://www.sockets.com/err_lst1.htm#WSAHOST_NOT_FOUND">WSAHOST_NOT_FOUND</a>

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define <a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>            (WSABASEERR+1002)
#define TRY_AGAIN               <a href="http://www.sockets.com/err_lst1.htm#WSATRY_AGAIN">WSATRY_AGAIN</a>

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define <a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>          (WSABASEERR+1003)
#define NO_RECOVERY             <a href="http://www.sockets.com/err_lst1.htm#WSANO_RECOVERY">WSANO_RECOVERY</a>

/* Valid name, no data record of requested type */
#define <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>              (WSABASEERR+1004)
#define NO_DATA                 <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>

/* no address, look for MX record */
#define <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_ADDRESS</a>           <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_DATA</a>
#define NO_ADDRESS              <a href="http://www.sockets.com/err_lst1.htm#WSANO_DATA">WSANO_ADDRESS</a>

/*
 * Windows Sockets errors redefined as regular Berkeley error constants
 */
#define EWOULDBLOCK             <a href="http://www.sockets.com/err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</a>
#define EINPROGRESS             <a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
#define EALREADY                <a href="http://www.sockets.com/err_lst1.htm#WSAEALREADY">WSAEALREADY</a>
#define ENOTSOCK                <a href="http://www.sockets.com/err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
#define EDESTADDRREQ            <a href="http://www.sockets.com/err_lst1.htm#WSAEDESTADDRREQ">WSAEDESTADDRREQ</a>
#define EMSGSIZE                <a href="http://www.sockets.com/err_lst1.htm#WSAEMSGSIZE">WSAEMSGSIZE</a>
#define EPROTOTYPE              <a href="http://www.sockets.com/err_lst1.htm#WSAEPROTOTYPE">WSAEPROTOTYPE</a>
#define ENOPROTOOPT             <a href="http://www.sockets.com/err_lst1.htm#WSAENOPROTOOPT">WSAENOPROTOOPT</a>
#define EPROTONOSUPPORT         <a href="http://www.sockets.com/err_lst1.htm#WSAEPROTONOSUPPORT">WSAEPROTONOSUPPORT</a>
#define ESOCKTNOSUPPORT         <a href="http://www.sockets.com/err_lst1.htm#WSAESOCKTNOSUPPORT">WSAESOCKTNOSUPPORT</a>
#define EOPNOTSUPP              <a href="http://www.sockets.com/err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</a>
#define EPFNOSUPPORT            <a href="http://www.sockets.com/err_lst1.htm#WSAEPFNOSUPPORT">WSAEPFNOSUPPORT</a>
#define EAFNOSUPPORT            <a href="http://www.sockets.com/err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
#define EADDRINUSE              <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>
#define EADDRNOTAVAIL           <a href="http://www.sockets.com/err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>
#define ENETDOWN                <a href="http://www.sockets.com/err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
#define ENETUNREACH             <a href="http://www.sockets.com/err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>
#define ENETRESET               <a href="http://www.sockets.com/err_lst1.htm#WSAENETRESET">WSAENETRESET</a>
#define ECONNABORTED            <a href="http://www.sockets.com/err_lst1.htm#WSAECONNABORTED">WSAECONNABORTED</a>
#define ECONNRESET              <a href="http://www.sockets.com/err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>
#define ENOBUFS                 <a href="http://www.sockets.com/err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
#define EISCONN                 <a href="http://www.sockets.com/err_lst1.htm#WSAEISCONN">WSAEISCONN</a>
#define ENOTCONN                <a href="http://www.sockets.com/err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
#define ESHUTDOWN               <a href="http://www.sockets.com/err_lst1.htm#WSAESHUTDOWN">WSAESHUTDOWN</a>
#define ETOOMANYREFS            <a href="http://www.sockets.com/err_lst1.htm#WSAETOOMANYREFS">WSAETOOMANYREFS</a>
#define ETIMEDOUT               <a href="http://www.sockets.com/err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>
#define ECONNREFUSED            <a href="http://www.sockets.com/err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>
#define ELOOP                   <a href="http://www.sockets.com/err_lst1.htm#WSAELOOP">WSAELOOP</a>
#define ENAMETOOLONG            <a href="http://www.sockets.com/err_lst1.htm#WSAENAMETOOLONG">WSAENAMETOOLONG</a>
#define EHOSTDOWN               <a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTDOWN">WSAEHOSTDOWN</a>
#define EHOSTUNREACH            <a href="http://www.sockets.com/err_lst1.htm#WSAEHOSTUNREACH">WSAEHOSTUNREACH</a>
#define ENOTEMPTY               <a href="http://www.sockets.com/err_lst1.htm#WSAENOTEMPTY">WSAENOTEMPTY</a>
#define EPROCLIM                <a href="http://www.sockets.com/err_lst1.htm#WSAEPROCLIM%3EWSAEPROCLIM%3C/a%3E#define%20EUSERS%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CA%20HREF=" err_lst1.htm#wsaeusers="">WSAEUSERS</a>
#define EDQUOT                  <a href="http://www.sockets.com/err_lst1.htm#WSAEDQUOT">WSAEDQUOT</a>
#define ESTALE                  <a href="http://www.sockets.com/err_lst1.htm#WSAESTALE">WSAESTALE</a>
#define EREMOTE                 <a href="http://www.sockets.com/err_lst1.htm#WSAEREMOTE">WSAEREMOTE</a>

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, 
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        const char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */
</pre>

<hr><h2><a name="NotesForSuppliers">Notes for Windows Sockets Suppliers</a></h2>

<a href="#Notes_Introduction">Introduction</a><p>
<a href="#Notes_WindowsComponents">Windows Sockets Components</a></p><p>
<a href="#Notes_Multithreadedness">Multithreadedness and blocking routines.</a></p><p>
<a href="#Notes_DatabaseFiles">Database Files</a></p><p>
<a href="#Notes_FDISSET">FD_ISSET</a></p><p>
<a href="#Notes_ErrorCodes">Error Codes</a></p><p>
<a href="#Notes_DLLOrdinals">DLL Ordinal Numbers</a></p><p>
<a href="#Notes_Validation">Validation Suite</a></p><p>

</p><hr><h3><a name="Notes_Introduction">Introduction</a></h3>

A Windows Sockets implementation must implement ALL the functionality described
in the Windows Sockets documentation.  Validation of compliance is discussed in 
<a href="#Notes_Validation">Validation
Suite</a>.<p>

Windows Sockets Version 1.1 implementations must support both TCP and UDP type
sockets.  An implementation may support raw sockets (of type SOCK_RAW), but
their use is deprecated.</p><p>

Certain APIs documented above have special notes for Windows Sockets
implementors.  A Windows Sockets implementation should pay special attention to
conforming to the API as documented.  The Special Notes are provided for
assistance and clarification.</p><p>


</p><hr><h3><a name="Notes_WindowsComponents">Windows Sockets Components</a></h3>

<h4><a name="NotesComp_Development">Development Components</a></h4>

The Windows Sockets development components for use by Windows Sockets
application developers will be provided by each Windows Sockets supplier.
These Windows Sockets development components are:<p>

</p><pre><b><u>Component			Description</u></b><p>
-------------------------------	-----------------------------------------------
Windows Sockets Documentation	This document</p><p>

WINSOCK.LIB file		Windows Sockets API Import Library</p><p>

WINSOCK.H file			Windows Sockets Header File</p><p>

NETDB.H file			Berkeley Compatible Header File</p><p>

ARPA/INET.H file		Berkeley Compatible Header File</p><p>

SYS/TIME.H file			Berkeley Compatible Header File</p><p>

SYS/SOCKET.H file		Berkeley Compatible Header File</p><p>

NETINET/IN.H file		Berkeley Compatible Header File</p><p>
</p></pre>

<h4><a name="NotesComp_RunTime">Run Time Components</a></h4>

The run time component provided by each Windows Sockets supplier is:<p>
</p><pre><b><u>Component			Description</u></b><p>
-------------------------------	-----------------------------------------------
WINSOCK.DLL			The Windows Sockets API implementation DLL
</p></pre>
<p>

</p><hr><h3><a name="Notes_Multithreadedness">Multithreadedness and blocking routines.</a></h3>

Data areas returned by, for example, the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
routines MUST be on a per thread basis.<p>

Note that an application MUST be prevented from making multiple nested Windows
Sockets function calls.  Only one outstanding function call will be allowed for
a particular task.  Any Windows Sockets call performed when an existing
blocking call is already outstanding will fail with an error code of
<a href="http://www.sockets.com/err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>.  There are two exceptions to this restriction: 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
and 
<a href="#IsBlocking">WSAIsBlocking()</a>
may be called at any time.  Windows Sockets suppliers should note that although
preliminary drafts of this specification indicated that the restriction only
applied to blocking function calls, and that it would be permissible to make
non-blocking calls while a blocking call was in progress, this is no longer
true.</p><p>

Regarding the implementation of blocking routines, the solution in Windows
Sockets is to simulate the blocking mechanism by having each routine call
PeekMessage() as it waits for the completion of its operation.  In anticipation
of this, the function 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
is provided to allow the programmer to define a special routine to be called
instead of the default PeekMessage() loop.  The blocking hook functions are
discussed in more detail in 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>.</p><p>


</p><hr><h3><a name="Notes_DatabaseFiles">Database Files</a></h3>

The database routines in the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
family (<b>gethostbyaddr()</b>, etc.) were originally designed (in the first
Berkeley UNIX releases) as mechanisms for looking up information in text
databases.  A Windows Sockets supplier may choose to employ local files OR a
name service to provide some or all of this information.  If local files exist,
the format of the files must be identical to that used in BSD UNIX, allowing
for the differences in text file formats.  <p>


</p><hr><h3><a name="Notes_FDISSET">FD_ISSET</a></h3>

It is necessary to implement the FD_ISSET Berkeley macro using a supporting
function: <b>__WSAFDIsSet()</b>.  It is the responsibility of a Windows Sockets
implementation to make this available as part of the Windows Sockets API.
Unlike the other functions exported by a Windows Sockets DLL, however, this
function is not intended to be invoked directly by Windows Sockets
applications: it should be used only to support the FD_ISSET macro.  The source
code for this function is listed below:<p>


</p><pre>int FAR
__WSAFDIsSet(SOCKET fd, fd_set FAR *set)
{
    int i = set-&gt;count;

    while (i--)
	if (set-&gt;fd_array[i] == fd)
	    return 1;

    return 0;
}
</pre>
<p>

</p><hr><h3><a name="Notes_ErrorCodes">Error Codes</a></h3>

In order to avoid conflict between various compiler environments Windows
Sockets implementations MUST return the error codes listed in the API
specification, using the manifest constants beginning with "WSA".  The
Berkeley-compatible error code definitions are provided solely for
compatibility purposes for applications which are being ported from other
platforms.<p>


</p><hr><h3><a name="Notes_DLLOrdinals">DLL Ordinal Numbers</a></h3>

The <b>winsock.def </b>file for use by every Windows Sockets implementation is
as follows.  Ordinal values starting at 1000 are reserved for Windows Sockets
implementors to use for exporting private interfaces to their DLLs.  A Windows
Sockets implementation must not use any ordinals 999 and below except for those
APIs listed below.  An application which wishes to work with any Windows
Sockets DLL must use only those routines listed below; using a private export
makes an application dependent on a particular Windows Sockets
implementation.<p>


</p><pre>;  
;         File: winsock.def 
;       System: MS-Windows 3.x 
;      Summary: Module definition file for Windows Sockets DLL.  
;  

LIBRARY         WINSOCK         ; Application's module name 

DESCRIPTION     'BSD Socket API for Windows' 

EXETYPE         WINDOWS         ; required for all windows applications 

STUB            'WINSTUB.EXE'   ; generates error message if application 
                                ; is run without Windows 

;CODE can be FIXED in memory because of potential upcalls 
CODE            PRELOAD         FIXED 

;DATA must be SINGLE and at a FIXED location since this is a DLL 
DATA            PRELOAD         FIXED           SINGLE

HEAPSIZE        1024 
STACKSIZE       16384 

; All functions that will be called by any Windows routine 
; must be exported.  Any additional exports beyond those defined
; here must have ordinal numbers 1000 or above. 

EXPORTS 
        accept                         @1 
        bind                           @2 
        closesocket                    @3 
        connect                        @4 
        getpeername                    @5 
        getsockname                    @6 
        getsockopt                     @7 
        htonl                          @8 
        htons                          @9 
        inet_addr                      @10 
        inet_ntoa                      @11 
        ioctlsocket                    @12 
        listen                         @13 
        ntohl                          @14 
        ntohs                          @15 
        recv                           @16 
        recvfrom                       @17 
        select                         @18 
        send                           @19 
        sendto                         @20 
        setsockopt                     @21 
        shutdown                       @22 
        socket                         @23 

        gethostbyaddr                  @51 
        gethostbyname                  @52 
        getprotobyname                 @53 
        getprotobynumber               @54 
        getservbyname                  @55 
        getservbyport                  @56 
        gethostname                    @57

        WSAAsyncSelect                 @101 
        WSAAsyncGetHostByAddr          @102 
        WSAAsyncGetHostByName          @103 
        WSAAsyncGetProtoByNumber       @104 
        WSAAsyncGetProtoByName         @105 
        WSAAsyncGetServByPort          @106 
        WSAAsyncGetServByName          @107 
        WSACancelAsyncRequest          @108 
        WSASetBlockingHook             @109 
        WSAUnhookBlockingHook          @110 
        WSAGetLastError                @111 
        WSASetLastError                @112 
        WSACancelBlockingCall          @113 
        WSAIsBlocking                  @114 
        WSAStartup                     @115 
        WSACleanup                     @116 

        __WSAFDIsSet                   @151 

        WEP                            @500    RESIDENTNAME 

;eof 
</pre>

<hr><h3><a name="Notes_Validation">Validation Suite</a></h3>

The Windows Sockets API Tester (WSAT) to ensure Windows Sockets compatibility
between Windows Sockets DLL implementations is currently in beta test.  This
beta version includes functionality testing of the Windows Sockets interface
and is supported by a comprehensive scripting language.  The final version of
WSAT will be available in Spring 1993.  If you wish to receive the tester or
more information on the beta, send email to 
<a href="mailto:wsat@microsoft.com">wsat@microsoft.com</a>. <p>

</p><hr><h2><a name="FurtherReference">For Further Reference</a></h2>

<p>
This specification is intended to cover the Windows Sockets interface to TCP/IP
in detail.  Many details of TCP/IP and Windows, however, are intentionally
omitted in the interest of brevity, and this specification often assumes
background knowledge of these topics.  For more information, the following
references may be helpful:</p><p>

Braden, R.[1989], <i>RFC 1122, Requirements for Internet Hosts--Communication
Layers</i>, Internet Engineering Task Force.</p><p>

Comer, D. [1991], <i>Internetworking with TCP/IP Volume I: Principles,
Protocols, and Architecture, </i>Prentice Hall, Englewood Cliffs, New Jersey.</p><p>

Comer, D. and Stevens, D. [1991], <i>Internetworking with TCP/IP Volume II:
Design, Implementation, and Internals, </i>Prentice Hall, Englewood Cliffs, New
Jersey.</p><p>

Comer, D. and Stevens, D. [1991], <i>Internetworking with TCP/IP Volume III:
Client-Server Programming and Applications, </i>Prentice Hall, Englewood
Cliffs, New Jersey.</p><p>

Leffler, S. et al., <i>An Advanced 4.3BSD Interprocess Communication
Tutorial.</i></p><p>

Petzold, C. [1992], <i>Programming Windows 3.1, </i>Microsoft Press, Redmond,
Washington.</p><p>

Stevens, W.R. [1990], <i>Unix Network Programming, </i>Prentice Hall, Englewood
Cliffs, New Jersey.

</p><hr><h2><a name="Background">Background Information</a></h2>

<hr><h3> <a name="Origins">Origins of Windows Sockets </a></h3>

The Windows Sockets project had its origins in a Birds Of A Feather session
held at Interop '91 in San Jose on October 10, 1991.  A committee was
established, and an intensive debate via email resulted in the creation of a
first draft specification, which was largely based on submissions from JSB and
NetManage.  This draft, and issues arising from it, were debated at a committee
meeting hosted by Microsoft in Redmond, WA on December 9, 1991.  Following
further email discussions, a working group was established to develop the
specification into its current form.<p>

The following people participated in the process as committee members, in
working meetings, or in email review.  The authors would like to thank everyone
who participated in any way, and apologize in advance if we have omitted
anyone.</p><p>


</p><pre>Martin Hall	(Moderator) 	JSB Corporation		<a href="mailto:martinh@jsbus.com">martinh@jsbus.com</a>
<a href="http://sunsite.unc.edu/towfiq">Mark Towfiq</a>	(Coordinator)	Microdyne Corporation	<a href="mailto:towfiq@east.sun.com">towfiq@microdyne.com</a>
Geoff Arnold			Sun Microsystems, Inc.	<a href="mailto:geoff@east.sun.com">geoff@east.sun.com</a>
Alistair Banks			Microsoft		<a href="mailto:alistair@microsoft.com">alistair@microsoft.com</a>
Carl Beame			Beame &amp; Whiteside	<a href="mailto:beame@mcmaster,ca">beame@mcmaster,ca</a>
David Beaver			Microsoft		<a href="mailto:dbeaver@microsoft.com">dbeaver@microsoft.com</a>
Amatzia BenArtzi		NetManage, Inc.		<a href="mailto:amatzia@netmanage.com">amatzia@netmanage.com</a>
Mark Beyer			Ungermann-Bass		<a href="mailto:mbeyer@ub.com">mbeyer@ub.com</a>
James Van Bokkelen		FTP Software		<a href="mailto:jbvb@ftp.com">jbvb@ftp.com</a>
Nelson Bolyard			Silicon Graphics, Inc.	<a href="mailto:nelson@sgi.com">nelson@sgi.com</a>
Pat Bonner			Hewlett-Packard		<a href="mailto:p_bonner@cnd.hp.com">p_bonner@cnd.hp.com</a>
Isaac Chan			Microsoft		<a href="mailto:isaacc@microsoft.com">isaacc@microsoft.com</a>
Nestor Fesas			Hughes LAN Systems	<a href="mailto:nestor@hls.com">nestor@hls.com</a>
Gary Gere			Gupta			<a href="mailto:ggere@gupta.com">ggere@gupta.com</a>
Bill Hayes			Hewlett-Packard		<a href="mailto:billh@hpchdpc.cnd.hp.com">billh@hpchdpc.cnd.hp.com</a>
Hoek Law			Citicorp		<a href="mailto:law@dcc.tti.com">law@dcc.tti.com</a>
Paul Hill			MIT			<a href="mailto:pbh@athena.mit.edu">pbh@athena.mit.edu</a>
Graeme Le Roux			Moresdawn P/L		<a href="mailto:-">-</a>
Terry Lister			Hewlett-Packard		<a href="mailto:tel@cnd.hp.com">tel@cnd.hp.com</a>
Lee Murach			Network Research	<a href="mailto:lee@nrc.com">lee@nrc.com</a>
David Pool			Spry, Inc.		<a href="mailto:dave@spry.com">dave@spry.com</a>
Brad Rice			Age			<a href="mailto:rice@age.com">rice@age.com</a>
Allen Rochkind			3Com			<a href="mailto:-">-</a>
Henry Sanders			Microsoft		<a href="mailto:henrysa@microsoft.com">henrysa@microsoft.com</a>
David Treadwell			Microsoft		<a href="mailto:davidtr@microsoft.com">davidtr@microsoft.com</a>
Miles Wu			Wollongong		<a href="mailto:wu@twg.com">wu@twg.com</a>
Boris Yanovsky			NetManage, Inc.		<a href="mailto:boris@netmanage.com">boris@netmanage.com</a>
J Allard			Microsoft Corporation	<a href="mailto:jallard@microsoft.com">jallard@microsoft.com</a>
</pre>

<hr><h3><a name="LegalStatus">Legal Status of Windows Sockets</a></h3>

The copyright for the Windows Sockets specification is owned by the
specification authors listed on the title page.  Permission is granted to
redistribute this specification in any form, provided that the contents of the
specification are not modified.  Windows Sockets implementors are encouraged to
include this specification with their product documentation.<p>

The Windows Sockets logo on the title page of this document is meant for use on
both Windows Sockets implementations and for applications that use the Windows
Sockets interface.  Use of the logo is encouraged on packaging, documentation,
collateral, and advertising.  The logo is available on <i>SunSite.UNC.Edu</i>
in /pub/micro/pc-stuff/ms-windows/winsock/winsock-1.1 as winsock.bmp.  The
suggested color for the logo's title bar is blue, the electrical socket grey,
and the text and outline black.  </p><p>

</p><hr><h3><a name="IconStory">The Story Behind the Windows Sockets Icon</a></h3>

<h4>(by Alistair Banks, Microsoft Corporation)</h4>

<img src="winsock_files/winsock-big.html" align="bottom">
<p>
We thought we'd do a "Wind Sock" at one stage--but you try to get that into
32x32 bits! It would have had to look wavy and colorful, and... well, it just
didn't work. Also, our graphics designers have "opinions" about the icons truly
representing what they are--people would have thought this was "The colorful
wavy tube specification 1.0!"</p><p>

I tried to explain "API" "Programming Interface" to the artist--we ended up
with toolbox icons with little flying windows.
</p><p>
Then we came to realise that we should be going after the shortened form of the
name, rather the name in full... Windows Sockets... And so we went for that --
so she drew (now remember I'm English and you're probably American) "Windows
Spanner", a.k.a. a socket wrench.  In the U.S. you'd have been talking about
the "Windows Socket spec" OK, but in England that would have been translatated
as "Windows Spanner Spec 1.0" -- so we went to Electrical sockets -- well the
first ones came out looking like "Windows Pignose Spec 1.0"!!!!</p><p>

So how do you use 32x32, get an international electrical socket! You take the
square type (American &amp; English OK, Europe &amp; Australia are too
rounded)--you choose the American one, because it's on the wall in front of you
(and it's more compact (but less safe, IMHO) and then you turn it upside down,
thereby compromising its nationality!</p><p>

[IMHO = "In My Humble Opinion"--ed.]
</p></body></html>