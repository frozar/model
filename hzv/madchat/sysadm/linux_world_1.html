<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux World: Partie #1</title>
<style type="text/css">
<!--
A:link {
	COLOR: #0066ff; TEXT-DECORATION: none;
}
A:visited {
	COLOR: #0066ff; TEXT-DECORATION: none;
}
A:active {
	COLOR: #ff0000; TEXT-DECORATION: none;
}
A:hover {
	COLOR: #ffffff; TEXT-DECORATION: underline;
}
//-->
</style>
</head>
<body vlink="#3366ff" alink="#3366ff" link="#3366ff" bgcolor="#bbddee" text="#000000">
<div align=center><font color="#ff0000" size=+4>Linux World : Partie #1</font></div>
<hr>
<i><font color="#bbddee">. . . . . . . . . .</font>
<font color="#099990" size=-1>23 Aout 2002
<font color="#bbddee">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</font>
<a href="mailto:dave.lombardo1@caramail.com">SlayDave</a></font>
<p>
Le document que vous lisez en ce moment est seulement le prmier d'une s&eacute;rie que je vais &eacute;crire sur ce monde magique
qui est Linux.<br>
Dans cette premi&egrave;re partie, je vais faire une introductions &agrave; Linux, et je vais vous pr&eacute;senter ses principaux commandes. Je
voulais aussi ajouter une partie sur l'installation de ce syst&egrave;me d'exploitation, mais j'ai trouv&eacute; que des documents traitent ce
sujet d'une fa&ccedil;on tr&egrave;s detaill&eacute;e pour chaque distribution et chaque version.<br>
Pour faire ce tutorial, je me suis appuy&eacute; sur les documents suivants:
</i>
<ul>
<li>"Manuel de r&eacute;f&eacute;rence"  fournit avec <a href="http://www.linux-mandrake.com" target="blank">Linux Mandrake</a> 8.0</a></li>
<li>"GUIDE DE SURVIE DU DEBUTANT SOUS LINUX" de G.DELAFOND disponible sur : <a href="http://www.medsyn.fr/perso/g.delafond/survie.htm" target="blank">www.medsyn.fr/perso/g.delafond/survie.htm</a>.</li>
<li>"Guide dinstallation et de configuration de Linux</li> de Christian Casteyde disponible sur <a href="http://casteyde.christian.free.fr" target="blank">http://casteyde.christian.free.fr</a>.</li>
<li>"Linux, un syst&egrave;me d'exploitation performant et libre" de Jean-Luc Barras.</li>
<li>"Premiers pas avec Linux" de Christophe Dioux.</li>
</ul>
<i>
Si vous avez des remarques, des suggestions, des insultes, besoin d'aide, ou toute autre chose &agrave;
me dire, n'h&eacute;sitez pas &agrave; me mailler: <a href="mailto:dave.lombardo1@caramail.com">dave.lombardo1@caramail.com</a>.
<p>
<b>Remarque</b>: Ce document est test&eacute; avec Internet Explorer 6.0.2600.0000 sous Windows 98 (mais
je pense que &ccedil;a marchera aussi pour IE 4 et 5), Netscape Communicator 4.77 et Konqueror 2.11(avec KDE
2.11) sous Linux Mandrake 8.0. Pour ce qui est de Lynx ou Links je suis d&eacute;sol&eacute; que la mise en forme
n'est pas assez bonne.
</i>
<hr><p>
<div align=center><u><font color="#3366ff" size=+2>Table des mati&egrave;res</font></u></div>
<p>
<ul>
    <li><a href="#intro">1- Introduction</a></li>
	<ul>
	    <li><a href="#define">1.1- De quoi vous me parlez l&agrave;?</a></li>
	    <li><a href="#pqlinux">1.2- Pourquoi Linux?</a></li>
                  <li><a href="#out">1.3- O&ugrave; trouver...</a></li>
                  <ul>
	        <li><a href="#linux">1.3.1- Linux.</a></li>
	        <li><a href="#help">1.3.2- de l'aide.</a></li>
	    </ul>
	</ul><p>
    <li><a href="#concept">2- Quelques concepts de base d'Unix</a></li>
	<ul>
	    <li><a href="#usgr">2.1- Utilisateurs et groupes</a></li>
	    <li><a href="#droits">2.2- Les fichiers</a></li>
	    <li><a href="#proc">2.3- Les processus (introduction)</a></li>
	    <li><a href="#cmd">2.4- La ligne de commande (pr&eacute;sentation)</a></li>
	</ul><p>
    <li><a href="#introcmd">3- Introduction &agrave; la ligne de commande</a></li>
	<ul>
	    <li><a href="#manipfile">3.1- Manipulation de fichiers</a></li>
	    <li><a href="#manipatrib">3.2- Manipulation des attributs de fichiers</a></li>
	    <li><a href="#redtub">3.3- Redirections et tubes</a></li>
                  <ul>
                        <li><a href="#redirect">3.3.1- Redirections</a></li>
                        <li><a href="#tubes">3.3.2- Tubes</a></li>
                  </ul>
	    <li><a href="#other">3.4- Autres</a></li>
		<ul>
		    <li><a href="#englob">3.4.1- Motifs d'englobement du shell</a></li>
		    <li><a href="#cmple">3.4.2- Le compl&egrave;tement (completion) dans les lignes de commande</a></li>
                    <li><a href="#arriere">3.4.3- Lancement et manipulation de processus en arri&egrave;re-plan</a></li>
               </ul>
	</ul><p>
    <li><a href="#divers">4- Divers  </a></li>
	<ul>
	    <li><a href="#edition">4.1- L'&eacute;dition de texte</a></li>
	    <li><a href="#utilcmd">4.2- Quelques utilitaires en ligne de commande</a></li>
	</ul><p>
    <li><a href="#conc">5- Conclusion</a></li>
</ul><p>
<hr><p>
<a name="intro"><font color="#ff0000" size=+2><u>1- Introduction: </u></font></a><br>
<blockquote>
<u><i><b><a name="define"><font color="#3366ff" size=+1>1.1- De quoi vous me parlez l&agrave;? </font></a></b></i></u><br>
Je vous parle de Linux (une r&eacute;ponse tr&egrave;s b&ecirc;te non?). Linux est un syst&egrave;me d'exploitation de type
UNIX libre et gratuit (parfois vous payez, mais c'est juste pour couvrir les frais des CDs...),
capable de tourner sur un simple PC (cependant, j'ai enetendu dire qu'il existe des versions
pour MAC ...). La premi&egrave;re version officielle de Linux date de 1991. Elle fut mise au point par
une &eacute;quipe de "hackers" (comprendre des vrais hackers et non pas des "crashers" !) autour de
Linus Torvalds de l'Universit&eacute; de Helsinki, Finlande.<p>
<u><i><b><a name="pqlinux"><font color="#3366ff" size=+1>1.2- Pourquoi Linux? </font></a></b></i></u><br>
Si tu en as marre de Windaube (F**k Kro$oft), alors tu dois installer Linux.<br>
Si votre petit Windaube (F**k Kro$oft une deuxi&egrave;me fois) plante tous les 5 minutes, alors tu dois
installer Linux.<br>
Si tu es fan de la programmation et tu cherches des compilateurs tr&egrave;s puissants et gratuit, alors tu dois installer Linux.<br>
Si tu es un Lamer et tu cherche &agrave; te faire remarquer devant tes amis, alors tu dois installer Linux (mais je suis s&ucirc;r que tu arriveras jamais ;-)).<br>
Si tu es simplement curieux et tu veux conna&icirc;tre un autre monde, alors tu dois installer Linux.<br>
Si tu cherches ton bonheur devant ton PC, alors IL VOUS FAUT LINUX.<p>
Si tu ... (Arr&ecirc;tez, j'en ai marre.).<p>
Pourquoi?!
<ul>
<li>Linux est multi-t&acirc;che: plusieurs programmes peuvent fonctionner simultan&eacute;ment.</li>
<li>Linux est multi-utilisateurs: plusieurs utilisateurs peuvent utiliser simultan&eacute;ment le m&ecirc;me
ordinateur, via un r&eacute;seau local ou via l'Internet, par exemple.</li>
<li>Linux est remarquablement stable. A moins de commettre des imprudences sous le compte "root",
il est extr&ecirc;mement difficile de le "planter" compl&egrave;tement.</li>
<li>Linux peut lire des disques de formats diff&eacute;rents du sien. A partir de Linux, vous pouvez
acc&eacute;der &agrave; vos donn&eacute;es qui se trouveraient par exemple sur votre partition MS-Windows. Toutefois,
le contraire n'est pas vrai.</li>
<li>Linux est tr&egrave;s secure s'il y a devant lui un administrateur comp&eacute;tent.</li>
<li>Il existe bien d'autres (beaucoup m&ecirc;me) avantages que si on les cite, on va d&eacute;passer le
niveau d&eacute;butant de ce document.</li>
</ul>
Cependant il existe quelques inconv&eacute;nients (si on peut les appeler comme &ccedil;a):
<ul>
<li>Pour que Linux puisse fonctionner confortablement, il sera indispensable de lui r&eacute;server une
partition &agrave; son propre format sur votre disque dur. Si vous n'avez qu'un seul disque dur et si
vous ne voulez pas vous risquer &agrave; le repartitionner, vous pourrez toujours essayer Linux &agrave; partir
de MSDOS gr&acirc;ce &agrave; une intallation "UMSDOS", mais vous risquez d'&ecirc;tre fort d&eacute;&ccedil;us du fait du
ralentissement qui s'ensuivra.</li>
<li>C'est vous &ecirc;tes fan de Microsoft Flight Simulator (arf) ou bien Tomb Raider, tampis pour
vous.</li>
</ul>
<u><i><b><a name="out"><font color="#3366ff" size=+1>1.3- O&ugrave; trouver... </font></a></b></i></u><br>
<blockquote>
<u><i><a name="linux"><font color="#099990" size=+1>1.3.1- Linux: </font></a></i></u><br>
<ul>
<li>On peut se procurer Linux gratuitement sur l'Internet. Par ailleurs, l'ensemble est assez
volumineux et, si Linux est gratuit, les communications t&eacute;l&eacute;phoniques (F**k ***t&eacute;l&eacute;kom)ne le sont
pas et les disquettes ou autres supports ne le sont pas non plus !</li>
<li>On peut aussi trouver Linux avec certains livres ou magazines.</li>
<li>La m&eacute;thode la plus simple &agrave; l'heure actuelle est donc de se procurer Linux sur CDrom, soit
dans les magasins de logiciels, soit par correspondance. Dans la plupart des cas, vous aurez
ainsi une "distribution" relativement homog&egrave;ne, qui contiendra, outre le syst&egrave;me d'exploitation
Linux, une grande quantit&eacute; de logiciels et de documentation. Avec certaines de ces distributions
(compter environ 300 FF), on trouve aussi des manuels papier fort complets et surtout une p&eacute;riode
d'assistance t&eacute;l&eacute;phonique ou par Internet.</li>
</ul>
<u><i><a name="help"><font color="#099990" size=+1>1.3.2- de l'aide: </font></a></i></u><br>
<ul>
<li>Une id&eacute;e est d'acheter un bouquin.</li>
<li>Une autre bonne id&eacute;e est de lire les howto et les guides fournit avec votre distribution.</li>
<li>S'indcrire dans des forums ou des newsgroupes.</li>
<li>Voici aussi quelques sites interessants:</li>
<ul>
<li><a href="http://www.linux-france.org" target="blank">www.linux-france.org</a></li>
<li><a href="http://www.freenix.org" target="blank">www.freenix.org</li>
<li><a href="http://uhp.u-nancy.fr/linux" target="blank">http://uhp.u-nancy.fr/linux</li>
</ul></ul>
<p></blockquote></blockquote><hr><p>
<a name="concept"><font color="#ff0000" size=+2><u>2- Quelques concepts de base d'Unix: </u></font></a><br>
<blockquote>
<u><i><b><a name="usgr"><font color="#3366ff" size=+1>2.1- Utilisateurs et groupes: </font></a></b></i></u><br>
<b>Remarque</b>: J'ai bien dit UNIX, parce que cela est le cas de tous les UNIX y compris Linux.
<p>
Comme vous le savez Linux est un syst&egrave;me d'exploitation multi-utilisateur, c'est pour &ccedil;a qu'il
est n&eacute;cessaire de s'identifier au d&eacute;but de chaque session. Chaque utilisateur a deux param&egrave;tres
importants:
<ul>
<li><b>Login</b>: c'est le nom avec lequel vous vous connectez &agrave; Linux.</li>
<li><b>Password</b>: c'est le mot de passe.</li>
</ul>
Pour se connecter en tant qu'utilisateur, c'est facile il suffit de remplir les champs login et
password (n'ayez pas peur si vous ne voyez rien &agrave; l'&eacute;cran quand vous tapez votre mot de pass,
normal non?). Et pour se d&eacute;connecter, tapez "logout", et si &ccedil;a marche pas tapez "exit".<p>
<b>Remarque</b>: Si vous &ecirc;tes "root", il existe deux autres commandes int&eacute;ressantes: "halt" pour
arr&ecirc;ter le syst&egrave;me et "reboot" pour le red&eacute;marrer.<p>
Pour ajouter un nouvel utilisateur (en mode console), vous devez taper: "adduser user", et &ccedil;a va
cr&eacute;er un nouvel utilisateur du nom "user", ainsi qu'un r&eacute;pertoire "/home/user", dans lequel
"user" aura ses fichiers. En fait, "adduser" est un script qui appelle "useradd" et cr&eacute;e en plus
le home (le r&eacute;p&eacute;rtoire dej&agrave; mentionn&eacute; l&agrave;-haut) du nouvel utilisateur.<p>
<b>Astuce</b>: Si votre commande "adduser" (ou "useradd") ne fonctionne plus, v&eacute;rifiez s'il
n'existe pas un fichier "/etc/pwd.lock", et d&eacute;truisez le ("rm /etc/pwd.lock").<p>
Pour changer le mot de passe d'un utilisateur: "passwd user" sous "root", ou "passwd" sous
"user".<br>
Pour retirer un utilisateur et tous ses documents : "userdel -r user" fera le travail.<br>
Tapez "who" pour savoir qu'ils sont les utilisateurs connect&eacute;s en ce moment, et "whoami" pour
savoir sous quel nom d'utilisateur vous vous &ecirc;tes connect&eacute;s.<p>
Vous entendez beaucoup parler de "root", en effet c'est un utilisateur sp&eacute;cial (vous le verrez
plus tard).<p>
A part les utilisateurs, sous Linux (et d'ailleurs tous les Unix) il existe ce qu'on appelle un
groupe. Les groupes sont utiles dans le cadre de partage de fichiers entre diff&eacute;rentes personnes.
Chaque groupe peut contenir autant d'utilisateurs que vous le souhaitez, et il est tr&egrave;s courant
de voir une telle s&eacute;paration dans les gros syst&egrave;mes.<br>Par d&eacute;faut Par d&eacute;faut, la cr&eacute;ation d'un
utilisateur cr&eacute;e aussi un groupe du m&ecirc;me nom que l'utilisateur.<br>
Pour cr&eacute;er un groupe: "groupadd nouveau_groupe" cr&eacute;e un groupe du nom nouveau_groupe.<br>
Pour ajouter l'utilisateur "user" au groupe nouveau_groupe : "gpasswd -a bebert nouveau_groupe".
<br>
Et pour identifier les groupes auxquels appartient l'utilisateur "user" : "groups user".<p>
Une autre chose &agrave; savoir c'est que le syst&egrave;me ne connait pas les utilisateurs ou les groupes par
leurs noms, mais par deux num&eacute;ros, le premier est UID (User ID) pour les utilisateurs, et GID
(Group ID) pour les groupes.<p>
<u><i><b><a name="droits"><font color="#3366ff" size=+1>2.2- Les fichiers: </font></a></b></i></u><b>(la majorit&eacute; de cette partie est tir&eacute;e du "Manuel de r&eacute;f&eacute;rence")</b><br>
En tant que propri&eacute;taire d'un fichier, un utilisateur peut &eacute;tablir des droits sur ce fichier. Ces
droits distinguent trois cat&eacute;gories d'utilisateurs: le propri&eacute;taire du fichier, tout utilisateur
qui est membre du groupe propri&eacute;taire associ&eacute; au fichier (appel&eacute; le groupe propri&eacute;taire) mais
n'est pas le propri&eacute;taire lui-m&ecirc;me, et les autres, cat&eacute;gorie qui regroupe tout utilisateur qui
n'est ni le propri&eacute;taire ni membre du groupe propri&eacute;taire.<p>
On distingue trois types de droits :
<ul>
<li><b>Droit de lecture (r pour Read, lire)</b> : sur un fichier, cela autorise la lecture de son
contenu. Pour un r&eacute;pertoire, cela autorise son contenu (c'est-&agrave;-dire les fichiers qu'il contient)
&agrave; &ecirc;tre list&eacute;.</li>
<li><b>Droit d'&eacute;criture (w pour Write, &eacute;crire)</b> : pour un fichier, cela autorise la
modification de son contenu. Pour un r&eacute;pertoire, l'acc&egrave;s en &eacute;criture autorise un utilisateur &agrave;
ajouter et/ou retirer des fichiers de ce r&eacute;pertoire, m&ecirc;me s'il n'est pas le propri&eacute;taire des dits
fichiers.</li>
<li><b>Droit d'ex&eacute;cution (x pour eXecute, ex&eacute;cuter)</b> : pour un fichier, cela en autorise
l'ex&eacute;cution (par cons&eacute;quent, seuls les fichiers ex&eacute;cutables devraient normalement avoir ce droit
positionn&eacute;). Pour un r&eacute;pertoire, cela autorise un utilisateur &agrave; le traverser (ce qui signifie
entrer dans ce r&eacute;pertoire ou passer par celui-ci). Notez bien la s&eacute;paration avec le droit en
lecture: il se peut tr&egrave;s bien que vous puissiez traverser un r&eacute;pertoire sans pouvoir lire son
contenu !</li>
</ul>
Toutes les combinaisons de ces droits sont possibles : vous pouvez par exemple autoriser la
lecture du fichier &agrave; vous seul et l'interdire &agrave; tous les autres. Vous pouvez m&ecirc;me faire
l'inverse, m&ecirc;me si ce n'est pas tr&egrave;s logique &agrave; premi&egrave;re vue... En tant que propri&eacute;taire du
fichier, vous pouvez en changer le groupe propri&eacute;taire (si et seulement si vous &ecirc;tes aussi
membre du nouveau groupe), voire vous en d&eacute;poss&eacute;der (c'est-&agrave;-dire en changer le propri&eacute;taire).
Bien s&ucirc;r, si vous vous d&eacute;poss&eacute;dez du fichier, vous perdez tous vos droits dessus...<p>
Prenons un exemple:
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>ls -l</b><br>
total 1<br>
-rw-r----- &#160; 1 slaydave &#160; &#160;prog&#160;  &#160; &#160; 51230 Jul &#160;16 14:11 langage_c<br>
drwxr-xr-- &#160; 2 user &#160; &#160;prog&#160;  &#160; &#160;  1024 Jul &#160;8 14:11 programmation/<br>
$
<div align=center>-----------------------------<br>
pour "$" il s'agit de l'invite de la ligne de commande,<br>pour le "root" il est souvent marqu&eacute; "#".<br>
Ce qui est est en gras c'est ce que vous tapez.</div></td>
</tr>
</table><p>
Les dix premiers caract&egrave;res d&eacute;signent successivement le type du fichier et les droits qui lui
sont associ&eacute;s; le premier caract&egrave;re d&eacute;signe le type du fichier : c'est un tiret (-) s'il s'agit
d'un fichier ordinaire, (d) si le fichier est un r&eacute;pertoire. Il existe d'autres types de
fichiers mais on est encore d&eacute;butant pour les savoir, alors patience. Les neuf caract&egrave;res qui
suivent repr&eacute;sentent les droits associ&eacute;s au fichier. On constatera ici la distinction faite entre
les diff&eacute;rents types d'utilisateurs pour un m&ecirc;me fichier : les trois premiers caract&egrave;res
repr&eacute;sentent les droits octroy&eacute;s &agrave; l'utilisateur propri&eacute;taire, les trois suivants s'appliquent &agrave;
tout utilisateur du groupe qui n'est pas le propri&eacute;taire, et les trois derniers aux autres; un
tiret (-) signifie que le droit n'est pas octroy&eacute;.<br>
Vient ensuite le nombre de liens du fichier (on verra pas &ccedil;a une autre fois).
Viennent ensuite le nom de l'utilisateur propri&eacute;taire du fichier et le nom du groupe
propri&eacute;taire.<br>
Enfin sont affich&eacute;s la taille du fichier (en octets) ainsi que la date de sa derni&egrave;re
modification, et pour finir le nom du fichier ou r&eacute;pertoire lui-m&ecirc;me.<p>
Observons maintenant en d&eacute;tails les droits associ&eacute;s &agrave; l'acc&egrave;s de chacun de ces fichiers : il
faut tout d'abord enlever le premier caract&egrave;re, qui d&eacute;signe le type ; donc pour le fichier
"langage_c", les droits accord&eacute;s sont : "rw-r-----". Voici comment les interpr&eacute;ter :<br>
<ul>
<li>Les trois premiers (rw-) sont les droits accord&eacute;s &agrave; l'utilisateur propri&eacute;taire de ce fichier,
en l'occurrence "slaydave". L'utilisateur "slaydave" peut donc lire le fichier (r), le modifier
(w) mais pas l'ex&eacute;cuter (-).</li>
<li>Les trois suivants (r--) sont conc&eacute;d&eacute;s &agrave; tout utilisateur qui n'est pas slaydave mais qui
appartient au groupe "prog" : il pourra lire le fichier (r), mais ne pourra ni le modifier ni
l'ex&eacute;cuter (--).</li>
<li>Les trois derniers (---) s'appliquent &agrave; tout utilisateur qui n'est pas slaydave et qui
n'appartient pas au groupe "prog" : un tel utilisateur n'a tout simplement aucun droit sur ce
fichier.</li>
</ul>
Pour le r&eacute;pertoire "programmation", les droits sont rwxr-xr--, et donc :
<ul>
<li>"user", en tant que propri&eacute;taire du r&eacute;pertoire, peut en lister le contenu (r), peut ajouter
des fichiers dans ce r&eacute;pertoire ou en supprimer (w), et il peut traverser ce r&eacute;pertoire (x).</li>
<li>Tout utilisateur qui n'est pas "user" mais appartient au groupe "prog" pourra lister le
contenu de ce r&eacute;pertoire (r) mais ne pourra pas y ajouter des fichiers (-); il aura par contre
le droit de le traverser (x).</li>
<li>Tout autre utilisateur ne pourra que lister les fichiers de ce r&eacute;pertoire (r), mais c'est
tout. Il ne sera m&ecirc;me pas capable de le traverser.</li>
</ul>
Il existe une exception &agrave; ces r&egrave;gles : "root". "root" peut changer les attributs (droits,
propri&eacute;taire, groupe propri&eacute;taire) de tous les fichiers, m&ecirc;me s'il n'en est pas le propri&eacute;taire.
Cela veut dire qu'il peut aussi s'en attribuer la propri&eacute;t&eacute; ! Il peut lire des fichiers sur
lesquels il n'a pas le droit de lecture, traverser des r&eacute;pertoires auxquels il n'aurait
normalement pas acc&egrave;s, et ainsi de suite. Et s'il lui manque un droit, il lui suffit juste de le
rajouter..., le "root" est donc le super-utilisateur.<p>
Pour conclure, il est utile de mentionner les diff&eacute;rences entres les noms de fichiers dans le
monde Unix et le monde Windows. Unix permet une flexibilit&eacute; bien plus grande et a moins de
limitations :
<ul>
<li>Un nom de fichier peut comporter n'importe quel caract&egrave;re (&agrave; l'exception du caract&egrave;re ASCII
0, qui d&eacute;note la fin d'une cha&icirc;ne de caract&egrave;res, et /, qui est le s&eacute;parateur de r&eacute;pertoires),
m&ecirc;me des caract&egrave;res non imprimables. De plus, Unix est sensible &agrave; la casse : les fichiers readme
et Readme sont diff&eacute;rents, car r et R sont deux caract&egrave;res diff&eacute;rents.</li>
<li>Comme vous avez pu le remarquer, un nom de fichier ne comporte pas forc&eacute;ment une extension, &agrave;
moins que vous le vouliez. Les extensions de fichiers n'identifient pas le contenu des dits
fichiers sous Linux, pas plus qu'elles ne le font sur n'importe quel autre syst&egrave;me
d'exploitation, d'ailleurs. Ces &laquo; extensions  &raquo; ainsi nomm&eacute;es sont toujours tr&egrave;s pratique,
cependant. Le caract&egrave;re point (.) sous Unix est juste un caract&egrave;re comme les autres. On peut
noter que les noms de fichiers commen&ccedil;ant avec un point sous Unix sont des &laquo;fichiers
cach&eacute;s&raquo;.</li>
</ul>
<u><i><b><a name="proc"><font color="#3366ff" size=+1>2.3- Les processus (introduction): </font></a></b></i></u><b>(M&ecirc;me chose que pour la partie pr&eacute;c&eacute;dente)</b><br>
On d&eacute;signe par le terme de processus une instance de programme en cours d'ex&eacute;cution et son
environnement. Chaque processus s'ex&eacute;cute avec les droits de l'utilisateur qui l'a lanc&eacute;. En
interne, le syst&egrave;me identifie les processus de fa&ccedil;on unique gr&acirc;ce &agrave; un num&eacute;ro. Ce num&eacute;ro est
appel&eacute; le PID (Process ID). Avec ce PID, le syst&egrave;me sait, entre autres choses, qui (quel
utilisateur, donc) a lanc&eacute; le processus. Il lui reste alors &agrave; v&eacute;rifier si ce que le processus
demande est &laquo; l&eacute;gal  &raquo;. Si on en revient donc &agrave; l'exemple du fichier "langage_c" cit&eacute; plus haut,
un processus lanc&eacute; par l'utilisateur "user" sera capable d'ouvrir ce fichier en lecture seule,
mais pas en lecture/&eacute;criture, puisque les droits associ&eacute;s au fichier l'interdisent. Encore une
fois, l'exception &agrave; la r&egrave;gle est "root"...<p>
Cela a pour cons&eacute;quence que Linux est virtuellement immunis&eacute; contre les virus : pour op&eacute;rer,
les virus doivent infecter des fichiers ex&eacute;cutables du syst&egrave;me. Mais avec le seul statut
d'utilisateur, il leur est impossible de modifier ces fichiers, ce qui r&eacute;duit le risque
d'autant. Ajoutons que les virus sont, en g&eacute;n&eacute;ral, tr&egrave;s rares dans le monde Unix : jusque l&agrave;,
il n'existe que trois virus connus pour Linux (Je sais pas s'il existe d'autres), et ils sont
compl&egrave;tement inoffensifs lorsqu'ils sont lanc&eacute;s par un utilisateur normal. Un seul utilisateur
peut vraiment endommager le syst&egrave;me en activant ces virus, et, encore une fois, c'est... "root".
<br>
Paradoxalement, il existe bien des logiciels antivirus sous Linux pour... les fichiers
DOS/Windows. En effet, de plus en plus de serveurs de fichiers Linux fournissent des machines
Windows, avec le paquetage logiciel Samba (non, on va pas parler de &ccedil;a).<p>
Linux permet &eacute;galement un contr&ocirc;le ais&eacute; des processus. Une fa&ccedil;on de les contr&ocirc;ler sont les
signaux. Avec les signaux, vous pouvez par exemple suspendre un processus ou le tuer. Envoyez
simplement le signal correspondant au processus et c'est fait. Toutefois, vous serez limit&eacute; &agrave;
l'envoi de signaux &agrave; vos propres processus, pas aux processus lanc&eacute;s par un autre utilisateur.
L'exception &agrave; la r&egrave;gle est "root". Oui, encore lui !(Dans un autre article, on va parler de &ccedil;a en
d&eacute;tail).<p>
<u><i><b><a name="cmd"><font color="#3366ff" size=+1>2.4- La ligne de commande (pr&eacute;sentation): </font></a></b></i></u><br>
La ligne de commande est le moyen le plus direct pour donner des ordres &agrave; la machine. Le shell
est le programme qui se charge de lire et dex&eacute;cuter les commandes que lutilisateur saisit.
Classiquement, le shell est utilis&eacute; de mani&egrave;re interactive, cest &agrave; dire que lutilisateur
dialogue avec le syst&egrave;me par linterm&eacute;diaire du shell. Il saisit les commandes, et le shell les
ex&eacute;cute et affiche les r&eacute;sultats. Le shell le plus couramment utilis&eacute; sous Linux est sans aucun
doute bash. En tout cas, cest le shell par d&eacute;faut que la plupart des distributions utilisent.
Il est donc conseill&eacute; de conna&icirc;tre un petit peu ce que ce shell est capable de r&eacute;aliser, et
comment. Son nom provient de labr&eacute;viation de langlais &laquo;Bourne Again SHell&raquo;, ce qui signifie
quil sagit effectivement dune nouvelle variante du shell sh.<br>
Au temps des interfaces graphiques complexes et sophistiqu&eacute;es, il peut para&icirc;tre archa&iuml;que de
vouloir encore utiliser des lignes de commandes pour utiliser un ordinateur. Cest en partie
vrai, mais il faut savoir que les shells Unix sont extr&ecirc;mement puissants et que les interfaces
graphiques ne permettent toujours pas, m&ecirc;me &agrave; lheure actuelle, de r&eacute;aliser toutes les t&acirc;ches
faisables avec un shell. Dautre part, il est souvent plus efficace de taper une simple commande
dans un shell que de rechercher un outil graphique et de parcourir les divers menus, puis de
choisir les options de la commande d&eacute;sir&eacute;e avant de valider. Des ergonomes ont d&eacute;montr&eacute;, et des
graphistes du monde entier le confirmeront, que la souris nest pas le p&eacute;riph&eacute;rique dentr&eacute;e le
plus pr&eacute;cis et le plus facile &agrave; utiliser pour manipuler les objets de lenvironnement
utilisateur.<br>
Quoi quil en soit, le shell est bien plus quun interpr&eacute;teur de commande. Il sagit r&eacute;ellement
dun environnement de programmation, permettant de d&eacute;finir des variables, des fonctions, des
instructions complexes et des programmes complets, que lon appelle des scripts shell.<br>
Mais ne comptez pas de savoir le tout &agrave; la fois, on verra &ccedil;a dans un autre article.<p>
Voici quelques commandes importantes &agrave; savoir:
<ul>
<li><b>su</b>: pour devenir root provisoirement.</li>
<li><b>pwd</b>: pour savoir o&ugrave; on est sur le syst&egrave;me.</li>
<li><b>cd</b>: pour changer le r&eacute;pertoire.<br>
Elle peut &ecirc;tre utilis&eacute;e avec "." et "..", qui sont respectivement le r&eacute;pertoire courant et son
r&eacute;pertoire parent.<br>
Taper simplement "cd" vous ram&egrave;nera &agrave; votre r&eacute;pertoire personnel.<br>
Taper "cd -" vous renverra dans le dernier r&eacute;pertoire visit&eacute;. Et enfin, vous pouvez sp&eacute;cifier
le r&eacute;pertoire d'un utilisateur "user" en tapant "~darth" ("~" seul signifie votre propre
r&eacute;pertoire personnel). Notez qu'en tant qu'utilisateur normal, vous ne pouvez, en g&eacute;n&eacute;ral, pas
acc&eacute;der au r&eacute;pertoire d'un autre utilisateur (&agrave; moins qu'il ne l'ait explicitement autoris&eacute; ou
que tel soit le r&eacute;glage de la configuration par d&eacute;faut du syst&egrave;me), sauf si vous &ecirc;tes "root".
</li>
<li><b>man</b>: "man commande" vous offres tous les informations sur le commande "commande". (Il
existe aussi "info" qui fait la m&ecirc;me chose).<br>
Parfois vous tombez sur une expression tel que "voir les page de manuel commande(2)", pour cela vous
faites: <b>man 2 commande</b>.
</li>
<li><b>cat</b>: Afficher le contenu d'un ou plusieurs fichiers sur la sortie standard, donc
l'&eacute;cran en temps normal.</li>
<li><b>less</b>: Utilisez less pour voir des gros fichiers, qui ne rentrent pas sur un &eacute;cran.
</li>
<li><b>ls</b>: Faire une liste de fichiers (meilleur que dir du DOS). (consulter les pages man
pour plus d'info sur les options de cette commande).</li>
</ul>
<b>Exercice</b>:<br>
Aller voir les pages man des commandes suivantes: "su", "pwd", "cd", "cat", "less", "ls" et
"man".<p>
A la fin de cette partie j'ai d&eacute;cid&eacute; de vous donner une liste des principaux racourcis de clavier
pour le shell BASH.
D'abord les touches fl&eacute;ch&eacute;es : Bash maintient un historique des commandes que vous tapez,
dans lequel vous pouvez vous balader avec les fl&egrave;ches haut et bas. Vous pouvez remonter jusqu'&agrave;
un nombre de lignes d&eacute;finies dans la variable d'environnement HISTSIZE (on va revenir au sujet de
ces variables plus tard). De plus, l'historique est persistant d'une session &agrave; l'autre, donc
vous ne perdrez pas les commandes que vous avez tap&eacute;es lors d'une session pr&eacute;c&eacute;dente.<br>
Les fl&egrave;ches gauche et droite d&eacute;placent le curseur dans le sens indiqu&eacute;. Vous pouvez ainsi
&eacute;diter vos lignes de cette fa&ccedil;on.<br>
"Ctrl+a" et "Ctrl+e", vous am&egrave;neront respectivement au d&eacute;but et &agrave; la fin de la ligne
courante. Les touches "Backspace" et "Suppr" (aussi appel&eacute; "Del") fonctionneront comme on s'y
attend. Un &eacute;quivalent de "Backspace" est "Ctrl+h" et un &eacute;quivalent de "Suppr" est "Ctrl+d".
"Ctrl+k" effacera toute la ligne depuis la position du curseur jusqu'&agrave; la fin de la ligne, et
"Ctrl+w" effacera le mot qui pr&eacute;c&egrave;de la position du curseur.<br>
Taper "Ctrl+d" sur une ligne vide vous fera fermer la session actuelle, ce qui est un vrai
raccourci par rapport &agrave; la commande "exit". "Ctrl+c" interrompra la commande en cours
d'ex&eacute;cution, sauf si vous &eacute;tiez en train d'&eacute;diter une ligne, auquel cas ce sera l'&eacute;dition en
cours qui sera interrompue et vous serez ramen&eacute; &agrave; l'invite. "Ctrl+l" nettoie l'&eacute;cran.<br>
Il existe beaucoup d'autres racourcis, mais ce sont les essentiels.<p>
</blockquote><hr><p>
<a name="introcmd"><font color="#ff0000" size=+2><u>3- Introduction &agrave; la ligne de commande: </u></font></a><br>
<blockquote>
<u><i><b><a name="manipfile"><font color="#3366ff" size=+1>3.1- Manipulation de fichiers: </font></a></b></i></u><br>
La manipulation de fichiers signifie ici "copier", "d&eacute;placer" et "effacer" des fichiers. Le
changement de leurs attributs (propri&eacute;taire, permissions associ&eacute;es) sera examin&eacute; par la suite.<p>
<ul>
<li><b>mkdir</b>: cette commande permet de cr&eacute;er des r&eacute;pertoire.
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr>
<td>
$<b>mkdir metal</b><br>
<div align=center>-----------------------------<br>
cr&eacute;er un r&eacute;pertoire "metal" dans le r&eacute;pertoire courant.</div><br></td></tr>
<tr><td>
$<b>mkdir -p musique/slayer</b><br>
<div align=center>-----------------------------<br>
cr&eacute;er un r&eacute;pertoire "slayer" dans le r&eacute;pertoire "musique" apr&egrave;s avoir cr&eacute;er ce dernier s'il
n'existait pas.</div>
</td></tr>
</table><p></li>
<li><b>touch</b>: cette commande a pour but de mettre &agrave; jour les dates d'acc&egrave;s et de modification
d'un fichier, mais on peut l'utiliser pour cr&eacute;er des fichier vides.
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>touch paroles/reign_in_blood interview</b><br>
<div align=center>-----------------------------<br>
cr&eacute;er un fichier "reign_in_blood" de taille 0 dans le r&eacute;pertoire "paroles" (s'il existait), et un
fichier "interview" aussi de taille 0 dans le r&eacute;pertoire courant.</div>
</td></tr>
</table><p></li>
<li><b>rm</b>: (ReMove) cette commande permet supprimer des fichiers ou des r&eacute;pertoires.<br>
Cette commande accepte plusieurs options:
<ul>
<li>-r ou -R : supprime r&eacute;cursivement. Cette option est obligatoire pour supprimer un r&eacute;pertoire,
cependant il existe aussi une commande <b>rmdir</b>, mais elle ne supprime que des r&eacute;pertoires
vides.</li>
<li>-i : demande une confirmation avant chaque effacement. Cette option est par d&eacute;faut dans
plusieurs distribution.</li>
<li>-f : le contraire de -i, cette option force la suppression des fichiers ou r&eacute;pertoires.</li>
</ul>
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>rm -rf morbid/</b><br>
<div align=center>-----------------------------<br>
supprimer tout le r&eacute;pertoire "morbid".</div><br></td></tr>
<tr><td>
$<b>rm -i *.txt</b><br>
<div align=center>-----------------------------<br>
supprimer tout les fichiers terminants par ".txt" dans le r&eacute;pertoire courant avec demande de
confirmation (tapez o ou y pour confirmer, ou n sinon).</div>
</td></tr>
</table><p></li>
<li><b>mv</b>: cette commande permet de d&eacute;placer un fichier ou un dossier (peut aussi changer son
nom).<br>
Voici quelques options de cette commande:
<ul>
<li>-f : force l'op&eacute;ration -. Aucun avertissement en cas d'&eacute;crasement d'un fichier au cours de
l'op&eacute;ration.</li>
<li>-i : le contraire: demande une confirmation &agrave; l'utilisateur avant d'&eacute;craser un fichier
existant.</li>
<li>-v : mode verbeux qui rapporte tous les changements.</li>
</ul>
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>mv -f slayer/disco/*.htm .</b><br>
<div align=center>-----------------------------<br>
d&eacute;placer tous les fichiers du r&eacute;pertoire "slayer/disco" terminants par ".htm" dans le r&eacute;pertoire
courant (.), sans demande de confirmation.</div><br></td></tr>
<tr><td>
$<b>mv udisputed_attitude undisp</b><br>
<div align=center>-----------------------------<br>
renommer le fichier "undisputed_attitude" en "undisp".
</div></td>
</tr>
</table><p></li>
<li><b>cp</b>: cette commande permet de copier des fichiers ou des r&eacute;pertoires.<br>
Voici ses principaux options:
<ul>
<li>-R : copie r&eacute;cursivement; obligatoire pour copier un r&eacute;pertoire.</li>
<li>-i : demande une confirmation avant d'&eacute;craser des fichiers.</li>
<li>-f : le contraire de -i.</li>
<li>-v : mode verbeux qui mentionne toutes les actions effectu&eacute;es par cp.</li>
</ul>
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>cp -i slayer/photos/*.gif slayer/images/</b><br>
<div align=center>-----------------------------<br>
copier tous les fichiers se terminants par ".gif" du r&eacute;pertoire "slayer/photos" dans le
r&eacute;pertoire "slayer/images/", en demandant une confirmation avant d'&eacute;craser un fichier.</div><br></td></tr>
<tr><td>
$<b>cp -vR testament/paroles/ obituary/paroles/ ..</b><br>
<div align=center>-----------------------------<br>
copier tout les r&eacute;pertoire "testament/paroles/" "obituary/paroles/" dans le r&eacute;pertoire parent.
</div></td>
</tr>
</table><p></li>
</ul>
<u><i><b><a name="manipatrib"><font color="#3366ff" size=+1>3.2- Manipulation des attributs de fichiers: </font></a></b></i></u><br>
Les commandes pr&eacute;sent&eacute;e ici sont utilis&eacute;es pour changer le propri&eacute;taire ou groupe propri&eacute;taire d'un fichier ou ses droits
d'acc&egrave;s.<p>
<ul>
<li><b>chown</b> : changer le propri&eacute;taire d'un ou plusieurs fichiers.<br>
Ses options:
<ul>
<li>-R : r&eacute;cursif; change le propri&eacute;taire de tous les fichiers et sous-r&eacute;pertoires d'un r&eacute;pertoire donn&eacute;.</li>
<li>-v : mode verbeux; d&eacute;crit toutes les actions effectu&eacute;es par chown; indique quels fichiers ont chang&eacute; de
propri&eacute;taire &agrave; la suite de la commande et lesquels sont demeur&eacute;s inchang&eacute;s.</li>
<li>-c : comme -v, mais ne mentionne que les fichiers pour lesquels un changement a eu lieu.</li>
</ul>
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>chown slaydave /shared/book.tex</b><br>
<div align=center>-----------------------------<br>
changer le propri&eacute;taire du fichier "/shared/book.tex" pour nobody.
</div><br></td></tr>
<tr><td>
$<b>chown -Rc storm.metal *.mp3 musique/</b><br>
<div align=center>-----------------------------<br>
donner la propri&eacute;t&eacute; de tous les fichiers dans le r&eacute;pertoire courant se terminant par ".mp3" et de tous les fichiers
et sous-r&eacute;pertoires du r&eacute;pertoire "musique/" &agrave; "storm" et au groupe "metal", en ne mentionnant que les fichiers
affect&eacute;s par la commande.
</div></td>
</tr>
</table><p></li>
<li><b>chgrp</b>: (CHange GRouP) ne vous laisse changer que le groupe propri&eacute;taire d'un
fichier ou d'un groupe de fichiers; sa syntaxe est tr&egrave;s semblable &agrave; celle de la commande chown.
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>chgrp death metal/obit*</b><br>
<div align=center>-----------------------------<br>
attribuer au groupe "death" tous les fichiers du r&eacute;pertoire "metal/" dont le nom
commence par "obit".
</div></td>
</tr>
</table><p></li>
<li><b>chmod</b>: changer les permissions sur des fichiers et des r&eacute;pertoires.<br>
La syntaxe de cette commande est un peu particuli&egrave;re:<br>
<b>chmod [options] "changement de mode" "fichier|r&eacute;p." [fichier|r&eacute;p...]</b><br>
Ce qui est entre crochets est facultatif, le signe "|" signifie "ou".<p>
Le changement de mode peut se produire de deux fa&ccedil;ons:
<ul>
<li>en octal; les droits d'acc&egrave;s de l'utilisateur propri&eacute;taire correspondent alors &agrave; des chiffres
de la forme <x>00, o&ugrave; <x&gt;  correspond au droit assign&eacute; : 4 pour lecture, 2 pour &eacute;criture, 1 pour
ex&eacute;cution; de m&ecirc;me, les droits d'acc&egrave;s du groupe propri&eacute;taire sont de la forme <x>0 et ceux des
&laquo;autres&raquo; sont de la forme x. Pour obtenir le chiffre correct, il suffira d'additionner les
droits d'acc&egrave;s assign&eacute;s chiffre. Ainsi, les permissions rwxr-xr-- correspondent &agrave; 400+200+100
(droits d'acc&egrave;s de l'utilisateur propri&eacute;taire, rwx) +40+10 (droits d'acc&egrave;s du groupe, r-x) +4
(droits d'acc&egrave;s des autres, r--) = 754; les droits d'acc&egrave;s sont ainsi exprim&eacute;s de mani&egrave;re
absolue : les droits d'acc&egrave;s pr&eacute;c&eacute;dents sont remplac&eacute;s de fa&ccedil;on inconditionnelle.</li>
<li>&agrave; l'aide de certaines expressions : les droits d'acc&egrave;s sont ici indiqu&eacute;s par une suite
d'expressions s&eacute;par&eacute;es par des virgules, une expression &eacute;tant de la forme<br>
<b>[cat&eacute;gorie] "+|-" "droits d'acc&egrave;s"</b><br>
La cat&eacute;gorie peut &ecirc;tre une combinaison de : u (User, utilisateur, permission pour propri&eacute;taire),
g (Group, groupe, permision pour le groupe propri&eacute;taire) ou o (Others, permission pour les &laquo; autres  &raquo;).
Si aucune cat&eacute;gorie n'est sp&eacute;cifi&eacute;e, le changement s'applique &agrave; toutes les cat&eacute;gories.<br>
Un "+" appose un droit d'acc&egrave;s, un "-" le retire et un "=" &eacute;tablit la permission.<br>
Pour finir, les droits d'acc&egrave;s sont d&eacute;finis par une ou plusieurs des lettres suivantes : r (Read, lecture),
w (Write, &eacute;criture) ou x (eXecute, ex&eacute;cution.</li>
</ul>
Les options principales sont tr&egrave;s similaires &agrave; celles de chown ou chgrp :
<ul>
<li>-R : change les droits d'acc&egrave;s r&eacute;cursivement.</il>
<li>-v : mode verbeux; d&eacute;crit les actions effectu&eacute;es pour chaque fichier.</il>
<li>-c : comme -v mais ne mentionne que les fichiers dont les droits d'acc&egrave;s ont chang&eacute;.</il>
</ul>
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>chmod -R o-w metal/</b><br>
<div align=center>-----------------------------<br>
enlever de fa&ccedil;on r&eacute;cursive le droit d'&eacute;criture aux &laquo;autres&raquo; sur
tous les fichiers et sous-r&eacute;pertoires du r&eacute;pertoire "metal".</div><br></td></tr>
<tr><td>
$<b>chmod -R og-w,o-x slayer/</b><br>
<div align=center>-----------------------------<br>
enlever de fa&ccedil;on r&eacute;cursive le droit d'&eacute;criture pour le groupe et les
autres sur tout le r&eacute;pertoire "slayer/", et retirer le droit d'ex&eacute;cution pour les autres.
</div><br></td></tr>
<tr><td>
$<b>chmod -c 644 divers/perso*/</b><br>
<div align=center>-----------------------------<br>
change les droits d'acc&egrave;s de tous les fichiers du r&eacute;pertoire
"divers/" dont les noms commencent par "perso" en rw-r--r-- (droit de lecture pour tout le monde
et droit d'&eacute;criture pour le propri&eacute;taire du fichier seulement), et ne mentionne que les
fichiers affect&eacute;s par l'op&eacute;ration.</div></td>
</tr>
</table><p></li>
</ul>
<u><i><b><a name="redtub"><font color="#3366ff" size=+1>3.3- Redirections et tubes: </font></a></b></i></u><b>(Tir&eacute; du "Manuel de r&eacute;f&eacute;rence")</b><br>
<blockquote>
<u><i><a name="redirect"><font color="#099990" size=+1>3.3.1- Redirections: </font></a></i></u><br>
Pour comprendre le principe des redirections et des tubes, ils nous faudra introduire ici une
nouvelles notion qui concerne les processus. Chaque processus sous Unix (y compris les
applications graphiques) ouvre un minimum de trois descripteurs de fichiers : l'entr&eacute;e
standard, la sortie standard et le canal d'erreur standard. Leurs num&eacute;ros respectifs sont 0, 1
et 2. En g&eacute;n&eacute;ral, ces trois descripteurs sont associ&eacute;s au Terminal depuis lequel le processus a
&eacute;t&eacute; lanc&eacute;, l'entr&eacute;e standard &eacute;tant lue depuis le clavier. Le but des redirections et des tubes
est de rediriger ces descripteurs.<p>
Dans cette section on va parler des redirections.<p>
Supposons, par exemple, que vous vouliez conna&icirc;tre la liste des fichiers se terminant par
".png" dans le r&eacute;pertoire "images", et que cette liste soit tr&egrave;s longue : il serait donc
pertinent de la stocker dans un fichier pour la consulter &agrave; loisir ensuite. Vous pouvez alors
taper ceci :
<br>
$ <b>ls images/*.png 1>liste_fichiers</b><br>
Ce qui signifie que la sortie standard de cette commande (1) est redirig&eacute;e (>) vers le fichier
qui a pour nom liste_fichiers. Le signe &gt;  est l'op&eacute;rateur de redirection de sortie. Dans le cas
o&ugrave; le fichier de redirection n'existe pas, il est alors cr&eacute;&eacute;. Par contre, s'il existait
pr&eacute;c&eacute;demment, son ancien contenu est &eacute;cras&eacute;. Cependant, par d&eacute;faut, le descripteur redirig&eacute; par
cet op&eacute;rateur est la sortie standard, il n'est donc pas n&eacute;cessaire de le sp&eacute;cifier sur la
ligne de commande. Vous pouvez donc &eacute;crire plus simplement :
$ <b>ls images/*.png &gt; liste_fichiers</b><br>
et le r&eacute;sultat sera exactement le m&ecirc;me. Vous pouvez ensuite consulter le fichier &agrave; l'aide d'un
visualisateur de fichiers textes tel que "less".<p>
Supposons maintenant que vous vouliez conna&icirc;tre le nombre exact de ces fichiers. Au lieu de
compter manuellement, vous pouvez utiliser le bien nomm&eacute;  : "wc" (Word Count, comptage des mots)
avec l'option -l, qui &eacute;crit sur la sortie standard le nombre de lignes du fichier. Pour obtenir
le r&eacute;sultat d&eacute;sir&eacute;, une solution possible serait la suivante :<br>
<b>wc -l 0 &lt;liste_fichiers</b><br>
Le signe &lt; est l'op&eacute;rateur de redirection d'entr&eacute;e. Le descripteur redirig&eacute; par d&eacute;faut est
&eacute;galement celui de l'entr&eacute;e standard, donc 0. La ligne s'&eacute;crit alors simplement :<br>
<b>wc -l &lt;liste_fichiers</b><p>
Supposons maintenant que vous vouliez retirer de cette liste toutes les &laquo;extensions&raquo; des
fichiers puis sauvegarder le r&eacute;sultat dans un autre fichier. L'outil dont vous aurez besoin
sera : "sed", pour Stream EDitor (&eacute;diteur de flux). Il suffira de rediriger l'entr&eacute;e standard de
sed vers le fichier liste_fichiers et de rediriger sa sortie vers le fichier r&eacute;sultat, par
exemple la_liste :
<b>sed -e 's/\.png$//g' &lt;liste_fichiers &gt; la_liste</b><br>
Il vous sera &eacute;galement possible de consulter &agrave; loisir cette nouvelle liste avec un
visualisateur.<p>
Il pourrait aussi s'av&eacute;rer utile de rediriger l'erreur standard. Par exemple, vous voulez
savoir quels r&eacute;pertoires dans /shared ne vous sont pas accessibles : une solution est de lister
r&eacute;cursivement ce r&eacute;pertoire et de rediriger les erreurs vers un fichier, tout en n'affichant
pas le canal de sortie standard :<br>
<b>ls -R /shared &gt; /dev/null 2>erreurs</b><br>
Ce qui signifie que la sortie standard sera redirig&eacute;e (>) vers /dev/null, un fichier sp&eacute;cial
dans lequel tout ce qu'on &eacute;crit est perdu (et aura comme effet secondaire que la sortie
standard ne sera pas affich&eacute;e) et que le canal d'erreur standard (2) est redirig&eacute; (>) vers le
fichier erreurs.<p>
<u><i><a name="tubes"><font color="#099990" size=+1>3.3.2- Tubes: </font></a></i></u><br>
Les tubes (pipes en anglais) sont en quelque sorte une combinaison des redirections d'entr&eacute;e
et de sortie. Leur principe mime en effet celui d'un tube: un processus envoie des donn&eacute;es
dans le tube par un bout et un autre processus lit les donn&eacute;es par l'autre bout. L'op&eacute;rateur
tube est "|". Reprenons l'exemple de la liste des fichiers ".png" ci-dessus. Supposons que vous
vouliez seulement conna&icirc;tre le nombre de fichiers en question sans avoir &agrave; stocker la liste
dans un fichier temporaire.<br>
utilisez alors la commande suivante:<br>
<b>ls images/*.png | wc -l</b><br>
ce qui signifie que la sortie standard de la commande ls (donc la liste des fichiers) est
redirig&eacute;e vers l'entr&eacute;e standard de la commande wc. Vous obtenez donc le r&eacute;sultat d&eacute;sir&eacute;.<p>
Vous pouvez de m&ecirc;me construire directement la liste des fichiers &laquo;sans les extensions&raquo; avec
la commande suivante:<br>
<b>ls images/*.png | sed -e 's/\.png//g' &gt;la_liste</b><p>
ou, si vous voulez simplement consulter la liste sans la stocker dans un fichier:<br>
<b>ls images/*.png | sed -e 's/\.png//g' | less</b><p>
Les tubes et les redirections ne sont pas limit&eacute;s au seul texte lisible par les humains. Ainsi
en est-il de la commande suivante, lanc&eacute;e &agrave; partir d'un xterm "console sous X-Window):<br>
<b>xwd -root | convert - ~/mon_bureau.png</b><br>
ce qui effectuera une capture d'&eacute;cran de votre bureau dans le fichier intitul&eacute;
mon_bureau.png dans votre r&eacute;pertoire personnel.<p>
</blockquote>
<u><i><b><a name="other"><font color="#3366ff" size=+1>3.4- Autres: </font></a></b></i></u><b>(encore tir&eacute; du "Manuel de r&eacute;f&eacute;rence")</b><br>
<blockquote>
<u><i><a name="englob"><font color="#099990" size=+1>3.4.1- Motifs d'englobement du shell: </font></a></i></u><br>
Il est probable que vous utilisiez d&eacute;j&agrave; sans le savoir des caract&egrave;res d'englobement. Quand vous
enregistrez un fichier dans une application sous Windows, quand vous recherchez un fichier,
vous utilisez "*" pour d&eacute;signer une suite de caract&egrave;res quelconque. Par exemple, "*.txt" d&eacute;signe
l'ensemble des fichiers dont le nom se termine par ".txt". Je l'ai &eacute;galement beaucoup utilis&eacute;
dans les sections pr&eacute;c&eacute;dentes, mais l'englobement va beaucoup plus loin que le seul "*".<p>
Quand vous tapez une commande comme "ls *.txt", puis Entr&eacute;e, la t&acirc;che de trouver quels fichiers
correspondent au motif "*.txt" n'est pas du ressort de ls, mais doit passer par le shell lui-m&ecirc;me.
Cela requiert donc une petite explication sur la fa&ccedil;on dont le shell interpr&egrave;te une ligne de
commande. Lorsque vous tapez :
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$ <b>ls *.txt</b><br>
readme.txt  recettes.txt<br>
</td>
</tr>
</table><p>
la ligne de commande est tout d'abord s&eacute;par&eacute;e en mots ("ls" et "*.txt" en l'occurrence). Quand le
shell voit le "*" dans un des mots, il interpr&egrave;te le mot comme &eacute;tant un motif englobant et le
remplace dans la ligne de commande par les noms de tous les fichiers correspondant au motif. La
ligne qui se trouve juste avant que ne s'enclenche l'ex&eacute;cution par le shell est donc devenue
"ls readme.txt recettes.txt", ce qui donnera le r&eacute;sultat recherch&eacute;. Le shell r&eacute;agit aussi &agrave; la
vue d'autres caract&egrave;res :
<ul>
<li><b>?</b>: correspond &agrave; un caract&egrave;re unique, quel qu'il soit.</li>
<li><b>[...]</b>: correspond &agrave; tout caract&egrave;re &eacute;crit entre les crochets; les caract&egrave;res peuvent
d&eacute;signer soit des intervalles (par exemple, 1-9), soit des valeurs discr&egrave;tes, soit encore un
m&eacute;lange des deux. Exemple : "[a-zBE5-7]" correspond &agrave; tous les caract&egrave;res de a &agrave; z, un B, un E,
un 5, un 6 ou un 7.</li>
<li><b>[!...]</b>: correspond &agrave; tous les caract&egrave;res qui ne se trouvent pas entre les crochets;
[!a-z], par exemple, correspond &agrave; tout caract&egrave;re qui n'est pas une lettre minuscule.</li>
<li><b>&lcub;c1,c2&rcub;</b>: correspond &agrave; c1 ou c2, o&ugrave; c1 et c2 sont &eacute;galement des caract&egrave;res
d'englobement, ce qui signifie que vous pouvez &eacute;crire "&lcub;[0-9]*,[acr]&rcub;" par exemple.
</li>
</ul>
Voici quelques exemples:
<ul>
<li><b>image/cars,space[0-9]/*.jpg</b>: tous les fichiers dont le nom se termine par ".jpg" dans
les r&eacute;pertoires image/cars, image/space0, jusqu'&agrave; image/space9, s'ils existent.</li>
<li><b>/usr/doc/*/README</b>: tous les fichiers de nom README dans tous les sous-r&eacute;pertoires
imm&eacute;diats de /usr/share/doc. Cela correspondra &agrave; /usr/share/doc/mandrake/README par exemple, mais
pas &agrave; /usr/share/doc/myprog/doc/README.
<li><b>*[!a-z]</b> : tous les fichiers du r&eacute;pertoire courant dont le nom ne finit pas par une
lettre minuscule. Notes
</ul>
<b>Attention !</b>: Quoique que cela soit vrai sous Linux, il est possible que cela ne fonctionne
pas sur les syst&egrave;mes d'op&eacute;ration de la famille Unix.<p>
<u><i><a name="cmple"><font color="#099990" size=+1>3.4.2- Le compl&egrave;tement (completion) dans les lignes de commande: </font></a></i></u><br>
Le compl&egrave;tement est une fonctionnalit&eacute; des plus pratiques et tous les shells modernes (dont bash)
l'incluent d&eacute;sormais. Son but est d'aider l'utilisateur &agrave; en faire le moins possible ! Le mieux
pour illustrer ce qu'est le compl&egrave;tement est un exemple.<p>
Supposons que vous ayez dans votre r&eacute;pertoire personnel un fichier
"fichier_au_nom_tr&egrave;s_long_impossible_&agrave;_taper", et que vous vouliez le consulter. Mais, vous avez
&eacute;galement dans ce m&ecirc;me r&eacute;pertoire un autre fichier appel&eacute; fichier_texte. Que faire? Vous vous
trouvez dans votre r&eacute;pertoire personnel et vous tapez alors la s&eacute;quence suivante:<br>
<b>$ less fi&lt;TAB&gt;</b><br>
(c'est-&agrave;-dire, tapez less fi suivi d'une pression sur la touche TAB). Le shell aura alors &eacute;tendu
la ligne de commande pour vous :<br>
<b>$ less fichier_</b><br>
et aura &eacute;galement marqu&eacute; la liste des choix possibles (dans sa configuration par d&eacute;faut, qui peut
&ecirc;tre personnalis&eacute;e). Tapez alors la s&eacute;quence de touches suivante :<br>
<b>less fichier_a&lt;TAB&gt;</b><br>
et le shell aura &eacute;tendu la ligne de commande pour obtenir le r&eacute;sultat que vous souhaitiez:<br>
<b>less fichier_au_nom_tr&egrave;s_long_impossible_&agrave;_taper</b><br>
Il ne vous reste plus alors qu'&agrave; taper sur la touche Entr&eacute;e pour valider et consulter le
fichier.<p>
Il existe bien d'autres m&eacute;thodes de completion, mais celle-l&agrave; est suffisante, alors &agrave; vous de
chercher si vous &ecirc;tes curieux.<p>
<u><i><a name="arriere"><font color="#099990" size=+1>3.4.3- Lancement et manipulation de processus en arri&egrave;re-plan: </font></a></i></u><br>
Vous aurez remarqu&eacute; que quand vous lancez une commande &agrave; partir d'un Terminal, vous devez
normalement attendre que la commande soit termin&eacute;e pour que le shell vous rende le contr&ocirc;le:
c'est que vous avez lanc&eacute; la commande au premier plan. Il y a des situations, cependant, o&ugrave;
cela n'est pas souhaitable.<p>
Supposons, par exemple, que vous ayez entrepris de copier r&eacute;cursivement un gros r&eacute;pertoire vers
un autre. Vous d&eacute;cidez &eacute;galement d'ignorer les erreurs, donc vous redirigez le canal d'erreur
vers /dev/null (d&eacute;j&agrave; vu) :<br>
<b>cp -R images/ /shared/ 2>/dev/null</b><br>
Une telle commande peut prendre plusieurs minutes avant d'&ecirc;tre ex&eacute;cut&eacute;e. Vous disposez alors
de deux solutions : la premi&egrave;re, brutale, est d'interrompre (de &laquo;tuer&raquo;) (on verra &ccedil;a apr&egrave;s) la
commande pour la relancer plus tard, quand vous aurez le temps. Pour ce faire, tapez Ctrl-c (la
touche Control plus la touche c): cela terminera le processus et vous retournerez alors &agrave;
l'invite. Mais attendez, ne faites pas &ccedil;a ! Continuez &agrave; lire.<p>
Supposons que vous vouliez ex&eacute;cuter une commande pendant que vous faites quelque chose d'autre.
La solution est de placer le processus en arri&egrave;re-plan. Pour ce faire, tapez d'abord Ctrl-z pour
suspendre le processus:
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>cp -R images/ /shared/ 2&gt;/dev/null</b><br>
# Tapez Ctrl-z<br>
[1]+ &#160; Stopped &#160; &#160;&#160; &#160;&#160; &#160; cp -R images/ /shared/ 2>/dev/null
</td>
</tr>
</table><p>
et vous revoil&agrave; devant l'invite. Le processus est alors suspendu, dans l'attente d'&ecirc;tre relanc&eacute;
(comme l'indique le mot-cl&eacute; Stopped, arr&ecirc;t&eacute;). Vous allez le relancer mais en le maintenant en
arri&egrave;re-plan. Tapez bg (pour BackGround, arri&egrave;re-plan), provoquera exactement l'effet escompt&eacute;:
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>bg</b><br>
[1]+ cp -R images/ /shared/ 2&gt;/dev/null &<br>
$
</td>
</tr>
</table><p>
Le processus aura alors repris son ex&eacute;cution en t&acirc;che de fond, ce qu'indique le signe "&"
(esperluette) &agrave; la fin de la ligne. Vous vous retrouvez alors en face de l'invite et pouvez
continuer &agrave; travailler. Un processus qui tourne en t&acirc;che de fond, ou arri&egrave;re-plan, est appel&eacute;
un job.<p>
Vous pouvez bien s&ucirc;r lancer directement des processus en t&acirc;che de fond, justement en ajoutant
une & &agrave; la fin de la commande. Ainsi, vous pouvez lancer la copie du r&eacute;pertoire en arri&egrave;re-plan
en &eacute;crivant:
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>cp -R images/ /shared/ 22&gt;/dev/null &</b>
</td>
</tr>
</table><p>
Si vous le souhaitez, vous pouvez &eacute;galement remettre ce processus au premier plan et attendre
qu'il se termine en tapant fg (pour ForeGround, premier plan). R&eacute;p&eacute;tez alors la s&eacute;quence Ctrl-z,
bg pour le remettre &agrave; l'arri&egrave;re-plan.<br>
Vous pouvez lancer plusieurs jobs de cette fa&ccedil;on : chacune de ces commandes recevra alors un
num&eacute;ro de job. La commande jobs du shell indique la liste de tous les jobs associ&eacute;s au shell
courant. Le job pr&eacute;c&eacute;d&eacute; d'un signe + d&eacute;signe le dernier processus mis en t&acirc;che de fond. Pour
remettre au premier plan un job en particulier, vous pourrez alors taper fg <n> o&ugrave; <n> d&eacute;signe
le num&eacute;ro de job, par exemple fg 5.<br>
Notez que vous pouvez &eacute;galement suspendre ou lancer de cette fa&ccedil;on des applications plein
&eacute;cran (si elles sont correctement programm&eacute;es), telles que less ou un &eacute;diteur de texte comme
VI, et les remettre au premier plan quand vous le voulez.<p>
</blockquote></blockquote><hr><p>
<a name="divers"><font color="#ff0000" size=+2><u>4- Divers: </u></font></a><br>
<blockquote>
<u><i><b><a name="edition"><font color="#3366ff" size=+1>4.1- L'&eacute;dition de texte: </font></a></b></i></u><b>(La majorit&eacute; de cette section est tir&eacute;e du "Guide dinstallation et de configuration de Linux"</b><br>
On trouve sous Linux des &eacute;diteurs de texte tr&egrave;s puissants, "vi" et "emacs". Ils para&icirc;trons toujours complexe &agrave; la
premi&egrave;re vue, mais avec un peu de pratique c'est autre chose. Dans cette partie on va parler de quelques
(je dis bien quelques) commandes de base pour l'utilisation de "vi" (prononcer vi-a&icirc;e), tout de m&ecirc;me pour
trouver de l'aide sur l'utilisation de "emacs" ou m&ecirc;me "vi", il existe plusieurs Howto, sois vous les avez avec
votre distribution sois vous les trouvez sur internet (vous pouvez me contacter si vous les trouvez pas).<p>
Pour &eacute;diter un fichier avec vi, il suffit de passer le nom de ce fichier en ligne de commande:
<br><b>vi fichier</b><br>
Il est possible de passer plusieurs fichiers dans la ligne de commande, et vi les &eacute;ditera les uns
apr&egrave;s les autres. Cependant, il faut savoir que vi ne permet de travailler que sur deux fichiers
&agrave; la fois, et quil nest pas facile de passer de lun &agrave; lautre. Par cons&eacute;quent, il est
conseill&eacute; de n&eacute;diter quun seul fichier &agrave; la fois.<p>
vi est un &eacute;diteur qui fonctionne avec plusieurs modes de fonctionnement : le mode d&eacute;dition,
dans lequel le texte peut &ecirc;tre modifi&eacute;, le mode de commande, dans lequel des commandes
particuli&egrave;res peuvent &ecirc;tre donn&eacute;es, et le mode de visualisation, dans lequel le fichier ne peut
&ecirc;tre que visualis&eacute;. Par d&eacute;faut, vi est en mode de visualisation, et il faut utiliser une commande
d&eacute;dition pour passer en mode d&eacute;dition. Quand on est en mode d&eacute;dition, on peut revenir au mode
de visualisation en appuyant sur la touche Echap (ou Esc, selon votre clavier). Cette touche a
aussi une signification dans le mode de commande : elle annule la saisie de la commande en cours.
Par cons&eacute;quent, lorsquon est perdu et que lon ne sait plus dans quel mode on se trouve (ce qui
arrive fatalement &agrave; un moment donn&eacute;), il suffit dappuyer sur cette touche. On sait alors quon
se trouve en mode de visualisation.<p>
Le d&eacute;placement du curseur en mode de visualisation se fait avec les touches du curseur.
Cependant, si votre clavier nest pas bien configur&eacute;, ces touches peuvent ne pas fonctionner.
Cest pour cette raison que vi fournit un jeu de touches alternatif:
<ul>
<li>la touche h permet de d&eacute;placer le curseur vers la gauche.</li>
<li>la touche l permet de d&eacute;placer le curseur vers la droite.</li>
<li>la touche j permet de d&eacute;placer le curseur vers le bas.</li>
<li>la touche k permet de d&eacute;placer le curseur vers le haut.</li>
</ul>
Le curseur est bien entendu d&eacute;plac&eacute; automatiquement lors de la saisie du texte en mode d&eacute;dition.
Le passage en mode d&eacute;dition peut se faire avec lune des commandes suivantes:
<ul>
<li>la touche i permet de passer en mode dinsertion (le texte saisi sins&egrave;re avant le caract&egrave;re
sur lequel le curseur est positionn&eacute;).</li>
<li>la touche a permet de passer en mode dajout de caract&egrave;res (le texte saisi sins&egrave;re apr&egrave;s le
caract&egrave;re sur lequel le curseur est positionn&eacute;).</li>
<li>la touche A permet de placer le curseur en fin de ligne et de passer en mode dajout de
caract&egrave;res.</li>
<li>la touche o permet de cr&eacute;er une nouvelle ligne apr&egrave;s la ligne o&ugrave; se trouve le curseur et de
passer en mode d&eacute;dition sur cette nouvelle ligne.</li>
<li>la touche O permet de cr&eacute;er une nouvelle ligne avant la ligne o&ugrave; se trouve le curseur et de
passer en mode d&eacute;dition sur cette nouvelle ligne.</li>
</ul>
La cr&eacute;ation dune nouvelle ligne peut donc &ecirc;tre faite avec les commandes o et O, mais il est
possible de couper une ligne en deux, ou de passer &agrave; la ligne simplement en tapant sur la touche
Entr&eacute;e en mode d&eacute;dition. Inversement, la commande J permet de supprimer un saut de ligne en fin
de ligne et de placer ainsi le texte de la ligne suivante &agrave; la suite du texte de la ligne
courante. La suppression dun caract&egrave;re se fait avec la touche Suppr (ou Del, selon le clavier)
ou la touche de retour arri&egrave;re (dite touche Backspace). Cependant, encore une fois, vi fournit un
jeu de touches alternatif permettant de travailler avec un clavier mal configur&eacute;:
<ul>
<li>la commande x permet deffacer le caract&egrave;re situ&eacute; sous le curseur.</li>
<li>la commande dd permet deffacer la ligne o&ugrave; se trouve le curseur.</li>
<li>la commande dw permet deffacer le mot o&ugrave; se trouve le curseur.</li>
</ul>
Le texte qui a &eacute;t&eacute; supprim&eacute; est plac&eacute; dans ce que lon appelle un buffer. Le contenu du buffer
peut &ecirc;tre ins&eacute;r&eacute; &agrave; nimporte quel endroit du fichier gr&acirc;ce &agrave; la commande p. Ainsi, il est
possible de faire un couper/coller en effa&ccedil;ant la ligne d&eacute;sir&eacute;e et en appuyant sur la touche p &agrave;
lemplacement destination.<br>
La commande u permet dannuler la derni&egrave;re op&eacute;ration effectu&eacute;e, et la commande U permet de la
r&eacute;-ex&eacute;cuter.<br>
La commande yy permet de copier la ligne courante dans le buffer. Cette commande est donc
utilis&eacute;e pour effectuer des copier/coller, en combinaison avec la commande p.<p>
Les commandes de vi peuvent &ecirc;tre r&eacute;p&eacute;t&eacute;es un certain nombre de fois, en tapant un nombre avant de
les taper. Ainsi, pour supprimer 3 lignes, il suffira de taper la commande suivante:<br>
<b>3dd</b><br>
Dans ce cas, ces trois lignes sont &eacute;galement plac&eacute;es dans le buffer. La m&ecirc;me technique peut &ecirc;tre
utilis&eacute;e pour copier/coller plusieurs lignes en une seule op&eacute;ration.<p>
Enfin, vi accepte un certain nombre de commandes g&eacute;n&eacute;rales lorsquil est en mode de commande. Ce
mode est activ&eacute; d&egrave;s que lon appuie sur la touche deux points (:) dans le mode de
visualisation. Les commandes g&eacute;n&eacute;rales les plus utiles sont d&eacute;crites ci-dessous:
<ul>
<li>la commande :q permet de quitter vi. Si le fichier en cours d&eacute;dition a &eacute;t&eacute; modifi&eacute;, vi
refusera de se terminer sans lenregistrer. Si lon veut malgr&eacute; tout sortir sans lenregistrer,
il faudra utiliser la commande ":q !".</li>
<li>la commande :w permet denregistrer le fichier courant. Pour enregistrer ce fichier et
quitter vi, la commande :wq peut &ecirc;tre utilis&eacute;e.</li>
<li>la commande :help sujet permet dobtenir de laide sur le sujet &laquo;sujet&raquo;.</li>
<li>la commande : !commande permet dex&eacute;cuter la commande du shell &laquo; commande &raquo;. Ceci peut &ecirc;tre
pratique pour effectuer une op&eacute;ration dans le shell sans avoir &agrave; quitter vi. Ceci dit, il sera
sans doute plus efficace dutiliser un autre terminal virtuel.</li>
</ul>
Comme vous lavez constat&eacute;, vi est r&eacute;ellement une horreur &agrave; utiliser. Malgr&eacute; tout, il permet de
faire tout ce dont on a besoin pour &eacute;diter un fichier. Il dispose m&ecirc;me de puissantes
fonctionnalit&eacute;s que m&ecirc;me les traitements de texte &eacute;volu&eacute;s ne sont pas capables de faire. Elles
ne seront cependant pas d&eacute;crites ici, car ceci d&eacute;passerait le cadre de ce document.<p>
<u><i><b><a name="utilcmd"><font color="#3366ff" size=+1>4.2- Quelques utilitaires en ligne de commande: </font></a></b></i></u><br>
Dans cette section, on va parler d'un petit nombre d'outils en ligne de commande.<p>
<ul>
<li><b>grep</b>: chercher une cha&icirc;ne de caract&egrave;re dans un fichier.<br>
On l'utilise de cette fa&ccedil;on:<br>
<b>grep chaine_de_caractere fichier</b><br>
Cette commande accepte plusieurs options d&eacute;crites dans les pages de manuels (man grep).<p>
<b>Remarque</b>: le texte cherch&eacute; peut &ecirc;tre plac&eacute; entre guillemets si n&eacute;cessaire, par exemple s'il
contient des caract&egrave;res comme "?" ou "*" (on a d&eacute;j&agrave; vu &ccedil;a, non?).</li>
<li><b>find</b>: permet de chercher des fichiers dans un r&eacute;peroire selon des crit&egrave;res donn&eacute;es.<br>
Sa syntaxe est la suivante: (j'ai essay&eacute; de la simplifier)<br>
<b>find r&eacute;pertoire -name nom_du_fichier -print</b><br>
o&ugrave; r&eacute;pertoire est le r&eacute;pertoire o&ugrave; la recherche va &ecirc;tre effectu&eacute;e. et nom est le nom du fichier &agrave; rechercher.
Ce nom peut contenir des motifs d'englobements (vu pr&eacute;c&eacute;demment), mais il faut utilis&eacute; des guillemets pour
cela.<br>
Cette commande accepte aussi plusieurs options de recherche &agrave; part "-name", et peut effectuer d'autres
action &agrave; part "-print".<br>
Pour plus d'informations &agrave; ce sujet "man find".</li>
<li><b>gzip</b>: compresser un fichier.<br>
On utilise cette commande de la mani&egrave;re suivante:<br>
<b>gzip fichier</b><br>
o&ugrave; fichier est le fichier &agrave; compresser, le nom du fichier compress&eacute; sera "fichier.gz".<p>
Pour d&eacute;comresser, utilisez la commande <b>gunzip</b>, elle s'emploie de cette fa&ccedil;on:<br>
<b>gunzip fichier.gz</b><p>
Pour plus d'informations les pages de manuels.</li>
<li><b>tar</b>: archiver des fichiers (regrouper tous les fichiers en un seul fichier structur&eacute; en bloc)...<br>
Voici sa syntaxe:<br>
<b>tar options archive [fichiers]</b><br>
o&ugrave; options sont les options qui indiquent l'op&eacute;ration &agrave; effectuer et la fa&ccedil;on de l'effectuer. Et archive est
le nom de l'archive qui doit &ecirc;tre cr&eacute;&eacute; ..., et fichier est la liste des fichiers &agrave; archiver.<p>
Voici ses options les plus utilis&eacute;e:
<ul>
<li>cvf: pour cr&eacute;er une archive.</li>
<li>tvf: pour lister le contenu d'une archive.</li>
<li>xvf: pour restaurer le contenu d'une archive.</li>
</ul>
Et pour conclure quelques petits exemples:
<p><table width="70%" border="1" cellspacing="0" cellpadding="0" bgcolor="#dddddd" align="center">
<tr><td>
$<b>tar cvf archive.tar *</b><br>
<div align=center>-----------------------------<br>
archiver le contenu du r&eacute;pertoire courant dans le fichier "archive.tar".
</div><br></td></tr>
<tr><td>
$<b>tar xvf archive.tar</b><br>
<div align=center>-----------------------------<br>
extraire le contenu de "archive.tar".
</div></td>
</tr>
</table><p>
Pour en savoir plus les pages de manuel.
</li></ul><p>
Il existe bien d'autres utilitaires (beaucoup plus nombreux que vous imaginez), que vous devez chercher par
vous m&ecirc;me dans les pages de manuel. Voici quelques commandes &agrave; chercher comme exercice:<br>
<b>crontab, at, bzip2, sort, convert, sed, zip, ...</b>. 
</blockquote><hr><p>
<a name="conc"><font color="#ff0000" size=+2><u>5- Conclusion: </u></font></a><br>
J'&eacute;sp&egrave;re que vous avez maintenant une base sur Linux (sinon vous pouvez me contacter). Vous avez sans doute
remarqu&eacute; que j'ai utilis&eacute; trop de copier/coller, c'est parce que je pense que ces parties copi&eacute;es
sont plus meilleur que ce que j'aurai pu &eacute;crire (et en plus pourquoi se fatiguer pour quelque chose que
les autres ont d&eacute;j&agrave; faite), aussi le temps (1 jour et demi) ne permet pas d'&eacute;crire un tel document.<br>
Enfin, une chose &agrave; ne pas oublier, la pratique et l'exp&eacute;rimentation sont tr&egrave;s important.<br>
Dans la prochaine partie, on parlera plus sur les processus, les variables d'environnement et aussi
beaucoup d'autres sujets.<p>
<hr><i>
<b>Greetz</b>: Meriyem, Storm, Slay-Tariq, Stoorm, Marcel, Darkshado, Cyanure, et les autres
amis, ainsi que tous les membres de l'Underground (surtout le marocain et le fran&ccedil;ais mais aussi
les autres), moi pour avoir &eacute;crire ce texte ;-), et toi qui lit ce tutorial... Enfin merci pour les
albums "South Of Heaven" de Slayer, "Damned In Black" Immortal, "Casket Garden" de Dismember et "Formulas Fatal To The Flech" de Morbid Angel,
qui m'ont soutenu durant l'&eacute;criture de ce document.<br>
Et un grand <b>F***k</b>: &agrave; tous les LaMeRs, &agrave; Kr$oft (Billou aussi), &agrave; Marok T&eacute;l&eacute;con
(pour ses facteurs) mais aussi les autres *** t&eacute;l&eacute;con (elles sont toutes les m&ecirc;mes), &agrave; mon voisin
Sharoon, et son ami Jorje Buch (je vois un petit sourire l&agrave;)...
</i>
</body>
</html>
