<!-- NAME: main.tpl -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
    <title>L i n u x [inetdoc]: (Guides) </title>
    <meta HTTP-EQUIV="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta name="Content-Language" content="fr">
    <meta name="description" content="inet doc linux">
    <meta name="author" content="philippe.latu@linux-france.org">
    <meta name="copyright" content="(c)2000 Philippe Latu">
    <meta name="publisher" content="philippe.latu@linux-france.org">
    <meta name="keywords" content="documentation, ethernet, formation, guide, ieee, ifconfig, inet, interface, ip, iproute2, iptables, isdn, IUT, IUP, latu, linux, net, OSI, ping, reseau, RNIS, route, routage, TCP, TCP/IP, UDP">
    <meta name="audience" content="All, Tous">
    <meta name="robots" content="INDEX,FOLLOW">
    <link rel="STYLESHEET" type="text/css" href="/prj/inetdoc/style/docstyle.css">
    <script language="javascript" type="text/javascript">
      <!-- for javascript enabled browser's only
        if (top.location != location) top.location.href = location.href;
	
        function popup(form) {
          optionIndex = form.banner.SelectedIndex;
          if (optionIndex == 0) return;
          location.href = form.banner.options[form.banner.selectedIndex].value;
          }
      // end script hiding -->
    </script>
  </head>
<BODY BGCOLOR="#FFFFFF" TEXT="#990000" LINK="#990000" VLINK="#990000" ALINK="#990000" leftMargin="0" topMargin="0" marginheight="0" marginwidth="0">
<TABLE width=100% border=0 cellspacing=2 cellpadding=0 align=center>
  <TR>
    <TD width=25% bgcolor=#990000 align=center valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
        <TR align=right> 
	  <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
      	</TR>
	<TR>
	  <TD bgcolor=#990000 align=center>
	    <a class="nodecor" href="/prj/inetdoc">
              <IMG src="/prj/inetdoc/images/upleft.png" border=0 width=158 height=96 hspace=10 alt="logo">
      	    </a>
	  <TD>
	</TR>
      </TABLE>
    </TD>
    <TD width=75% bgcolor=#FFFFFF align=left valign=top>
      <!-- banner menu start -->
      <form>
        <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
	  <!-- 1st row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor=#FF9966>
	      <TABLE width="100%" border="0" cellspacing="3" cellpadding="0" width="100%">
	        <TR>
		  <th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/">&nbsp;Accueil</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/articles/">&nbsp;Articles</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/courses/">&nbsp;Cours</a>
</th>
<th align="left" valign="top" bgcolor="white">
  <a class="reduced" href="/prj/inetdoc/i/net/guides/">&nbsp;Guides</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/formation/">&nbsp;Formation</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/download/">&nbsp;Téléchargement</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/source/">&nbsp;Source</a>
</th>

		</TR>
	      </TABLE>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#FFFFFF><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <!-- 2nd row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor=#FFCC66>
	      <FONT color=#990000 size=-1 face="Arial, 'Myriad Web', Syntax, sans-serif"><B>
	       <SELECT name="banner" onChange="popup(this.form)">
	         <OPTION value="/prj/inetdoc/i/net/articles/model/tcpip.html">
  Modélisation TCP/IP
</OPTION>
<OPTION value="/prj/inetdoc/i/net/../../download/Advanced-routing-Howto.pdf">
  Téléchargement Linux 2.4 Advanced Routing HOWTO VF
</OPTION>
<OPTION value="/prj/inetdoc/i/net/guides/">
  Autres guides
</OPTION>

	       </SELECT>
	      </B></FONT>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#FFFFFF><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <!-- 3rd row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor="#990000" align="left" valign="middle" width="100%" height="100%">
	      <div class="browse"><font size=1>&nbsp;&nbsp;Références : <a href="http://netfilter.samba.org/" class="browse"><font size=1>Netfilter Home</font></a>&nbsp;|&nbsp;
<a href="http://lartc.org/" class="browse"><font size=1>Linux Advanced Routing & Traffic Control Home</font></a>&nbsp;|&nbsp;
<a href="http://www.linux-france.org/prj/inetdoc/download/Advanced-routing-Howto.pdf" class="browse"><font size=1>Version Française en PDF</font></a>&nbsp;
</font></div>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	</TABLE>
      </form>
      <!-- banner menu end -->
    </TD>
  </TR>
  <TR>
    <TD width=25% bgcolor=#330066 align=left valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
        <TR align=right> 
	  <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	</TR>
	<TR>
	  <TD bgcolor=#330066 align=center>
	    &nbsp;<!-- no Toc section in guides/Advanced-routing-Howto/Advanced-routing-Howto.v0.9.html -->
      	    <br>
      	    <TABLE width=100% border=0 cellpadding=0 cellspacing=4>
              <TR>
	  	<TD bgcolor=#000000 align=center>
	    	  <TABLE width=100% border=0 cellpadding=2 cellspacing=1>
              	    <TR>
	              <TH bgcolor=#FFCC66 align="center" valign="top" class="toc-title">
		        <a class="toc-title" href="mailto:philippe.latu@linux-france.org">
	        	  Contact<img src="/prj/inetdoc/images/envelope.gif" border=0 width=50 height=35 align="middle" alt="mail">
		  	</a>
		      </TH>
              	    </TR>
              	    <TR>
	              <TD bgcolor=#FFCC99 align=center valign=top class="toc-item">
		        &nbsp;<a class="toc-item" href="/prj/inetdoc/log/">Carnet de bord</a>
		      </TD>
              	    </TR>
              	    <TR>
	              <TD bgcolor=#FFCC99 align=center valign=top class="toc-item">
		  	&nbsp;<a class="toc-item" href="/prj/inetdoc/legal/">Notice légale</a>
		      </TD>
              	    </TR>
            	  </TABLE>
	  	</TD>
              </TR>
      	    </TABLE>
          </TD>
        </TR>
      </TABLE>
    </TD>
    <TD width=75% bgcolor=#FFFFFF align=left valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=8 align=center>
        <TR>
	  <TD bgcolor=#FFFFFF align=left valign=top>
            <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st February 2002), see www.w3.org">
<meta name="GENERATOR" content="LinuxDoc-Tools 0.9.18">
<title>HOWTO du routage avancé et du contrôle de trafic sous Linux:
Gestionnaires de mise en file d'attente avancés &amp; et moins
communs</title>
<link href="Advanced-routing-Howto.v0.9-15.html" rel="next">
<link href="Advanced-routing-Howto.v0.9-13.html" rel="previous">
<link href="Advanced-routing-Howto.v0.9.html#toc14" rel="contents">
</head>
<body>
<a href="Advanced-routing-Howto.v0.9-15.html">Page suivante</a> <a
href="Advanced-routing-Howto.v0.9-13.html">Page précédente</a> <a
href="Advanced-routing-Howto.v0.9.html#toc14">Table des
matières</a> 

<hr>
<h2><a name="s14">14.</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14">Gestionnaires de mise en
file d'attente avancés &amp; et moins communs</a></h2>

<p>Si vous constatez que vous avez des besoins qui ne sont pas
gérés par les files d'attente citées précédemment, le noyau
contient quelques autres files d'attente plus spécialisées
mentionnées ici.</p>

<h2><a name="ss14.1">14.1</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.1">bfifo/pfifo</a></h2>

<p>Ces files d'attente sans classes sont plus simples que
pfifo_fast dans la mesure où elles n'ont pas de bandes internes,
tout le trafic étant vraiment équivalent. Elles ont cependant
l'important avantage de réaliser des statistiques. Donc, même si
vous n'avez pas besoin de mise en forme ou de donner de priorité,
vous pouvez employer ce gestionnaire pour déterminer l'arriéré
(backlog) de votre interface.</p>

<p>pfifo mesure en paquets et bfifo en octets.</p>

<h3>Paramètres &amp; usage</h3>

<dl>
<dt><b>limit</b></dt>

<dd>
<p>Spécifie la taille de la file d'attente. Mesuré en octets pour
bfifo, en paquets pour pfifo. Par défaut, correspond à des paquets
de taille égal au paramètre txqueuelen de l'interface (voir le
chapitre pfifo_fast) ou txqueuelen*mtu octets pour bfifo.</p>
</dd>
</dl>

<br>
<br>
 

<h2><a name="ss14.2">14.2</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.2">Clark-Shenker-Zhang
algorithm (CSZ)</a></h2>

<p>Ceci est si théorique que pas même Alexey (l'auteur principal de
CBQ) ne prétend le comprendre. De sa source&nbsp;:</p>

<p>"David D. Clark, Scott Shenker and Lixia Zhang Supporting
Real-Time Applications in an Integrated Services Packet Network:
Architecture and Mechanism.</p>

<p>Comme je le comprends, l'idée principale est de créer des flux
WFQ pour chaque service garanti et d'allouer le reste de la bande
passante au flux factice, appelé "flow-0". Le Flux-0 inclut le
trafic de service prédictif et le trafic "best-effort". Il est
traité par un ordonnanceur de priorité qui alloue la bande passante
de plus grande priorité aux services prédictifs, et le reste aux
paquets "best-effort".</p>

<p>Notez que dans CSZ, les flux ne sont PAS limités à leur bande
passante. On suppose que le flux a passé le contrôle d'admission au
bord du réseau QoS et qu'il n'a pas besoin de mises en forme
supplémentaires. N'importe quelles autres tentatives pour améliorer
le flux ou pour le mettre en forme grâce à un seau de jetons lors
d'étapes intermédiaires introduiront des retards non désirés et
augmentera l'instabilité.</p>

<p>A l'heure actuelle, CSZ est le seul ordonnanceur qui fournit un
véritable service garanti. Les autres implémentations (incluant
CBQ) n'assurent pas un délai garanti et rendent aléatoires
l'instabilité.</p>

<p>Ne semble pas actuellement un bon candidat à utiliser, à moins
que vous n'ayez lu et compris l'article mentionné.</p>

<h2><a name="ss14.3">14.3</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.3">DSMARK</a></h2>

<p>Esteve Camps Chust &lt;marvin@grn.es&gt;<br>
Ce texte est un extrait de ma thèse sur le "support QoS dans
Linux", septembre 2000.<br>
</p>

<p>Documents sources&nbsp;:<br>
</p>

<ul>
<li><a href=
"http://ica1www.epfl.ch/~almesber">Draft-almesberger-wajhak-diffserv-linux-01.txt</a>.</li>

<li>Exemples de la distribution iproute2.</li>

<li><a href=
"http://www.qosforum.com/white-papers/qosprot_v3.pdf">White
Paper-QoS protocols and architectures</a> et <a href=
"http://www.qosforum.com/docs/faq">Foires Aux Questions IP QoS</a>,
les deux par <em>Quality of Service Forum</em>.</li>
</ul>

<br>
<br>
 

<p>Ce chapitre a été écrit par Esteve Camps
&lt;esteve@hades.udg.es&gt;.</p>

<h3>Introduction</h3>

<p>Avant tout, il serait préférable de lire les RFC écrits sur ce
sujet (RFC2474, RFC2475, RFC2597 et RFC2598) sur le <a href=
"http://www.ietf.org/html.carters/diffserv-charter.html">site web
du groupe de travail DiffServ IETF</a> et sur le <a href=
"http://ica1www.epfl.ch/~almesber">site web de Werner
Almesberger</a> (Il a écrit le code permettant le support des
Services Différenciés sous Linux).</p>

<h3>A quoi Dsmark est-il relié&nbsp;?</h3>

<p>Dsmark est un gestionnaire de mise en file d'attente qui offre
les fonctionnalités dont ont besoin les services différenciés
(Differentiated Services) (également appelé DiffServ ou tout
simplement DS). DiffServ est l'une des deux architectures actuelles
de la Qualité de Service (QoS : Quality of Services) (l'autre est
appelée "Integrated Services" (services intégrés)) et il se base
sur la valeur du champ DS contenue dans l'entête IP du paquet.</p>

<p>Une des premières solutions dans IP pour offrir des niveaux de
qualité de service était le champ Type de Service (octet TOS) dans
l'entête IP. En modifiant la valeur de ce champ, nous pouvions
choisir un niveau élevé/faible du débit, du délai ou de la
fiabilité. Cependant, cela ne fournissait pas une flexibilité
suffisante pour les besoins de nouveaux services (comme les
applications temps réel, les applications interactives et autres).
Après ceci, de nouvelles architectures sont apparues. L'une d'elle
a été DiffServ qui a gardé les bits TOS et les a renommés champ
DS.</p>

<h3>Guide des services différenciés</h3>

<p>Les services différenciés sont orientés groupes. Cela signifie
que nous ne savons rien des flux (ce sera le but des "integrated
Services" (services intégrés)). Nous connaissons par contre les
agrégations de flux et nous appliquerons des comportements
différents suivant l'agrégation à laquelle appartient le
paquet.</p>

<p>Quand un paquet arrive à un noeud de bord (noeud d'entrée du
domaine DiffServ) et entre dans un domaine DiffServ, nous devrons
avoir une politique, une mise en forme et/ou un marquage de ces
paquets (le marquage fait référence à la mise en place d'une valeur
dans le champ DS. Cela ressemble aux vaches :-) ). Ce sera cette
marque/valeur que les noeuds internes de votre domaine DiffServ
regarderons pour déterminer quel comportement ou niveau de qualité
de service appliquer.</p>

<p>Comme vous pouvez le déduire, les Services Différenciés
impliquent un domaine sur lequel toutes les règles DS devront être
appliquées. Vous pouvez raisonner de la façon suivante&nbsp;: "Je
classifierai tous les paquets entrant dans mon domaine. Une fois
qu'ils seront entrés dans mon domaine, ils seront soumis aux règles
que ma classification impose et chaque noeud traversé appliquera
son niveau de qualité de service".</p>

<p>En fait, vous pouvez appliquer vos propres politiques dans vos
domaines locaux, mais des <em>autorisations au niveau service</em>
devront être considérées lors de la connexion à d'autres domaines
DS.</p>

<p>En ce moment, vous vous posez peut-être beaucoup de questions.
DiffServ est plus vaste que ce que j'ai expliqué. En fait, vous
pouvez comprendre que je ne peux pas résumer plus de trois RFC en
50 lignes :-).</p>

<h3>Travailler avec Dsmark</h3>

<p>Comme le spécifie la bibliographie concernant DiffServ, nous
différencions les noeuds frontières et les noeuds intérieurs. Ce
sont deux éléments importants dans le chemin qu'emprunte le trafic.
Les deux réalisent une classification quand un paquet arrive. Le
résultat peut être utilisé à différents endroits lors du processus
DS avant que le paquet ne soit libéré vers le réseau. Cela est
possible car le nouveau code diffserv fourni une structure appelée
sk_buff, incluant un nouveau champ appelé skb-&gt;tcindex. Ce champ
mémorisera le résultat de la classification initiale et pourra être
utilisé à plusieurs reprises dans le traitement DS.</p>

<p>La valeur skb-&gt;tc_index sera initialement configurée par le
gestionnaire de mise en file d'attente DSMARK. Cette valeur sera
extraite du champ DS de l'entête IP de tous les paquets reçus. En
outre, le classificateur cls_tcindex lira tout ou une partie de la
valeur skb-&gt;tcindex et l'utilisera pour sélectionner les
classes.</p>

<p>Mais, avant tout, regardons la commande qdisc DSMARK et ses
paramètres&nbsp;:</p>

<blockquote>
<pre>
<code>... dsmark indices INDICES [ default_index DEFAULT_INDEX ] [ set_tc_index ]
</code>
</pre>
</blockquote>

Que signifient ces paramètres&nbsp;? 

<ul>
<li><b>indices</b>: taille de la table des couples (masque,valeur).
La valeur maximum est 2^n, où n&gt;=0.</li>

<li><b>Default_index</b>: l'index d'entrée par défaut de la table
si aucune correspondance n'est trouvée.</li>

<li><b>Set_tc_index</b>: indique au gestionnaire dsmark de
récupérer le champs DS et de l'enregistrer dans
skb-&gt;tc_index.</li>
</ul>

Regardons DSMARK procéder.<br>
<br>
 

<h3>Comment SCH_DSMARK travaille.</h3>

<p>Ce gestionnaire de mise en file d'attente réalisera les étapes
suivantes&nbsp;:</p>

<ul>
<li>Si vous avez déclaré l'option set_tc_index dans la commande
qdisc, le champ DS est récupéré et mémorisé dans la variable
skb-&gt;tc_index.</li>

<li>Le classificateur est invoqué. Celui-ci sera exécuté et
retournera un identificateur de classe (class ID) qui sera
enregistré dans la variable skb-&gt;tc_index. Si aucun filtre
correspondant n'est trouvé, nous considérons l'option default_index
comme étant l'identificateur de classe à enregistrer. Si, ni
set_tc_index, ni default_index n'ont été déclarés, alors les
résultats peuvent ne pas être prédits.</li>

<li>Après avoir été envoyé dans le gestionnaire de file d'attente
interne, où le résultat du filtre peut être réutilisé,
l'identificateur de classe retourné par le gestionnaire est stocké
dans la variable skb-&gt;tc_index. Cette valeur sera utilisée plus
tard pour indexer la table masque-valeur. Le résultat de
l'opération suivante sera assigné au paquet&nbsp;: 

<blockquote>
<pre>
<code>Nouveau_champ_DS = ( Ancien_champ_DS &amp; masque ) | valeur
</code>
</pre>
</blockquote>
</li>

<li>La nouvelle valeur résultera donc d'un ET logique entre les
valeurs du champ_DS et du masque, suivi d'un OU logique avec le
paramètre valeur. Regarder la figure suivante pour comprendre tout
ce processus&nbsp;:</li>
</ul>

<blockquote>
<pre>
<code>                         skb-&gt;ihp-&gt;tos
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;
     |                                                       |     ^
     | -- Si vous déclarez set_tc_index, nous configurons    |     |  &lt;-----Peut changer
     |    la valeur DS dans la variable skb-&gt;tc_index        |     |O       le champ DS
     |                                                      A|     |R
   +-|-+      +------+    +---+-+  File d'attente-+     +---N|-----|----+
   | | |      |filtre|---&gt;|   | |--&gt;  . . .  --&gt;| |     |   D|     |    |
   | | |-----&gt;|  tc  |---&gt;|   | |   interne     | |----&gt;|    v     |    |
   | | |      |index |---&gt;| | | +---------------+ |   ----&gt;(masque,valeur)|
--&gt;| O |      +------+    +-|-+--------------^----+  /  |  (.  ,  .)    |
   | | |          ^         |                |       |  |  (.  ,  .)    |
   | | +----------|---------|----------------|-------|--+  (.  ,  .)    |
   | | sch_dsmark |         |                |       |                  |
   +-|------------|---------|----------------|-------|------------------+
     |            |         | &lt;- tc_index -&gt; |       |
     |            |(lecture)|   peut changer |       |  &lt;--------------Index de la table
     |            |         |                |       |                    des couples 
     v            |         v                v       |                    (masque,valeur)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&gt;
                         skb-&gt;tc_index
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Comment faire le marquage&nbsp;? Il suffit de modifier le masque
et la valeur associé à la classe que vous voulez marquer. Regarder
la ligne de code suivante&nbsp;:</p>

<blockquote><code>tc class change dev eth0 classid 1:1 dsmark mask
0x3 value 0xb8</code></blockquote>

Cela modifie le couple (masque,valeur) dans la table de hachage, et
re-marque les paquets appartenant à la classe 1:1. Vous devez
"changer" ces valeurs en raison des valeurs par défaut que le
couple (masque, valeur) obtient initialement (voir le tableau
ci-dessous).<br>
<br>
 

<p>Nous allons maintenant expliquer comment le filtre TC_INDEX
travaille, et comment il s'intègre dans tout cela. En outre, le
filtre TC_INDEX peut être utiliser dans des configurations autres
que celles incluant les services DS.</p>

<h3>Le filtre TC_INDEX</h3>

<p>Voici la commande de base pour déclarer un filtre
TC_INDEX&nbsp;:</p>

<blockquote>
<pre>
<code>... tcindex [ hash SIZE ] [ mask MASK ] [ shift SHIFT ]
            [ pass_on | fall_through ]
            [ classid CLASSID ] [ police POLICE_SPEC ]
</code>
</pre>
</blockquote>

Ensuite, nous montrons l'exemple utilisé pour expliquer le mode
opératoire de TC_INDEX. Soyez attentif aux mots en gras&nbsp;:<br>
<br>
tc qdisc add dev eth0 handle 1:0 root dsmark indices 64
<b>set_tc_index</b><br>
tc filter add dev eth0 parent 1:0 protocol ip prio 1 tcindex
<b>mask 0xfc shift 2</b><br>
tc qdisc add dev eth0 parent 1:0 handle 2:0 cbq bandwidth 10Mbit
cell 8 avpkt 1000 mpu 64<br>
# Classe du trafic EF<br>
tc class add dev eth0 parent 2:0 classid 2:1 cbq bandwidth 10Mbit
rate 1500Kbit avpkt 1000 prio 1 bounded isolated allot 1514 weight
1 maxburst 10<br>
# Gestionnaine de file d'attente fifo pour le trafic EF<br>
tc qdisc add dev eth0 parent 2:1 pfifo limit 5<br>
tc filter add dev eth0 parent 2:0 protocol ip prio 1 <b>handle
0x2e</b> tcindex <b>classid 2:1 pass_on</b><br>
<br>
<br>
(Ce code n'est pas complet. Ce n'est qu'un extrait de l'exemple
EFCBQ inclus dans la distribution iproute2).<br>
<br>
 

<p>Avant tout, supposons que nous recevons un paquet marqué comme
EF. Si vous lisez le RFC2598, vous verrez que DSCP recommande une
valeur de 101110 pour le trafic EF. Cela signifie que le champ DS
sera égal à 10111000 (rappelez- vous que les bits les moins
significatifs de l'octet TOS ne sont pas utilisés dans DS) ou 0xb8
en notation hexadécimale.</p>

<blockquote>
<pre>
<code>              FILTRE
              TC INDEX
   +---+      +-------+    +---+-+    +------+                +-+    +-------+
   |   |      |       |    |   | |    |FILTRE|  +-+    +-+    | |    |       |
   |   |-----&gt;| MASK  | -&gt; |   | | -&gt; |HANDLE|-&gt;| |    | | -&gt; | | -&gt; |       |
   |   |  .   | =0xfc |    |   | |    |0x2E  |  | +----+ |    | |    |       |
   |   |  .   |       |    |   | |    +------+  +--------+    | |    |       |
   |   |  .   |       |    |   | |                            | |    |       |
--&gt;|   |  .   | SHIFT |    |   | |                            | |    |       |--&gt;
   |   |  .   | =2    |    |   | +----------------------------+ |    |       |
   |   |      |       |    |   |       CBQ 2:0                  |    |       |
   |   |      +-------+    +---+--------------------------------+    |       |
   |   |                                                             |       |
   |   +-------------------------------------------------------------+       |
   |                          DSMARK 1:0                                     |
   +-------------------------------------------------------------------------+
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Le paquet arrive alors avec la valeur du champ DS configurée à
0xb8. Comme je l'ai expliqué auparavant, le gestionnaire de mise en
file d'attente dsmark, identifié par 1:0 dans cet exemple, récupère
le champ DS et l'enregistre dans la variable skb-&gt;tc_index.
L'étape suivante consistera à associer un filtre à ce gestionnaire
de mise en file d'attente (la seconde ligne dans cet exemple). Les
opérations suivantes seront réalisées&nbsp;:</p>

<blockquote>
<pre>
<code>Valeur1 = skb-&gt;tc_index &amp; MASK
Clé = Valeur1 &gt;&gt; SHIFT
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Dans cet exemple, MASK=0xFC et SHIFT=2.</p>

<blockquote>
<pre>
<code>Valeur1 = 10111000 &amp; 11111100 = 10111000
Clé = 10111000 &gt;&gt; 2 = 00101110 -&gt; 0x2E en hexadécimal
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>La valeur retournée correspondra à un identificateur de filtre
du gestionnaire de file d'attente interne (dans l'exemple,
identifier par 2:0). Si un filtre avec cet identificateur (id)
existe, les conditions de contrôle et de performance seront
vérifiées (au cas où le filtre inclurait ceci) et l'identificateur
de classe sera retourné (dans notre exemple, classid 2:1) et stocké
dans la variable skb-&gt;tc_index.</p>

<p>Si aucun filtre avec cet identificateur n'est trouvé, le
résultat dépendra de la déclaration de l'option fall_through. Si
tel est le cas, la valeur Clé est retournée comme identificateur de
classe. Si cela n'est pas le cas, une erreur est retournée et le
traitement continue avec les filtres restant. Faites attention si
vous utilisez l'option fall_through ; ceci ne peut être fait que si
une relation existe entre les valeurs de la variable
skb-&gt;tc_index et les identificateurs de classe.</p>

<p>Les derniers paramètres à commenter sont hash et pass_on. Le
premier est relié à la taille de la table de hachage. Pass_on sera
utilisé pour indiquer d'essayer le filtre suivant dans le cas où
aucun identificateur de classe égal au résultat du filtre ne serait
trouvé. L'action par défaut est fall_through (regarder la table
suivante).</p>

<p>Finalement, regardons quelles sont les valeurs possibles pour la
configuration de tous ces paramètres TCINDEX&nbsp;:</p>

<blockquote>
<pre>
<code>Nom TC                  Valeur          Défaut
-----------------------------------------------------------------
Hash                    1...0x10000     Dépendant de l'implémentation
Mask                    0...0xffff      0xffff
Shift                   0...15          0
Fall through / Pass_on  Flag            Fall_through
Classid                 Major:minor     Rien
Police                  .....           Rien
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Ce type de filtre est très puissant. Il est nécessaire
d'explorer toutes les possibilités. En outre, ce filtre n'est pas
seulement utilisé dans les configurations DiffServ. Vous pouvez
l'utiliser comme n'importe quel autre filtre.</p>

<p>Je vous recommande de regarder les exemples DiffServ inclus dans
la distribution iproute2. Je vous promets que j'essaierai de
compléter ce texte dès que possible. Tout ce que j'ai expliqué est
le résultat de nombreux tests. Merci de me dire si je me suis
trompé quelque part.</p>

<h2><a name="ss14.4">14.4</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.4">Gestionnaire de mise en
file d'attente d'entrée (Ingress qdisc)</a></h2>

<p>Tous les gestionnaires de mise en file d'attente dont nous avons
discuté jusqu'ici sont des gestionnaires de sortie. Chaque
interface peut également avoir un gestionnaire de mise en file
d'attente d'entrée qui n'est pas utilisé pour envoyer les paquets à
l'extérieur du périphérique réseau. Au lieu de cela, il vous
autorise à appliquer des filtres tc aux paquets entrants par
l'interface, indépendamment de s'ils ont une destination locale ou
s'ils sont destinés à être transmis.</p>

<p>Etant donné que les filtres tc contiennent une implémentation
complète du Filter à Seau de Jetons, et qu'ils sont également
capables de s'appuyer sur l'estimation du flux fourni par le noyau,
il y a beaucoup de fonctionnalités disponibles. Ceci vous permet de
réglementer le trafic entrant de façon efficace, avant même qu'il
n'entre dans la pile IP.</p>

<h3>Paramètres &amp; usage</h3>

<p>Le gestionnaire de mise en file d'attente d'entrée ne nécessite
pas de paramètres. Il diffère des autres gestionnaires dans le fait
qu'il n'occupe pas la racine du périphérique. Attaché le comme
ceci&nbsp;:</p>

<pre>
# tc qdisc add dev eth0 ingress
</pre>

Ceci vous autorise à avoir d'autres gestionnaires de sortie sur
votre périphérique en plus du gestionnaire d'entrée.<br>
<br>
 

<p>Pour un exemple inventé sur la façon dont le gestionnaire
d'entrée peut être utilisé, voir le chapitre Recettes de
cuisine.</p>

<h2><a name="ss14.5">14.5</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.5">Random Early Detection
(RED)</a></h2>

<p>Ce chapitre est conçu comme une introduction au routage de
dorsales (backbones). Ces liaisons impliquent souvent des bandes
passantes supérieures à 100 mégabits/s, ce qui nécessite une
approche différente de celle de votre modem ADSL à la maison.</p>

<p>Le comportement normal des files d'attente de routeurs est
appelé "tail-drop" (NdT&nbsp;: élimine le reste). Le "tail-drop"
consiste à mettre en file d'attente un certain volume de trafic et
à éliminer tout ce qui déborde. Ce n'est pas du tout équitable et
cela conduit à des retransmissions de synchronisation. Quand une
retransmission de synchronisation a lieu, la brusque rafale de
rejet d'un routeur qui a atteint sa limite entraînera une rafale de
retransmissions retardée qui inondera à nouveau le routeur
congestionné.</p>

<p>Dans le but d'en finir avec les congestions occasionnelles des
liens, les routeurs de dorsales intègrent souvent des files
d'attente de grande taille. Malheureusement, bien que ces files
d'attente offrent un bon débit, elles peuvent augmenter
sensiblement les temps de latence et entraîner un comportement très
saccadé des connexions TCP pendant la congestion.</p>

<p>Ces problèmes avec le "tail-drop" deviennent de plus en plus
préoccupants avec l'augmentation de l'utilisation d'applications
hostiles au réseau. Le noyau Linux nous offre la technique RED,
abréviation de Random Early Detect ou détection précoce
directe.</p>

<p>RED n'est pas la solution miracle à tous ces problèmes. Les
applications qui n'intègrent pas correctement la technique de
"l'exponential backoff" obtiennent toujours une part trop grande de
bande passante. Cependant, avec la technique RED elles ne
provoquent pas trop de dégâts sur le débit et les temps de latence
des autres connexions.</p>

<p>RED élimine statistiquement des paquets du flux avant qu'il
n'atteigne sa limite "dure" (hard). Sur une dorsale congestionnée,
cela entraîne un ralentissement en douceur de la liaison et évite
les retransmissions de synchronisation. La technique RED aide aussi
TCP à trouver une vitesse "équitable" plus rapidement&nbsp;: en
permettant d'éliminer des paquets plus tôt, il conserve une file
d'attente plus courte et des temps de latence mieux contrôlés. La
probabilité qu'un paquet soit éliminé d'une connexion particulière
est proportionnelle à la bande passante utilisée par cette
connexion plutôt qu'au nombre de paquets qu'elle envoie.</p>

<p>La technique RED est une bonne gestion de file d'attente pour
les dorsales, où vous ne pouvez pas vous permettre le coût d'une
mémorisation d'état par session qui est nécessaire pour une mise en
file d'attente vraiment équitable.</p>

<p>Pour utiliser RED, vous devez régler trois paramètres&nbsp;:
Min, Max et burst. Min est la taille minimum de la file d'attente
en octets avant que les rejets n'aient lieu, Max est le maximum
"doux" (soft) en-dessous duquel l'algorithme s'efforcera de rester,
et burst est le nombre maximum de paquets envoyés "en rafale".</p>

<p>Vous devriez configurer Min en calculant le plus grand temps de
latence acceptable pour la mise en file d'attente, multiplié par
votre bande passante. Par exemple, sur mon lien ISDN à 64 Kbits/s,
je voudrais avoir un temps de latence de base de mise en file
d'attente de 200 ms. Je configure donc Min à 1600 octets (= 0,2 x
64000 / 8). Imposer une valeur Min trop petite va dégrader le débit
et une valeur Min trop grande va dégrader le temps de latence. Sur
une liaison lente, choisir un coefficient Min petit ne peut pas
remplacer une réduction du MTU pour améliorer les temps de
réponse.</p>

<p>Vous devriez configurer Max à au moins deux fois Min pour éviter
les synchronisations. Sur des liens lents avec de petites valeurs
de Min, il peut être prudent d'avoir Max quatre fois plus grand que
Min ou plus.</p>

<p>Burst contrôle la réponse de l'algorithme RED aux rafales. Burst
doit être choisi plus grand que min/avpkt (paquet moyen).
Expérimentalement, j'ai trouvé que (min+min+max)/(3*avpkt) marche
bien.</p>

<p>De plus, vous devez configurer limit et avpkt. Limit est une
valeur de sécurité&nbsp;: s'il y a plus de Limit octets dans la
file, RED reprend la technique "tail-drop". Je choisis une valeur
typique égale à 8 fois Max. Avpkt devrait être fixé à la taille
moyenne d'un paquet. 1000 fonctionne correctement sur des liaisons
Internet haut débit ayant un MTU de 1500 octets.</p>

<p>Lire <a href=
"http://www.aciri.org/floyd/papers/red/red.html">the paper on RED
queueing</a> par Sally Floyd et Van Jacobson pour les informations
techniques.</p>

<h2><a name="ss14.6">14.6</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.6">Generic Random Early
Detection</a></h2>

<p>Il n'y a pas grand chose de connu sur GRED. Il ressemble à GRED
avec plusieurs files d'attente internes, celles-ci étant choisies
en se basant sur le champ tcindex de Diffserv. Selon une
diapositive trouvée <a href=
"http://www.davin.ottawa.on.ca/ols/img22.htm">ici</a>, il possède
les capacités 'Distributed Weighted RED' de Cisco, ainsi que les
capacités RIO de Clark.</p>

<p>Chaque file d'attente virtuelle peut avoir ses propres "Drop
Parameters".</p>

<p>FIXME: Demandez à Jamal or Werner de nous en dire plus</p>

<h2><a name="ss14.7">14.7</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.7">émulation
VC/ATM</a></h2>

<p>Ceci est l'effort principal de Werner Almesberger pour vous
autoriser à construire des circuits virtuels au-dessus des sockets
TCP/IP. Le circuit virtuel est un concept venant de la théorie des
réseaux ATM.</p>

<p>Pour plus d'informations, voir la <a href=
"http://linux-atm.sourceforge.net/">page ATM sur Linux</a>.</p>

<h2><a name="ss14.8">14.8</a> <a href=
"Advanced-routing-Howto.v0.9.html#toc14.8">Weighted Round Robin
(WRR)</a></h2>

<p>Ce gestionnaire de mise en file d'attente n'est pas inclus dans
les noyaux standard, mais peut être téléchargée à partir de <a
href=
"http://wipl-wrr.dkik.dk/wrr/">http://wipl-wrr.dkik.dk/wrr/</a>. Ce
gestionnaire de mise en file d'attente n'a été testé qu'avec les
noyaux 2.2, mais marchera probablement également avec les noyaux
2.4/2.5.</p>

<p>La file d'attente WRR partage la bande passante entre ses
classes en utilisant la technique du tourniquet pondéré. Ceci est
similaire à la file d'attente CBQ qui contient des classes sur
lesquelles l'on peut associer arbitrairement des files d'attente.
Toutes les classes qui ont suffisamment de demandes obtiendront la
bande passante proportionnellement au poids associé des classes.
Les poidss peuvent être configurés manuellement en utilisant le
programme <code>tc</code>. Ils peuvent également être configurés
pour décroître automatiquement pour les classes transférant moins
de données.</p>

<p>La file d'attente a un classificateur intégré qui assigne les
paquets venant ou allant vers différentes machines à différentes
classes. On peut utiliser soit l'adresse MAC soit l'adresse IP de
l'adresse source ou de destination. L'adresse MAC ne peut cependant
être utilisée que quand la boite Linux est un pont ethernet. Les
classes sont automatiquement assignées aux machines en fonction des
paquets vus.</p>

<p>Ce gestionnaire de mise en file d'attente peut être très utile
au site comme les résidences étudiantes où des individus sans liens
particuliers partagent une connexion Internet. Un ensemble de
scripts pour configurer un tel cas de figure pour ce genre de site
est proposé dans la distribution WRR.</p>

<hr>
<a href="Advanced-routing-Howto.v0.9-15.html">Page suivante</a> <a
href="Advanced-routing-Howto.v0.9-13.html">Page précédente</a> <a
href="Advanced-routing-Howto.v0.9.html#toc14">Table des
matières</a>
</body>
</html>


	  </TD>
	</TR>
      </TABLE>
    </TD>
  </TR>
  <TR>
    <TD colspan=2 width=100% bgcolor=#990000 align=left>
      <TABLE width=100% border=0 cellpadding=0 cellspacing=4>
        <TR>
	  <TD bgcolor=#990000 align=right>
	    <div class="filemodtime">
	      <i>Dernière modification le : 4 March 2002 12:04</i>
	    </div>
      	    <a style="text-decoration:none" href="http://www.php.net">
              <img src="/prj/inetdoc/images/php-small-trans-dark.gif" border=0 width=88 height=31 alt="php logo">
      	    </a>
      	    &nbsp;&nbsp;
      	    <a style="text-decoration:none" href="http://www.debian.org">
              <img src="/prj/inetdoc/images/openlogo-25.jpg" border=0 width=25 height=30 alt="debian logo">
      	    </a>
      	    &nbsp;&nbsp;
	    <!-- stat_code_start
	    <a style="text-decoration:none" href="http://www.estat.com/getstats?serial=21701747824">
	      <img src="http://perso.estat.com/cgi-bin/perso/21701747824?page=marque_perso" border=0>
	    </a>
	     stat_code_end -->
	    <!-- eStat -->
	    <SCRIPT LANGUAGE="JavaScript">
	      <!--
	      var _UJS=0;
	      //-->
	    </SCRIPT>
	    <SCRIPT LANGUAGE="JavaScript" SRC="http://perso.estat.com/js/m.js">
	    </SCRIPT>
	    <SCRIPT LANGUAGE="JavaScript">
	      <!--
	      if(_UJS) _estat('21701747824','Page_D_Accueil','Accueil');
	      //-->
	    </SCRIPT>
	    <!-- /eStat -->
	  </TD>
	</TR>
      </TABLE>
    </TD>
  </TR>
</TABLE>
</body>
</html>
<!-- END: main.tpl -->
