<!-- NAME: main.tpl -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
    <title>L i n u x [inetdoc]: (Guides) </title>
    <meta HTTP-EQUIV="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta name="Content-Language" content="fr">
    <meta name="description" content="inet doc linux">
    <meta name="author" content="philippe.latu@linux-france.org">
    <meta name="copyright" content="(c)2000 Philippe Latu">
    <meta name="publisher" content="philippe.latu@linux-france.org">
    <meta name="keywords" content="documentation, ethernet, formation, guide, ieee, ifconfig, inet, interface, ip, iproute2, iptables, isdn, IUT, IUP, latu, linux, net, OSI, ping, reseau, RNIS, route, routage, TCP, TCP/IP, UDP">
    <meta name="audience" content="All, Tous">
    <meta name="robots" content="INDEX,FOLLOW">
    <link rel="STYLESHEET" type="text/css" href="/prj/inetdoc/style/docstyle.css">
    <script language="javascript" type="text/javascript">
      <!-- for javascript enabled browser's only
        if (top.location != location) top.location.href = location.href;
	
        function popup(form) {
          optionIndex = form.banner.SelectedIndex;
          if (optionIndex == 0) return;
          location.href = form.banner.options[form.banner.selectedIndex].value;
          }
      // end script hiding -->
    </script>
  </head>
<BODY BGCOLOR="#FFFFFF" TEXT="#990000" LINK="#990000" VLINK="#990000" ALINK="#990000" leftMargin="0" topMargin="0" marginheight="0" marginwidth="0">
<TABLE width=100% border=0 cellspacing=2 cellpadding=0 align=center>
  <TR>
    <TD width=25% bgcolor=#990000 align=center valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
        <TR align=right> 
	  <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
      	</TR>
	<TR>
	  <TD bgcolor=#990000 align=center>
	    <a class="nodecor" href="/prj/inetdoc">
              <IMG src="/prj/inetdoc/images/upleft.png" border=0 width=158 height=96 hspace=10 alt="logo">
      	    </a>
	  <TD>
	</TR>
      </TABLE>
    </TD>
    <TD width=75% bgcolor=#FFFFFF align=left valign=top>
      <!-- banner menu start -->
      <form>
        <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
	  <!-- 1st row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor=#FF9966>
	      <TABLE width="100%" border="0" cellspacing="3" cellpadding="0" width="100%">
	        <TR>
		  <th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/">&nbsp;Accueil</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/articles/">&nbsp;Articles</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/courses/">&nbsp;Cours</a>
</th>
<th align="left" valign="top" bgcolor="white">
  <a class="reduced" href="/prj/inetdoc/i/net/guides/">&nbsp;Guides</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/formation/">&nbsp;Formation</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/download/">&nbsp;Téléchargement</a>
</th>
<th align="left" valign="top" bgcolor="#FFCC99">
  <a class="reduced" href="/prj/inetdoc/i/net/source/">&nbsp;Source</a>
</th>

		</TR>
	      </TABLE>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#FFFFFF><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <!-- 2nd row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor=#FFCC66>
	      <FONT color=#990000 size=-1 face="Arial, 'Myriad Web', Syntax, sans-serif"><B>
	       <SELECT name="banner" onChange="popup(this.form)">
	         <OPTION value="/prj/inetdoc/i/net/../../download/packet-filtering-HOWTO.pdf">
  Téléchargement Linux 2.4 Packet Filtering HOWTO VF
</OPTION>
<OPTION value="/prj/inetdoc/i/net/guides/">
  Autres guides
</OPTION>

	       </SELECT>
	      </B></FONT>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#FFFFFF><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <!-- 3rd row -->
	  <TR align=right> 
	    <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR>
	    <TD bgcolor="#990000" align="left" valign="middle" width="100%" height="100%">
	      <div class="browse"><font size=1>&nbsp;&nbsp;Références : <a href="http://netfilter.kernelnotes.org/" class="browse"><font size=1>Netfilter Home</font></a>&nbsp;
</font></div>
	    </TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#990000><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=4 alt=""></TD>
	  </TR>
	  <TR align=right> 
	    <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	  </TR>
	</TABLE>
      </form>
      <!-- banner menu end -->
    </TD>
  </TR>
  <TR>
    <TD width=25% bgcolor=#330066 align=left valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=0 align=center>
        <TR align=right> 
	  <TD bgcolor=#FF9966><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=2 alt=""></TD>
	</TR>
	<TR align=right> 
	  <TD bgcolor=#330066><IMG src="/prj/inetdoc/images/blank.gif" width=1 height=1 alt=""></TD>
	</TR>
	<TR>
	  <TD bgcolor=#330066 align=center>
	    &nbsp;<!-- no Toc section in guides/packet-filtering-HOWTO/packet-filtering-HOWTO.html -->
      	    <br>
      	    <TABLE width=100% border=0 cellpadding=0 cellspacing=4>
              <TR>
	  	<TD bgcolor=#000000 align=center>
	    	  <TABLE width=100% border=0 cellpadding=2 cellspacing=1>
              	    <TR>
	              <TH bgcolor=#FFCC66 align="center" valign="top" class="toc-title">
		        <a class="toc-title" href="mailto:philippe.latu@linux-france.org">
	        	  Contact<img src="/prj/inetdoc/images/envelope.gif" border=0 width=50 height=35 align="middle" alt="mail">
		  	</a>
		      </TH>
              	    </TR>
              	    <TR>
	              <TD bgcolor=#FFCC99 align=center valign=top class="toc-item">
		        &nbsp;<a class="toc-item" href="/prj/inetdoc/log/">Carnet de bord</a>
		      </TD>
              	    </TR>
              	    <TR>
	              <TD bgcolor=#FFCC99 align=center valign=top class="toc-item">
		  	&nbsp;<a class="toc-item" href="/prj/inetdoc/legal/">Notice légale</a>
		      </TD>
              	    </TR>
            	  </TABLE>
	  	</TD>
              </TR>
      	    </TABLE>
          </TD>
        </TR>
      </TABLE>
    </TD>
    <TD width=75% bgcolor=#FFFFFF align=left valign=top>
      <TABLE width=100% border=0 cellspacing=0 cellpadding=8 align=center>
        <TR>
	  <TD bgcolor=#FFFFFF align=left valign=top>
            <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org">
<meta name="GENERATOR" content="LinuxDoc-Tools 0.9.21">
<title>Linux 2.4 Packet Filtering HOWTO: Utiliser iptables</title>
<link href="packet-filtering-HOWTO-8.html" rel="next">
<link href="packet-filtering-HOWTO-6.html" rel="previous">
<link href="packet-filtering-HOWTO.html#toc7" rel="contents">
</head>
<body>
<a href="packet-filtering-HOWTO-8.html">Page suivante</a> <a href=
"packet-filtering-HOWTO-6.html">Page précédente</a> <a href=
"packet-filtering-HOWTO.html#toc7">Table des matières</a> 

<hr>
<h2><a name="s7">7.</a> <a href=
"packet-filtering-HOWTO.html#toc7">Utiliser iptables</a></h2>

<p>iptables a une page de manuel bien détaillée (<code>man
iptables</code>), si tu veux des détails en particulier. Si tu es
familier avec ipchains tu devrais simplement regarder <a href=
"packet-filtering-HOWTO-10.html#Appendix-A">Différences entre
iptables et ipchains</a>; ils sont vraiment similaires.</p>

<p>Il y a plusieurs choses que tu peux faire avec
<code>iptables</code>. Tu commences avec trois chaines de départ
<code>INPUT</code>, <code>OUTPUT</code> et <code>FORWARD</code> que
tu ne peux pas effacer. Regardons les opérations pour administrer
les chaines :</p>

<ol>
<li>Créer une nouvelle chaine (-N).</li>

<li>Effacer une chaine vide (-X).</li>

<li>Changer la règle par défaut pour une chaine de départ
(-P).</li>

<li>Lister les règles dans une chaine (-L).</li>

<li>Retirer les règles d'une chaine (-F).</li>

<li>Mettre à zero les compteurs de bits et de paquets d'une chaine
(-Z).</li>
</ol>

<br>
<br>
 

<p>Il y a plusieurs manières de manipuler une règles dans une
chaine :</p>

<ol>
<li>Ajouter une nouvelle règle à la chaine (-A).</li>

<li>Insérer une nouvelle règle à une position dans la chaine
(-I).</li>

<li>Remplacer une règle à une position dans la chaine (-R).</li>

<li>Supprimer une règle à une position dans la chaine (-D).</li>

<li>Supprimer la première règle qui convient dans une chaine
(-D).</li>
</ol>

<br>
<br>
 

<h2><a name="ss7.1">7.1</a> <a href=
"packet-filtering-HOWTO.html#toc7.1">Ce que tu Verras quand ton
Ordinateur Démarrera</a></h2>

<p>iptables peut être un module, appelé (`iptable_filter.o'), qui
devrait être automatiquement chargé quand tu lances
<code>iptables</code>. Il peut aussi être compilé dans le
noyau.</p>

<p>Avant qu'aucune commande n'ait été effectuée, (attention :
certaines distributions lanceront iptables dans leurs scripts
d'initialisation), il n'y a pas de règles dans aucune des chaines
par défaut (`INPUT', `FORWARD' et `OUTPUT'), toutes les chaines ont
une règle par défaut de ACCEPT. Tu peux changer la règle par defaut
de la chaine FORWARD en specifiant l'option `forward=0' au module
iptable_filter.</p>

<h2><a name="ss7.2">7.2</a> <a href=
"packet-filtering-HOWTO.html#toc7.2">Operations sur une Seule
Chaine</a></h2>

<p>C'est le pain et le beurre du filtrage de paquets; manipuler des
règles. plus communément, tu utiliseras probablement les commandes
d'ajout (-A) et d'effacement (-D). Les autres (-I pour insérer et
-R pour remplacer) sont de simples extensions de ces concepts.</p>

<p>Chaque règle spécifie des conditions que le paquet doit remplir,
et que faire si le paquet les remplis (une `cible'). Par exemple,
tu voudrais laisser tomber tous les paquets ICMP qui viennent de
l'adresse IP 127.0.0.1. Donc dans ce cas les conditions sont que le
protocole soit icmp et que l'adresse source soit 127.0.0.1. Notre
cible est `DROP'.</p>

<p>127.0.0.1 est l'interface `loopback', que tu auras même si tu
n'as pas de connection réseau réelle. Tu peux utiliser la commande
`ping' pour generer de tels paquets (elle envoie simplement un ICMP
de type 8 (echo request) auquel tout les hôtes devraient répondre
avec un icmp de type 0 (echo reply)). Cela est utile pour
tester.</p>

<blockquote>
<pre>
<code># ping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.2 ms

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.2/0.2/0.2 ms
# iptables -A INPUT -s 127.0.0.1 -p icmp -j DROP
# ping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Tu peux voir que le 1er ping a fonctionné (le `-c 1' dit à ping
de n'envoyer qu'un seul paquet).</p>

<p>Ensuite nous ajoutons (-A) à la chaine `INPUT', une règle
spécifiant que pour les paquets venant de 127.0.0.1 (`-s
127.0.0.1') avec le protocole ICMP (`-p icmp') nous devons sauter
vers la cible DROP (`-j DROP').</p>

<p>Ensuite nous testons notre règle, en utilisant le second ping.
Il y aura une pause avant que le programme ne stoppe parce qu'il
attendra une réponse qui ne viendra jamais.</p>

<p>Nous pouvons effacer une règle de deux façons. Premièrement,
comme nous savons que c'est la seule règle dans la chaine INPUT, on
peut utiliser un effacement avec le nombre, comme:</p>

<blockquote>
<pre>
<code>        # iptables -D INPUT 1
        #
</code>
</pre>
</blockquote>

Pour effacer la règle numéro 1 dans la chaine INPUT.<br>
<br>
 

<p>La seconde façon est un miroir de la commande -A, remplacer -A
par -D. C'est utile quand tu as une chaine complexe et que tu ne
veux pas les compter pour trouver que c'est la règle 37 que tu veux
effacer. Dans ce cas , on utiliserait:</p>

<blockquote>
<pre>
<code>        # iptables -D INPUT -s 127.0.0.1 -p icmp -j DROP
        #
</code>
</pre>
</blockquote>

La syntaxe de la commande -D doit avoir exactement les mêmes
options que celles de -A (ou -I ou -R). Si il y a plusieurs règles
identiques dans la même chaine, la première seulement sera
effacée.<br>
<br>
 

<h2><a name="ss7.3">7.3</a> <a href=
"packet-filtering-HOWTO.html#toc7.3">Spécifications de
filtrage</a></h2>

<p>Nous avons vu l'utilisation de `-p' pour specifier le protocole,
et de `-s' pour specifier la source, mais il y a d'autres options
que tu peux utiliser pour specifier les caractéristiques d'un
paquet. Ce qui suit est une liste exhaustive.</p>

<h3>Specifier les adresses IP source et destination</h3>

<p>Les adresses IP source (`-s', `--source' ou `--src') et
destination (`-d',`--destination' ou `--dst') peuvent être
specifiées de 4 façons. La façon la plus commune est d'utiliser le
nom complet, comme `localhost' ou `www.linuxhq.com'. La seconde
façon est de specifier l'adresse IP comme `127.0.0.1'.</p>

<p>Les troisièmes et quatrièmes façons permettent de specifier un
groupe d'IPs, comme `199.95.207.0/24' ou
`199.95.207.0/255.255.255.0'. Elles specifient toutes deux les
adresses de 199.95.207.0 à 199.95.207.255 inclus; les nombres après
le `/' disent quelle partie des adresses IP a de la signification.
`/32' ou `/255.255.255.255' est le défaut (correspond à toutes les
adresses IP). Pour specifier toutes les adresses IP `/0' peut être
utilisé, comme dans :</p>

<blockquote>
<pre>
<code>        [ NOTE: `-s 0/0' is redundant here. ]
        # iptables -A INPUT -s 0/0 -j DROP
        #
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>C'est rarement utilisé, comme l'effet ci dessus est le même que
de ne pas specifier l'option `-s' du tout.</p>

<h3>Spécifier une inversion</h3>

<p>Beaucoup d'options comme `-s' (ou `--source' ) et `-d'
(`--destination') peuvent avoir leurs arguments précédés de `!'
(pronnoncé `NOT') pour correspondre aux adresses PAS égales à
celles données. Par exemple `-s ! localhost' correspond à tout
paquet qui ne vient <b>pas</b> de localhost.</p>

<h3>Specifier le protocole</h3>

<p>Le protocole peut être spécifié avec `-p' ( ou `--protocol'). Le
protocole peut être un nombre (si tu connais les valeurs numériques
de protocole IP) ou un nom pour les cas spéciaux `TCP', `UDP' ou
`ICMP'. La casse n'a pas d'importance, `tcp' marche aussi bien que
`TCP'.</p>

<p>Le nom du protocole peut être préfixé d'un `!', pour l'inverser,
comme `-p ! TCP' pour specifier les paquets qui ne sont <b>pas</b>
TCP.</p>

<h3>Specifier une interface</h3>

<p>Les options `-i' (ou `--in-interface') et `-o' (ou
`--out-interface') spécifient le nom d'une <b>interface</b> à
laquelle le paquet doit correspondre. Une interface est l'appareil
physique par lequel le paquet arrive (`-i') ou sort (`-o'). Tu peux
utiliser <code>ifconfig</code> pour voir les interfaces qui sont
`up' (p.e., qui fonctionnent pour le moment).</p>

<p>Les paquets qui traversent la chaine <code>INPUT</code> n'ont
pas encore d'interface de sortie donc, une règle utilisant `-o'
dans cette chaine ne conviendra pas; les paquets traversant la
chaine <code>OUTPUT</code> n'ont pas d'interface d'entrée, donc
toute règle utilisant `-i' dans cette chaine ne correspondra
jamais.</p>

<p>Seuls les paquets traversant la chaine <code>FORWARD</code> on
une interface d'entrée et de sortie.</p>

<p>Il est parfaitement légal de specifier une interface qui
n'existe pas; la règle ne conviendra pas jusqu'à ce que l'interface
soit `up'. C'est vraiment utile pour les lignes PPP (habituellement
l'interface <code>ppp0</code>) et ses semblables.</p>

<p>Un cas special est un nom d'interface se terminant par `+' qui
conviendra a toutes les interfaces (qui existent déja ou pas) qui
commencent par ces lettres. Par exemple, pour specifier une règle
qui convient à toutes les interfaces PPP, on utilisera l'ioption
<code>-i ppp+</code>.</p>

<p>Le nom de l'interface peut être précédé par un `!' pour convenir
à un paquet qui n'appartient <b>pas</b> à l'interface
spécifiée.</p>

<h3>Specifier des Fragments</h3>

<p>Parfois un paquet est trop large pour rentrer dans la ligne de
transmission (NdT: oui, je sais les traductions sont parfois
foireuses). Quand ça arrive, le paquet est divisé en
<b>fragments</b>, et envoyé comme de multiples paquets. Le
récepteur réassemble ces fragments pour reconstruire le paquet
entier.</p>

<p>Le problème avec les fragments c'est que le fragment initial a
son en-tète complète (IP + TCP, UDP et ICMP) à examiner mais que
les paquets suivants ont seulement quelques morceaux de l'en-tète
(IP sans les champs de protocole). Donc regarder à l'intérieur des
fragments suivants à la recherche d'en-tètes de protocoles (comme
c'est fait pour les extensions TCP, UDP et ICMP) n'est pas
possible.</p>

<p>Si tu utilises le suivi de connection ou le NAT, alors tout les
fragments seront recollés avant qu'ils n'arrivent au code de
filtrage de paquets, donc tu n'auras pas à t'occuper des
fragments.</p>

<p>Autrement il est important de comprendre comment les fragments
sont traités par les règles de filtrage. Toute règle de filtrage
qui demande des infomations qu'on a pas ne conviendra <em>pas</em>.
Ca veut dire que le premier fragment est traité comme tout autre
paquet, mais que le second et suivants ne le seront pas. Donc une
règle <code>-p TCP --sport www</code> (qui specifie le port source
`www') ne conviendra jamais à un fragment (autre que le premier
fragment). L'opposé est aussi valable <code>-p TCP --sport !
www</code>.</p>

<p>Sinon, tu peux specifier une règle pour les seconds fragments et
suivants, en utilisant l'option `-f' (ou `--fragment'). Il est
aussi légal de spécifier une règle qui ne s'applique <em>pas</em>
aux secondes fragments et suivants, en précédant `-f' avec `!'.</p>

<p>Habituellement il est sécurisant de laisser passer les seconds
fragments et suivants, comme le filtrage sera fait sur le premier,
et empèchera le réassemblement sur la machine cible; mais des bugs
ont été trouvés qui permettent de crasher la machine simplement en
lui envoyant des fragments.</p>

<p>Note: les paquets malformés (TCP, UDP et ICMP qui sont trop
courts pour que le code de firewalling lise les ports ou le code
ICMP et le type) sont DROPer quand de telles combinaisons sont
tentées, comme les fragments TCP qui commencent à la position
8.</p>

<p>Comme exemple, la règle suivante va laisser tomber tout les
fragments qui vont vers 192.168.1.1 :</p>

<blockquote>
<pre>
<code># iptables -A OUTPUT -f -d 192.168.1.1 -j DROP
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<h3>Extensions à iptables : Nouvelles Correspondances</h3>

<p><code>iptables</code> est <b>extensible</b>, ce qui veut dire
que le noyau et le programme iptables peuvent être étendus pour
avoir de nouvelles capacités.</p>

<p>Quelques unes de ces extensions sont standard, et d'autres sont
plus exotiques. Elles peuvent être créées par d'autres personnes et
distribuées séparément aux utilisateurs.</p>

<p>Les extensions au noyau sont normalement situées dans le
répretoire des modules du kernel comme /lib/modules/2.3.15/net.
Elles sont chargées a la demande si ton kernel a été compilé avec
CONFIG_KMOD, donc tu n'as pas besion de les insérer à la main.</p>

<p>Les extensions au programme iptables sont des librairies
partagées qui sont generallement situées dans
/usr/local/lib/iptables/, bien qu'une distribution puisse les
mettre dans /lib/iptables ou /usr/lib/iptables.</p>

<p>Les extensions sont de deux types : nouvelles correspondances et
nouvelles cibles (nous parlerons des nouvelles cibles plus tard).
Quelques protocoles offrent aussi de nouveaux tests : pour le
moment TCP, UDP et ICMP.</p>

<p>Pour ceux-ci tu pourras specifier les nouveaux tests sur la
ligne de commande après l'option `-p', qui va charger l'extension.
Pour specifier de nouveaux tests, utilises l'option `-m' pour
charger l'extension, après quoi l'extension est disponible.</p>

<p>Pour obtenir de l'aide sur une extension, utilises l'option pour
la charger (`-p', `-j' ou `-m') suivi de `-h' ou `--help',
p.e.:</p>

<blockquote>
<pre>
<code># iptables -p tcp --help
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<h3>Extensions TCP</h3>

<p>Les extensions TCP sont automatiquement chagées si `-p tcp' est
spécifié. Elles permettent les options suivantes (aucune d'entre
elles ne convient aux fragments).</p>

<dl>
<dt><b>--tcp-flags</b></dt>

<dd>
<p>Suivi d'un `!' optionnel, ensuite 2 chaines de caractères de
drapeaux, te permet de filtrer des drapeaux TCP spécifiques. La
première chaine de drapeaux est le masque : une liste de drapeaux
que tu veux examiner. La deuxième chaine de drapeaux dit lequel
doit être présent. Par exemple:</p>

<blockquote>
<pre>
<code># iptables -A INPUT --protocol tcp --tcp-flags ALL SYN,ACK -j DENY
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Ceci indique que tous les drapeaux doivent être examinés (`ALL'
est ynonyme de `SYN,ACK,FIN,RST,URG,PSH'), mais seulement SYN et
ACK doivent être présents. Il y a aussi l'argument `NONE' qui veut
dire pas de drapeaux.</p>
</dd>

<dt><b>--syn</b></dt>

<dd>
<p>Précédé optionnelement d'un `!', c'est une raccourci pour
`--tcp-flags SYN,RST,ACK SYN'.</p>
</dd>

<dt><b>--source-port</b></dt>

<dd>
<p>suivi d'un `!' optionnel, ensuite soit un port TCP seul, ou un
bloc de ports. Les ports peuvent être des noms de ports, listés
dans `/etc/services', ou des nombres. Les blocs sont soit 2 noms de
ports séparés par `:', ou (pour specifier plus grand que ou égal a)
un port avec un `:' ajouté, ou (pour specifier plus petit que ou
égal a) un port précédé de `:'.</p>
</dd>

<dt><b>--sport</b></dt>

<dd>
<p>est synonime de `--source-port'.</p>
</dd>

<dt><b>--destination-port</b></dt>

<dd>
<p>et</p>
</dd>

<dt><b>--dport</b></dt>

<dd>
<p>sont les mêmes qu'au dessus, ils spécifient juste la destination
plutôt que la source qui convient.</p>
</dd>

<dt><b>--tcp-option</b></dt>

<dd>
<p>suivi d'un `!' optionnel ou d'un nombre, convient à un paquet
qui a une option TCP qui équivaut à ce nombre. Un paquet qui n'a
pas une en-tète TCP complète est laissé tombé automatiquement si un
essai est fait pour examiner ses options TCP.</p>
</dd>
</dl>

<br>
<br>
 

<h3>Une Explication des Drapeaux TCP</h3>

<p>Il est parfois utile d'autoriser les connections TCP dans un
sens mais pas dans l'autre. Par exemple, tu pourrais vouloir
autoriser les connections vers un serveur WWW externe, mais pas les
connections à partir de ce serveur.</p>

<p>L'approche naive serait de bloquer les paquets TCP venant du
serveur. Malheureusement, les connections TCP on besion d'avoir des
paquets qui vont dans les deux sens pour fonctionner.</p>

<p>La solution est de bloquer seulement les paquets qui sont
utilisés pour demander une connection. Ces paquets sont appelés des
paquets <b>SYN</b> (ok, techniquement ce sont des paquets avec le
drapeux SYN et pas de drapeaux FIN et ACK, mais nous les appelons
paquets SYN pour faire plus court). En déniant seulement ces
paquets, nous pouvons stopper les tentatives de connections.</p>

<p>Le drappeau `--syn' est utilisé pour cela : il est seulement
valide pour les règles qui spécifient TCP comme protocole. Par
exemple, pour specifier un essai de connection de la part de
192.168.1.1 :</p>

<blockquote>
<pre>
<code>-p TCP -s 192.168.1.1 --syn
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Ce drapeau peut être spécifié en le précédant de `!', qui veut
dire tout les paquets sauf ceux d'initiation de connection.</p>

<h3>Extensions UDP</h3>

<p>Ces extensions sont automatiquements chargées si `-p udp' est
spécifié. Elles donnent les options `--source-port', `--sport',
`--destination-port' et `--dport' comme détaillé pour le tcp
ci-dessus.</p>

<h3>Extensions ICMP</h3>

<p>Ces extensions sont automatiquements chargées si `-p icmp' est
spécifié. Elles donnent seulement une seule nouvelle option :</p>

<dl>
<dt><b>--icmp-type</b></dt>

<dd>
<p>suivi d'un `!' optionnel, et ensuite un nom de type icmp (pe.
`host-unreachable'), ou un type numérique (p.e. `3'), ou un type et
un code numérique séparés par un `/' (p.e. `3/3'). Une liste de
types icmp disponibles est donnée en utilisant `-p icmp
--help'.</p>
</dd>
</dl>

<br>
<br>
 

<h3>Autres Extensions de Concordance</h3>

<p>Les autres extensions dans le package netfilter sont des
extensions de démonstration, qui (si installées) peuvent être
invoquées avec l'option `-m'.</p>

<dl>
<dt><b>mac</b></dt>

<dd>
<p>Ce module doit être spécifié explicitement avec `-m mac' ou
`--match mac'. Il est utilisé pour concorder à des adresses
Ethernet (MAC) de paquets qui arrivent, et est seulement utile pour
convenir avec des paquets traversant les chaines INPUT et
PREROUTING. Il donne une seule option:</p>

<dl>
<dt><b>--mac-source</b></dt>

<dd>
<p>suivi d'un `!' optionnel, ensuite une adresse ethernet en
notation hexa séparée par `:', pe `--mac-source
00:60:08:91:CC:B7'.</p>
</dd>
</dl>

<br>
<br>
</dd>

<dt><b>limit</b></dt>

<dd>
<p>Ce module doit être spécifié explicitement avec `-m limit' ou
`--match limit'. Il est utilisé pour limiter la vitesse de
concordance, comme pour specifier des messages de log. Il
conviendra seulement à un certain nombre de fois pas seconde ( par
défaut 3 concordances par heure, avec une réserve de 5). Il prends
deux arguments optionnels:</p>

<dl>
<dt><b>--limit</b></dt>

<dd>
<p>suivi d'un nombre; spécifie le nombre maximum de concordances
allouées par seconde. Le nombre peut specifier les unités
explicitement, en utilisant `/second', `/minute', `/hour' ou
`/day', ou une partie (donc `5/second' est le même que `5/s').</p>
</dd>

<dt><b>--limit-burst</b></dt>

<dd>
<p>suivi d'un nombre, inndique la réserve maximale avant
d'atteindre la limite ci-dessus.</p>
</dd>
</dl>

<br>
<br>
 

<p>Cette concordance peut souvent être utilisée avec la cible LOG
pour effectuer du logging limité en débit. Pour comprendre comment
cela fonctionne on va regarder à la règle suivante, qui logue les
paquets avec les paramètres de limite par défaut:</p>

<blockquote>
<pre>
<code># iptables -A FORWARD -m limit -j LOG
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>La première fois que cette règle est atteinte, le paquet sera
logué; en fait comme la réserve est de 5, les 5 premiers paquets
seront logués. Après cela, 20 minutes passeront avant qu'un paquet
ne soit logué par cette règle, sans tenir compte du nombre de
paquets qui l'atteignent. Aussi, chaque 20 minutes qui passent sans
concorder avec un paquet, un paquet de la réserve sera regagné; si
aucun paquet n'atteint la règle pendant 100 minutes, la réserve
sera complètement rechargée; on est revenu au point de départ.</p>

<p>Note : tu ne peux pas créer de règle avec un temps de recharge
de plus de 59 heures, donc si tu configures un débit moyen de 1 par
jour, alors le débit de réserve doit être inférieur à 3.</p>

<p>Tu peux aussi utiliser ce module pour eviter les déniement de
service (DoS) avec un débit supérieur pour augmenter la vitesse de
réaction.</p>

<p>Protection syn-flood:</p>

<blockquote>
<pre>
<code># iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Test de ports furtif:</p>

<blockquote>
<pre>
<code># iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Ping de la mort:</p>

<blockquote>
<pre>
<code># iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Ce module fonctionne comme "une porte à hystérésis", comme
montré dans le graphe qui suit.</p>

<blockquote>
<pre>
<code>         débit (pkt/s)  
               ^        .---.
               |       / DoS \
               |      /       \
limite de DoS -|.....:.........\.......................
 = (limit *    |    /:          \
limit-reserve) |   / :           \         .-.
               |  /  :            \       /   \
               | /   :             \     /     \
Fin de DoS    -|/....:..............:.../.......\..../.
 = limite      |     :              :`-'         `--'
-------------+-----+--------------+------------------&gt; temps (s)
   LOGIQUE =&gt;concord.| pas concord. |    concord.
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>On dit un paquet par seconde avec une réserve de 5 paquets mais,
les paquets commences à arriver à 4/s pendant 3 secondes puis
recommencent après 3 autres secondes</p>

<blockquote>
<pre>
<code>

        &lt;--Flood 1--&gt;           &lt;---Flood 2---&gt;

Total  ^                  Ligne  __--      YNNN
Paquets|              Débit  __--      YNNN
       |            mum  __--      YNNN
    10 |        Maxi __--         Y
       |         __--            Y
       |     __--               Y
       | __--    YNNN           
       |-    YNNN
     5 |    Y    
       |   Y                                Key:  Y -&gt; Règle concorde
       |  Y                                       N -&gt; Règle concorde pas
       | Y
       |Y 
     0 +--------------------------------------------------&gt;  Temps (secondes)
        0   1   2   3   4   5   6   7   8   9  10  11  12
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Tu peux voir que les 5 premiers paquets sont autorisés à
depasser la limite de un paquet par seconde, ensuite la limite
entre en jeu. Si il y a une pause, un autre bloc est autorisé, mais
pas au dessus de la limite maximum configurée par la règle (1
paquet par seconde après que la première réserve soit usée).</p>
</dd>

<dt><b>owner</b></dt>

<dd>
<p>Ce module essaye de concorder les caractéristiques variées du
créateur du paquet, pour les paquets générés locallement. Il est
seulement valide pour la chaine OUTPUT, et même comme cela,
certains paquets (comme les réponses de ping ICMP) n'auront pas de
possesseur, et donc ne concorderont jamais.</p>

<dl>
<dt><b>--uid-owner userid</b></dt>

<dd>
<p>Concorde si le paquet a été créé par un processus qui a le user
id effectif (numérique) donné.</p>
</dd>

<dt><b>--uid-owner groupid</b></dt>

<dd>
<p>Concorde si le paquet a été créé par un processus qui a le group
id effectif (numérique) donné.</p>
</dd>

<dt><b>--pid-owner processid</b></dt>

<dd>
<p>Concorde si le paquet a été créé par un processus qui a le
process donné.</p>
</dd>

<dt><b>--sid-owner sessionid</b></dt>

<dd>
<p>Concorde si le paquet a été créé par un processus qui a le
groupe de session donné.</p>
</dd>
</dl>

<br>
<br>
</dd>

<dt><b>unclean</b></dt>

<dd>
<p>Ce module expérimental doit être spécifié explicitement avec `-m
unclean ou `--match unclean'. Il effectue des vérifications
sanitaires aléatoires et variées sur les paquets. Ce module n'a pas
été testé, et ne devrait pas être utilisé comme une fonction de
sécurité (il rend peut-ètre les choses plus mauvaises si il a des
bugs lui-mème). Il n'a pas d'options.</p>
</dd>
</dl>

<br>
<br>
 

<h3>La Concordance d'Etat</h3>

<p>Le critère le plus utile est fourni par l'extension `state' qui
interprète l'analyse de suivi de connection du module
`ip_conntrack'. Il est fortement recommendé.</p>

<p>Specifier `-m state' permet une option additionelle `--state',
qui est une liste séparée par des virgules d'états qui conviennent
( les `!' indiquent les états qui ne conviennent <b>pas</b>. Ces
états sont:</p>

<dl>
<dt><b>NEW</b></dt>

<dd>
<p>Un paquet qui engendre une nouvelle connection.</p>
</dd>

<dt><b>ESTABLISHED</b></dt>

<dd>
<p>Un paquet qui appartient à une connection existante (p.e., une
qui a eu des paquets de réponse).</p>
</dd>

<dt><b>RELATED</b></dt>

<dd>
<p>Un paquet qui est relaté a, mais pas partie de, une connection
existante, comme une erreur ICMP, ou ( avec le module ftp chargé),
un paquet qui etablit une connection de données ftp.</p>
</dd>

<dt><b>INVALID</b></dt>

<dd>
<p>Un paquet qui ne peut pas être identifié pour n'importe quelle
raison : ceci inclus le manque de mémoire et les erreurs icmp qui
ne correspondent à aucune connection connue. Générallement, ces
paquets doivent être laissé tombés.</p>
</dd>
</dl>

<br>
<br>
 

<h2><a name="ss7.4">7.4</a> <a href=
"packet-filtering-HOWTO.html#toc7.4">Specifications de
Cibles</a></h2>

<p>Maintenant nous connaissons les examens que nous pouvons faire
sur un paquet, nous avons besoin de trouver une façon de dire quoi
faire de ces paquets qui correspondent à nos tests. Ceci est appelé
la <b>cible</b> d'une règle.</p>

<p>Il y a deux cibles simples compilées : DROP et ACCEPT. Nous les
avons déja rencontrées. Si une règle correspond à un paquet et que
la cible est une de celles ci, les règles suivantes ne sont pas
consultées : le sort du paquet a été décidé.</p>

<p>Il y a deux autres types de cibles que celles qui sont compilées
: les extensions et les chaines créées par l'utilisateur.</p>

<h3>Les chaines créées par l'utilisateur</h3>

<p>Une propriété puissante que <code>iptables</code> hérite de
<code>ipchains</code> est la possibilité pour l'utilisateur de
créer de nouvelles chaines, en addition a celles qui existent déja
(INPUT, FORWARD et OUTPUT). Par convention les chaines utilisateur
sont en minuscule pour les distinguer, nous décrirons comment créer
des chaines utilisateur dans <a href="#chain-ops">Opérations sur
une Chaine Entière</a> ci-dessous).</p>

<p>Quand un paquet concorde à une règle dont la cible est une
chaine utilisateur, le paquet commence à traverser les règles dans
la chaine utilisateur. Si cette chaine ne décide pas du sort du
paquet, alors une fois que la traversée de cette chaine est
terminée, la traversée reprend sur la règle suivante de la chaine
courante.</p>

<p>Il est temps pour un peu plus d'art ASCII. Considérons deux
chaines: <code>INPUT</code> (la chaine par defaut) et
<code>test</code> (une chaine utilisateur).</p>

<blockquote>
<pre>
<code>         `INPUT'                         `test'
        ----------------------------    ----------------------------
        | Règle1: -p ICMP -j DROP  |    | Règle1: -s 192.168.1.1   |
        |--------------------------|    |--------------------------|
        | Règle2: -p TCP -j test   |    | Règle2: -d 192.168.1.1   |
        |--------------------------|    ----------------------------
        | Règle3: -p UDP -j DROP   |
        ----------------------------
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Considérons un paquet TCP venant de 192.168.1.1, allant à
1.2.3.4. Il entre dans la chaine <code>INPUT</code>, et est testé
par la règle1 - pas de concordance. La règle2 concorde et sa cible
est <code>test</code>, donc la règle suivante examinée est le debut
de la chaine <code>test</code>. La règle1 de <code>test</code>
concorde mais ne spécifie pas de cible, donc la règle suivante est
examinée, la règle2. Ca ne concorde pas, nous avons atteint la fin
de la chaine <code>test</code>. Nous retournons à la chaine
<code>INPUT</code> ou nous venons d'examiner la règle2, donc nous
examinons la règle3, qui ne concorde pas d'avantage.</p>

<p>Donc la traversée du paquet est:</p>

<blockquote>
<pre>
<code>                                v    __________________________
         `INPUT'                |   /    `test'                v
        ------------------------|--/    -----------------------|----
        | Règle1                | /|    | Règle1               |   |
        |-----------------------|/-|    |----------------------|---|
        | Règle2                /  |    | Règle2               |   |
        |--------------------------|    -----------------------v----
        | Règle3                /--+___________________________/
        ------------------------|---
                                v
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Les chaines utilisateurs peuvent sauter dans d'autres chaines
utilisateur (mais ne fais pas de boucles : tes paquets seront
laissés tomber si ils sont dans une boucle).</p>

<h3>Extensions à iptables : Nouvelles Cibles</h3>

<p>L'autre type de cible est une extension. Une extension de cible
consiste en un module du noyau, et une extension optionnele à
<code>iptables</code> pour permettre de nouvelles options sur la
ligne de commande. Il y a plusieurs extensions dans la distribution
netfilter :</p>

<dl>
<dt><b>LOG</b></dt>

<dd>
<p>Ce module permet de logger les paquets qui concordent. Il donne
plusieurs options additionelles:</p>

<dl>
<dt><b>--log-level</b></dt>

<dd>
<p>Suivi d'un nombre de niveau ou d'un nom. Les noms valides sont
(non sensible à la casse) `debug', `info', `notice', `warning',
`err', `crit', `alert' and `emerg', correspondent aux nombres 7 à
0. Voir la page de manuel de syslog.conf pour une explication de
ces niveaux.</p>
</dd>

<dt><b>--log-prefix</b></dt>

<dd>
<p>Suivi d'une chaine de 29 caractères maximum, ce message est
envoyé au début du message de log, pour lui permettre d'être
identifié uniquement.</p>
</dd>
</dl>

<br>
<br>
 

<p>Ce module est le plus utile après une concordance limit, pour ne
pas saturer les logs.</p>
</dd>

<dt><b>REJECT</b></dt>

<dd>
<p>Ce module a les mèmes effets que `DROP', excepté que l'envoyeur
reçoit un message d'erreur ICMP `port unreachable'. Notes que le
message d'erreur ICMP n'est pas envoyé si (voir RFC 1122):</p>

<ul>
<li>Le paquet filtré etait un message d'erreur ICMP, ou un type
ICMP inconnu.</li>

<li>Le paquet filtré est un fragment sans en-tète.</li>

<li>Nous avons envoyé trop de messages d'erreur ICMP à cette
destination récemment.</li>
</ul>

<br>
<br>
 

<p>REJECT peut aussi prendre une option `--reject-with' qui altère
le type du paquet de réponse utilisé : voir la page de manuel.</p>
</dd>
</dl>

<br>
<br>
 

<h3>Cibles Speciales compilées</h3>

<p>Il y a 2 cibles speciales compilées: <code>RETURN</code> et
<code>QUEUE</code>.</p>

<p><code>RETURN</code> a le même effet que de tomber à la fin d'une
chaine : pour une règle dans une chaine compilée, la police de la
chaine est exécutée. Pour une règle dans une chaine utilisateur, la
traversée continue dans la chaine précédente, juste après la règle
qui a sauté sur cette chaine.</p>

<p><code>QUEUE</code> est une cible spéciale, met les paquets en
queue pour les traiter en espace utilisateur. Pour que ça soit
utile, deux composants supplémentaires sont requis:</p>

<ul>
<li>un "arbitre de queue", qui utilise les mécanismes du noyau pour
passer les paquets entre le noyau et l'espace utilisateur; et</li>

<li>une application utilisateur pour recevoir, peut être manipuler,
et donner un verdict sur les paquets.</li>
</ul>

L'arbitre de queue standard IPV4 pour iptables est le module
ip_queue, qui est distribué avec le noyau et marqué comme
expérimental.<br>
<br>
 

<p>Ce qui suit est un exemple rapide de comment utiliser iptables
pour mettre des paquets en queue pour les traiter en espace
utilisateur:</p>

<blockquote>
<pre>
<code># modprobe iptable_filter
# modprobe ip_queue
# iptables -A OUTPUT -p icmp -j QUEUE
</code>
</pre>
</blockquote>

Avec cette règle, les paquets ICMP sortants générés locallement
(comme créés par exemple avec ping) sont passés au module ip_queue,
qui ensuite essaye de délivrer les paquets à une application
utilisateur. Si aucune application n'est là pour prendre les
paquets, ils sont laissés tomber.<br>
<br>
 

<p>Pour écrire une application utilisateur, utilises l'API libipq.
Elle est distribuée avec iptables. du code d'exemple peut être
trouvé avec les outils de la suite de tests (p.e. redirect.c) en
CVS.</p>

<p>Le status de ip_queue peut être vérifié via :</p>

<blockquote>
<pre>
<code>/proc/net/ip_queue
</code>
</pre>
</blockquote>

La longueur maximale de la queue (le nombre de paquets délivrés à
l'espace utilisateur sans verdict retourné) peut être controllé via
: 

<blockquote>
<pre>
<code>/proc/sys/net/ipv4/ip_queue_maxlen
</code>
</pre>
</blockquote>

La valeur par défaut de la longueur maximum de la queue est 1024.
Une fois que cette limite est atteinte, les nouveaux paquets seront
laissés tomber jusqu'a ce que la longueur de la queue tombe en
dessous de la limite. Les protocoles bien faits comme le TCP
interprètent les paquets laissés tombés comme une congestion, et
réagiront positivement lorsque la queue se remplit. De toutes
façons, des expériences doivent être faites pour determiner la
longueur de queue maximale pour une situation donnée si la valeur
par défaut est trop petite.<br>
<br>
 

<h2><a name="chain-ops"></a> <a name="ss7.5">7.5</a> <a href=
"packet-filtering-HOWTO.html#toc7.5">Operations sur une Chaine
Entière</a></h2>

<p>Une propriété utile de <code>iptables</code> est la possibilité
de groupper des règles dans des chaines. Tu peux appeler les
chaines comme tu veux, mais je recommende les minuscules pour
éviter la confusion avec les chaines compilées et les cibles. les
noms de chaines peuvent être de 31 caractères maximum.</p>

<h3>Créer une Nouvelle Chaine</h3>

<p>Créons une nouvelle chaine. Parce que je suis imaginatif je
l'appelerai <code>test</code>. Nous utilisons l'option `-N' ou
`--new-chain':</p>

<blockquote>
<pre>
<code># iptables -N test
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>C'est aussi simple que ça. Maintenant tu peux mettre des règles
dedans comme détaillé au dessus.</p>

<h3>Supprimer une Chaine</h3>

<p>Effacer une chaine est simple aussi, en utilisant l'option `-X'
ou `--delete-chain'. Pourquoi `-X'? Ben, toutes les bonnes règles
étaient prises.</p>

<blockquote>
<pre>
<code># iptables -X test
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Il y a quelques restrictions pour effacer une chaine : elles
doit être vide (voir <a href="#flushing">Vider une Chaine</a>
dessous) et elle ne doit pas être la cible d'une table. Tu ne peux
pas effacer une des chaines compilées.</p>

<p>Si tu ne spécifie pas de chaine, <em>toutes</em> les chaines
utilisateur seront effacées, si possible.</p>

<h3><a name="flushing"></a> Vider une Chaine</h3>

<p>Il y a une façon simple d'effacer toutes les règles d'une
chaine, en utilisant la commande `-F' (or `--flush').</p>

<blockquote>
<pre>
<code># iptables -F FORWARD
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Si tu ne spécifie pas de chaine, alors <em>toutes</em> les
chaines seront vidées.</p>

<h3>Lister une Chaine</h3>

<p>Tu peux lister toutes les règles d'une chaine en utilisant la
commande `-L' (or `--list').</p>

<p>Le `refcnt' listé pour chaque chaine utilisateur est le nombre
de règles qui ont cette chaine pour cible. Il doit être à zero (et
la chaine doit être vide) avant que cette chaine soit effacée.</p>

<p>Si le nom de la chaine est omis, toutes les chaines sont
listées, mème les chaines vides.</p>

<p>Il y a trois options qui peuvent accompagner `-L'. Le `-n'
(numérique) qui est vraiment utile car il évite à
<code>iptables</code> d'essayer de résoudre les adresses IP, qui
(si tu utilises des DNS comme la pluspart des gens) causera de
larges délais si ton DNS n'est pas configuré convenablement, ou tu
as filtré les requètes DNS. Il cause aussi les ports TCP et UDP au
lieu d'être affiché par leur nom seront affiché par le numero.</p>

<p>L'option `-v' te montre tous les détails des règles, comme les
compteurs de paquets et d'octets, les comparaisons TOS, et les
interfaces. Sinon ces valeurs sont omises.</p>

<p>Notes que les compteurs de paquets et d'octets sont écris en
utilisant les suffixes `K', `M' ou `G' pour 1000, 1,000,000 et
1,000,000,000 respectivement. Utiliser `-x' (expansion des nombres)
écrit les nombres complets sans importance avec leur grandeur.</p>

<h3>Resetter (Zeroer) les Compteurs</h3>

<p>Ilk est utile de pouvoir remettre les compteurs à zéro. Ca peut
être fait avec l'option `-Z' (ou `--zero').</p>

<p>Considères ceci:</p>

<blockquote>
<pre>
<code># iptables -L FORWARD
# iptables -Z FORWARD
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<p>Dans l'exemple du dessus, quelques paquets pourraient passer
entre les commandes `-L' et `-Z'. Pour cette raison, tu peux
utiliser `-L' et `-Z' <em>ensembles</em>, pour remettre les
compteurs à zero en les lisant.</p>

<h3><a name="policy"></a> Configurer la Police</h3>

<p>Nous avons parlé de ce qui arrive quand un paquet arrive à la
fin d'une chaine compilée quand nous avons discuté comment un
paquet traversait les chaines plus tôt. Dans ce cas, la
<b>police</b> de la chaine détermine le sort du paquet. Seules les
chaines compilées (<code>INPUT</code>, <code>OUTPUT</code> et
<code>FORWARD</code>) ont des polices, à cause du fait que si un
paquet tombe à la fin d'une chaine utilisateur, la traversée
reprend à la chaine précédente.</p>

<p>La police peut être soit <code>ACCEPT</code> ou
<code>DROP</code> par exemple :</p>

<blockquote>
<pre>
<code># iptables -P FORWARD DROP
#
</code>
</pre>
</blockquote>

<br>
<br>
 

<hr>
<a href="packet-filtering-HOWTO-8.html">Page suivante</a> <a href=
"packet-filtering-HOWTO-6.html">Page précédente</a> <a href=
"packet-filtering-HOWTO.html#toc7">Table des matières</a>
</body>
</html>


	  </TD>
	</TR>
      </TABLE>
    </TD>
  </TR>
  <TR>
    <TD colspan=2 width=100% bgcolor=#990000 align=left>
      <TABLE width=100% border=0 cellpadding=0 cellspacing=4>
        <TR>
	  <TD bgcolor=#990000 align=right>
	    <div class="filemodtime">
	      <i>Dernière modification le : 9 May 2002 13:53</i>
	    </div>
      	    <a style="text-decoration:none" href="http://www.php.net">
              <img src="/prj/inetdoc/images/php-small-trans-dark.gif" border=0 width=88 height=31 alt="php logo">
      	    </a>
      	    &nbsp;&nbsp;
      	    <a style="text-decoration:none" href="http://www.debian.org">
              <img src="/prj/inetdoc/images/openlogo-25.jpg" border=0 width=25 height=30 alt="debian logo">
      	    </a>
      	    &nbsp;&nbsp;
	    <!-- stat_code_start
	    <a style="text-decoration:none" href="http://www.estat.com/getstats?serial=21701747824">
	      <img src="http://perso.estat.com/cgi-bin/perso/21701747824?page=marque_perso" border=0>
	    </a>
	     stat_code_end -->
	    <!-- eStat -->
	    <SCRIPT LANGUAGE="JavaScript">
	      <!--
	      var _UJS=0;
	      //-->
	    </SCRIPT>
	    <SCRIPT LANGUAGE="JavaScript" SRC="http://perso.estat.com/js/m.js">
	    </SCRIPT>
	    <SCRIPT LANGUAGE="JavaScript">
	      <!--
	      if(_UJS) _estat('21701747824','Page_D_Accueil','Accueil');
	      //-->
	    </SCRIPT>
	    <!-- /eStat -->
	  </TD>
	</TR>
      </TABLE>
    </TD>
  </TR>
</TABLE>
</body>
</html>
<!-- END: main.tpl -->
