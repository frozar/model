<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="P. Trau">
   <meta name="description" content="Les bases du C++ (il faut déjà connaître C ANSI)">
   <meta name="keywords" content="cplusplus, c plus plus, C++, objets, instance, héritage, instanciation">
   <meta name="GENERATOR" content="Mozilla/4.7 [fr] (X11; I; Linux 2.2.14-15mdk i586) [Netscape]">
   <title>Introduction C++ - P. Trau</title>
<!-- c'est pas vrai!-->
</head>
<body text="#FFFFB0" bgcolor="#111122" link="#99CCFF" vlink="#CC99FF" alink="#CC99FF" background="fond-inv.gif">

<div align=right><a href="http://www-ipst.u-strasbg.fr/pat/">P. Trau</a><a href="http://www-ipst.u-strasbg.fr/ipst/">ULP-IPST</a></div>

<center>
<h1>
Introduction au C++</h1></center>

<p><br>
<hr size=4>
<h2>
Table des mati&egrave;res</h2>
<a href="#Heading1"><img SRC="bullevar.gif" ALT="*" BORDER=0 height=11 width=15></a>&nbsp;<a href="#Heading1">
1) INTRODUCTION</a>
<ul>
<ul>
<li>
<a href="#Heading2">a) qu'est-ce qu'un objet ?</a></li>

<li>
<a href="#Heading3">b) pourquoi un L.O.O. ?</a></li>

<li>
<a href="#Heading4">c) avantages - inconv&eacute;nients ?</a></li>

<li>
<a href="#Heading5">d) Pourquoi C++ ?</a></li>
</ul>
</ul>
<a href="#Heading6"><img SRC="bullevar.gif" ALT="*" BORDER=0 height=11 width=15></a>&nbsp;<a href="#Heading6">
2) PREMI&Egrave;RES SP&Eacute;CIFICIT&Eacute;S C++</a>
<ul>
<ul>
<li>
<a href="#Heading7">a) commentaires</a></li>

<li>
<a href="#Heading8">b) entr&eacute;es-sorties (flux)</a></li>

<li>
<a href="#Heading9">c) mot clef const</a></li>

<li>
<a href="#Heading10">d) passage d'arguments par adresse</a></li>

<li>
<a href="#Heading11">e) arguments par d&eacute;faut</a></li>

<li>
<a href="#Heading12">f) r&eacute;solution de port&eacute;e</a></li>
</ul>
</ul>
<a href="#Heading13"><img SRC="bullevar.gif" ALT="*" BORDER=0 height=11 width=15></a>&nbsp;<a href="#Heading13">
3) VOCABULAIRE</a>
<ul>
<ul>
<li>
<a href="#Heading14">a) la classe</a></li>

<li>
<a href="#Heading15">b) l'instance</a></li>

<li>
<a href="#Heading16">c) l'h&eacute;ritage</a></li>

<li>
<a href="#Heading17">d) la surcharge</a></li>

<li>
<a href="#Heading18">e) le constructeur</a></li>
</ul>
</ul>
<a href="#Heading13"><img SRC="bullevar.gif" ALT="*" BORDER=0 height=11 width=15></a>&nbsp;
<a href="#Heading19">4)APPLICATIONS</a>
<ul>
<ul>
<li>
<a href="#Heading20">a)simple</a></li>

<li>
<a href="#Heading21">b) acc&egrave;s aux membres d'une classe</a></li>

<li>
<a href="#Heading22">c) h&eacute;ritage</a></li>

<li>
<a href="#Heading23">d) new, delete</a></li>

<li>
<a href="#Heading24">e) surcharge d'un op&eacute;rateur</a></li>

<li>
<a href="#Heading25">f) classes virtuelles</a></li>

<li>
<a href="#Heading26">g) polymorphisme</a></li>
</ul>
</ul>
<a href="#Heading13"><img SRC="bullevar.gif" ALT="*" BORDER=0 height=11 width=15></a>&nbsp;
<a href="#Heading27">5) EXEMPLE COMPLET (COMMENT&Eacute;)</a>
<p>
<hr size=4>
<center>
<h1>
le C++</h1></center>

<center>
<h2>
Introduction pour qui conna&icirc;t le C</h2></center>
Cette page n'est pas destin&eacute;e au d&eacute;butant. Je suppose que
le lecteur connait bien le C standard (ANSI). Sinon, vous pouvez d'abord
voir <a href="tpc.htm">mon cours C complet</a>. Pour un probl&egrave;me
pr&eacute;cis, allez directement &agrave; son <a href="tpc_i.htm">index</a>.
<h1>
<a NAME="Heading1"></a>1) INTRODUCTION</h1>
Le C++ est LA solution pour passer aux L.O.O. (langages orient&eacute;s
objet) sans trop de probl&egrave;mes.
<h2>
<a NAME="Heading2"></a>a) qu'est-ce qu'un objet ?</h2>
une STRUCTure regroupant des donn&eacute;es et les fonctions pour les manipuler.
<h2>
<a NAME="Heading3"></a>b) pourquoi un L.O.O. ?</h2>
Le passage de l'assembleur aux langages structur&eacute;s a permis d'obtenir
des programmes maintenables : on peut les comprendre, les modifier, les
am&eacute;liorer : on a une structure de programme claire. Par contre si
l'on d&eacute;cide de modifier la structure des donn&eacute;es importantes
(par exemple remplacer le tableau des donn&eacute;es par une liste cha&icirc;n&eacute;e),
il fallait r&eacute;&eacute;crire tout le programme. Les objets structurent
les donn&eacute;es : en changeant la structure d'un objet, il suffit de
modifier ses "m&eacute;thodes" pour que la transformation s'applique &agrave;
tout le programme. La programmation est plus simple, les m&eacute;thodes
(fonctions en C) sont class&eacute;es par types de donn&eacute;es plut&ocirc;t
que s&eacute;quentiellement. De plus elles sont organis&eacute;es hi&eacute;rarchiquement
(arborescence=bidimensionnel plut&ocirc;t que s&eacute;quentiel=lin&eacute;aire).
<h2>
<a NAME="Heading4"></a>c) avantages - inconv&eacute;nients ?</h2>

<ul>
<li>
Programmes plus faciles &agrave; &eacute;crire et &agrave; maintenir. Modification
ais&eacute;e, y compris des types de donn&eacute;es. Modularit&eacute;
accrue (un objet bien d&eacute;fini reservira dans de nombreux programmes)</li>

<li>
Programme r&eacute;sultant (ex&eacute;cutable) un peu moins efficace (plus
gros et moins rapide, mais aujourd'hui le prix de la vitesse et de la m&eacute;moire
est inf&eacute;rieur au co&ucirc;t d'une optimisation de programme, on
n'&eacute;crit plus grand chose en assembleur).</li>
</ul>

<h2>
<a NAME="Heading5"></a>d) Pourquoi C++ ?</h2>
C++ est s&ucirc;rement un mauvais L.O.O. (du point de vue de l'informaticien
puriste), par contre il permet de garder tous les avantages du C : portable,
possibilit&eacute; d'utiliser diff&eacute;rents niveaux d'optimisation
au sein d'un m&ecirc;me programme (objets - langage structur&eacute; classique
- assembleur). Il permet de passer en douceur aux objets, mais surtout
de garder et r&eacute;utiliser toutes les biblioth&egrave;ques existantes.
Bien que plus strict que C, il acceptera &agrave; peu pr&egrave;s tout,
donc sera avare en messages d'erreur de compilation. C'est le programmeur
qui doit se forcer &agrave; programmer "objets", s'il ne le fait pas le
compilateur ne le pr&eacute;vient m&ecirc;me pas. Comme vous le verrez
ici, le passage aux objets (si l'on conna&icirc;t d&eacute;j&agrave; C)
est tr&egrave;s simple.
<h1>
<a NAME="Heading6"></a>2) PREMIERES SPECIFICITES C++</h1>

<h2>
<a NAME="Heading7"></a>a) commentaires</h2>
Les commentaires /* ... */ restent possibles, on y a ajout&eacute; les
commentaires commen&ccedil;ant par // et se finissant &agrave; la fin de
la ligne.
<h2>
<a NAME="Heading8"></a>b) entr&eacute;es-sorties (flux)</h2>
&agrave; condition d'inclure &lt;iostream.h> (et donc pas &lt;stdio.h>),
on peut utiliser cout (pour afficher &agrave; l'&eacute;cran) et cin (pour
lire sur le clavier). Exemple :
<pre><font color="#AAFF33">float P; int Nb;
cout &lt;&lt; "prix unitaire ? ";
cin >> P;
cout &lt;&lt; "Nombre ? ";
cin >> Nb;
cout.precision(2); //manipulateur (fonction membre)de cout : tous les
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //flottants QUI SUIVENT seront affich&eacute;s avec
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2 chiffres apr&egrave;s la virgule
cout &lt;&lt; "prix total : " &lt;&lt; P*Nb &lt;&lt; "F \n";</font></pre>
L'avantage de ces fonctions est qu'elles peuvent &ecirc;tre plus facilement
surcharg&eacute;es que printf et scanf (par exemple &eacute;tendues aux
tableaux). Les flux fstream poss&egrave;dent les m&ecirc;mes fonctionnalit&eacute;s
pour les fichiers (je ne d&eacute;taille pas).
<h2>
<a NAME="Heading9"></a>c) mot clef const</h2>

<pre><font color="#AAFF33">&nbsp;&nbsp;&nbsp; const type var=valeur;</font></pre>
contrairement au #define, permet une analyse syntaxique (on garde les define
pour les "r&eacute;&eacute;critures" et compilations conditionnelles).
<h2>
<a NAME="Heading10"></a>d) passage d'arguments par adresse</h2>
il suffit d'ajouter le signe &amp; dans l'ent&ecirc;te de la fonction (qui
doit &ecirc;tre prototyp&eacute;e avant toute utilisation). Ceci &eacute;vite
l'&eacute;criture "pointeur" tant pour les arguments r&eacute;els que formels
:
<pre><font color="#AAFF33">void echange(int &amp;a, int &amp;b) {int z=a;a=b;b=z;}
int X,Y;echange(X,Y);</font></pre>

<h2>
<a NAME="Heading11"></a>e) arguments par d&eacute;faut</h2>
On peut d&eacute;clarer des valeurs par d&eacute;faut des arguments d'une
fonction (uniquement dans le prototype, pas dans l'ent&ecirc;te). Les arguments
r&eacute;els peuvent &ecirc;tre omis en commen&ccedil;ant par le dernier
(impossible d'omettre les premiers si l'on veut pr&eacute;ciser un suivant).
<h2>
<a NAME="Heading12"></a>f) r&eacute;solution de port&eacute;e</h2>
Si vous disposez de deux (ou plus) entit&eacute;s (donn&eacute;e ou m&eacute;thode)
de m&ecirc;me nom, en C standard seule la plus locale est accessible. <tt>ou::nom</tt>
permet en C++ de pr&eacute;ciser de quel nom on parle (en g&eacute;n&eacute;ral
<tt>ou</tt> correspond &agrave; une classe, <tt>::nom</tt> pour acc&eacute;der
&agrave; une variable globale).
<h1>
<a NAME="Heading13"></a>3) VOCABULAIRE</h1>

<h2>
<a NAME="Heading14"></a>a) la classe</h2>
Une classe est un regroupement de donn&eacute;es et de m&eacute;thodes.
C'est donc une extension des STRUCT du C :
<center>
<p>class MaClasse {d&eacute;claration donn&eacute;es et m&eacute;thodes
} MonInstance;</center>

<p>Ne pas oublier le ; final m&ecirc;me quand on ne d&eacute;clare pas
d'instance ici (en g&eacute;n&eacute;ral les classes sont globales, les
variables devraient plut&ocirc;t &ecirc;tre locales). En fait les mots
clef struct et union permettent &eacute;galement la d&eacute;claration
de m&eacute;thodes en plus de donn&eacute;es, simplement elles sont par
d&eacute;faut publiques (public) (accessibles aux autres classes) alors
que pour une classe elles sont par d&eacute;faut priv&eacute;es (private).
<h2>
<a NAME="Heading15"></a>b) l'instance</h2>
On utilisera le terme "instanciation" &agrave; chaque cr&eacute;ation d'une
instance (ce qu'on appelait avant une variable). L'adresse de l'instance
actuelle est appel&eacute;e "this" (sans avoir &agrave; la d&eacute;clarer).
<h2>
<a NAME="Heading16"></a>c) l'h&eacute;ritage</h2>
les classes sont structur&eacute;es de mani&egrave;re arborescente. Si
l'on cr&eacute;e une classe d'objets A (dite classe de base), on peut cr&eacute;er
une classe B qui "d&eacute;rive" de A : elle en h&eacute;rite toutes les
composantes (donn&eacute;es et m&eacute;thodes). On peut, &agrave; partir
de C++ version 2, utiliser l'h&eacute;ritage multiple (une classe h&eacute;rite
de plusieurs classes de base), alors que ce n'&eacute;tait pas possible
avant.
<h2>
<a NAME="Heading17"></a>d) la surcharge</h2>
On peut d&eacute;crire plusieurs m&eacute;thodes de m&ecirc;me nom, &agrave;
condition que chacune s'applique &agrave; des types de donn&eacute;es diff&eacute;rents.
Par exemple on peut d&eacute;finir <tt>int puissance(int,int)</tt> et <tt>float
puissance(float,float)</tt>, les deux fonctions ayant une impl&eacute;mentation
diff&eacute;rente suivant le type de donn&eacute;es, c'est le compilateur
qui choisira en fonction des types des arguments. On peut m&ecirc;me surcharger
les op&eacute;rateurs classiques du C (red&eacute;finir + pour les vecteurs
par exemple). On ne peut pas surcharger deux fonctions ayant exactement
les m&ecirc;mes types d'arguments mais retournant un type diff&eacute;rent
(produits scalaire et vectoriel par exemple)
<h2>
<a NAME="Heading18"></a>e) le constructeur</h2>
Pour chaque classe, il existe une m&eacute;thode n&eacute;cessaire (mais
non obligatoire, si on ne la d&eacute;finit pas le compilateur en cr&eacute;e
une par d&eacute;faut) : le constructeur. Son nom est toujours le m&ecirc;me
que celui de la classe. Il est appel&eacute; implicitement &agrave; chaque
nouvelle cr&eacute;ation d'instance ou explicitement par la fonction new
(correspond au malloc, mais c'est le compilateur qui d&eacute;termine la
taille n&eacute;cessaire). Le constructeur est une fonction qui ne retourne
rien (m&ecirc;me pas void). Le destructeur est appel&eacute; implicitement
&agrave; la destruction d'un objet ou explicitement par delete. Remarque
: le constructeur peut affecter une valeur &agrave; un membre constant
(mais qui ne pourra pas changer jusqu'&agrave; sa destruction).
<h1>
<a NAME="Heading19"></a>4)APPLICATIONS</h1>

<h2>
<a NAME="Heading20"></a>a)simple</h2>

<pre><font color="#AAFF33">class Point&nbsp;
&nbsp; {
&nbsp;&nbsp;&nbsp; int X;intY; //les donn&eacute;es
&nbsp;&nbsp;&nbsp; int GetX(void) {return X;} // d&eacute;claration "interne" ou "inline"
&nbsp;&nbsp;&nbsp; int GetY(void); // d&eacute;claration externe
&nbsp;&nbsp;&nbsp; Point (int NewX=0, int NewY=0) {X=NewX;Y=NewY;} //d&eacute;claration
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //interne du constructeur, avec initialisation par d&eacute;faut
&nbsp; };
int Point::GetY(void)
&nbsp;&nbsp; {return Y;} //d&eacute;claration "externe", il faut pr&eacute;ciser
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&agrave; quelle classe elle se rapporte ici POINT.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //dans la r&eacute;alit&eacute; j'aurai plutot utilis&eacute; une d&eacute;claration interne</font></pre>
si je d&eacute;clare :
<pre><font color="#AAFF33">&nbsp;&nbsp; Point P(5,10); //appel automatique du constructeur &agrave; lad&eacute;claration
&nbsp;&nbsp; int coordX;</font></pre>
je peux par exemple appeler la fonction (attention, pas n'importe o&ugrave;,
voir paragraphe suivant) :
<pre><font color="#AAFF33">&nbsp;&nbsp; coordX=P.GetX();</font></pre>

<h2>
<a NAME="Heading21"></a>b) acc&egrave;s aux membres d'une classe</h2>
les membres d'une classe peuvent &ecirc;tre
<ul>
<li>
priv&eacute;s (private), c'est &agrave; dire accessible uniquement aux
autres membres de cette classe;</li>

<li>
prot&eacute;g&eacute;s (protected), c'est &agrave; dire accessibles au
membres de la classe et des classes d&eacute;riv&eacute;es;</li>

<li>
publics (public), c'est &agrave; dire accessibles "classiquement" : m&ecirc;me
port&eacute;e qu'une d&eacute;claration classique C</li>
</ul>
Exemple :
<pre><font color="#AAFF33">class Point&nbsp;
&nbsp; {
&nbsp;&nbsp;&nbsp; int X;intY;&nbsp;&nbsp;&nbsp; //priv&eacute; par d&eacute;faut
&nbsp; public :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tout ce qui suit est public
&nbsp;&nbsp;&nbsp; int GetX(void) {return X;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ceci permet d'acc&eacute;der aux
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //infos sans savoir comment elles ont &eacute;t&eacute; stock&eacute;es
&nbsp;&nbsp;&nbsp; int GetY(void) {return Y;}
&nbsp;&nbsp;&nbsp; Point (int NewX, int NewY) {X=NewX;Y=NewY;}
&nbsp; };</font></pre>
On peut utiliser les 3 acc&egrave;s, autant de fois que l'on veut et dans
n'importe que ordre. L'acc&egrave;s qui s'applique est le dernier sp&eacute;cifi&eacute;
(ou celui par d&eacute;faut, private pour class et public pour struct).
<h2>
<a NAME="Heading22"></a>c) h&eacute;ritage</h2>

<pre><font color="#AAFF33">class Point&nbsp;
&nbsp; {
&nbsp; protected: //accessible uniquement par h&eacute;ritage
&nbsp;&nbsp;&nbsp; int X;intY;&nbsp;
&nbsp; public : // accessible partout
&nbsp;&nbsp;&nbsp; int GetX(void) {return X;}
&nbsp;&nbsp;&nbsp; int GetY(void) {return Y;}
&nbsp;&nbsp;&nbsp; Point (int NewX=0, intNewY=0) {X=NewX;Y=NewY;}
&nbsp; };
class Pixel : public Point //d&eacute;rive de point,&nbsp;
&nbsp; {
&nbsp; protected:
&nbsp;&nbsp;&nbsp; int couleur;
&nbsp; public :
&nbsp;&nbsp;&nbsp; Pixel (int nx,int ny,int coul=0);
&nbsp;&nbsp;&nbsp; void allume(void);
&nbsp;&nbsp;&nbsp; void allume(int couleur); //surcharge : on peut allumer avec une autre couleur
&nbsp;&nbsp;&nbsp; void eteind(void);
&nbsp; };</font></pre>
Les acc&egrave;s d&eacute;riv&eacute;s sont le plus restrictif entre celui
d&eacute;fini dans la classe de base et celui pr&eacute;cis&eacute; lors
de la d&eacute;rivation (ici d&eacute;rivation publique, les acc&egrave;s
restent inchang&eacute;s sauf pour les priv&eacute;s qui sont inaccessibles).
<pre><font color="#AAFF33">Pixel::Pixel(int nx,int ny,int coul):Point(nx,ny) // je pr&eacute;cise la
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //liste (s&eacute;par&eacute;e par des virgules) des constructeurs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(sinon val par d&eacute;faut), je n'ai plus qu'&agrave; construire les&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ajouts par rapport &agrave; la classe de base
&nbsp; {couleur=coul;}
void Pixel::allume(void)&nbsp;
&nbsp; {g_pixel(X,Y,couleur);} //g_pixel : une fonction qui allume un pixel &agrave; l'&eacute;cran
void Pixel::allume(int coul)&nbsp;
&nbsp; {g_pixel(X,Y,couleur=coul);}
void Pixel::eteind(void)&nbsp;
&nbsp; {allume(0);}</font></pre>
On pourrait maintenant d&eacute;finir une classe segment contenant un pixel
et un point (la couleur n'a besoin d'&ecirc;tre stock&eacute;e qu'une fois).
On red&eacute;finirait des m&eacute;thodes de m&ecirc;me nom : Segment::allume...
<h2>
<a NAME="Heading23"></a>d) new, delete</h2>

<pre><font color="#AAFF33">&nbsp; Pixel *ptrPixel = new Pixel(100,100,1); // construction explicite
&nbsp; ptrPixel->allume(); //utilisation
&nbsp; delete ptrPixel; //destruction, le destructeur par d&eacute;faut est souvent suffisant</font></pre>
Si l'on veut d&eacute;finir explicitement le destructeur d'une classe (pour
fermer un fichier par exemple), on utilise le nom de la classe pr&eacute;c&eacute;d&eacute;
de ~ :
<pre><font color="#AAFF33">Point::~Point() {...}</font></pre>

<h2>
<a NAME="Heading24"></a>e) surcharge d'un op&eacute;rateur</h2>
utilisons le signe + pour additionner deux Points (par adresse pour &eacute;viter
de recopier en local):
<pre><font color="#AAFF33">Point operator+ (Point &amp;P1, Point &amp;P2)
&nbsp; { Point res(P1.GetX()+P2.GetX(),P1.GetY()+P2.GetY(),P1);
&nbsp;&nbsp;&nbsp; return res;}</font></pre>
On peut aussi surcharger &lt;&lt; (pour cout) :
<pre><font color="#AAFF33">ostream&amp; operator &lt;&lt; (ostream&amp; flux, Point&amp; P)
&nbsp; { flux &lt;&lt; "[" &lt;&lt; P.GetX() &lt;&lt; "," &lt;&lt; P.GetY() &lt;&lt; "]";&nbsp;
&nbsp;&nbsp;&nbsp; return flux;
&nbsp; }</font></pre>
Ces deux surcharges sont globales. Mais on peut &eacute;galement les d&eacute;finir
comme fonctions membres :
<pre><font color="#AAFF33">class Point {
&nbsp; .....
&nbsp; Point operator + (Point &amp;P);
&nbsp; Point operator = (Point &amp;P);
};
Point::Point::operator + (Point &amp; P)
&nbsp; {Point r;r.X=this->X+P.X;r.Y=this->Y+P.Y;return r;}
void main(void) {
&nbsp; Point A,B,C;
&nbsp; A=B; //appelle A.operator=(B)
&nbsp; B+C; //appelle A.operator+(B)
&nbsp; A=B+C; //marchera aussi, mais A=B=C je n'en suis pas sur
&nbsp; }</font></pre>

<h2>
<a NAME="Heading25"></a>f) classes virtuelles</h2>
Soient : une classe A, deux classes B et C d&eacute;rivant de A, une classe
D d&eacute;rivant de B et C. Nous aurons dans D deux instances de A (qui
peuvent &ecirc;tre diff&eacute;rentes). Mais si une seule instance de A
suffisait, il suffit de les d&eacute;clarer :
<pre><font color="#AAFF33">class A {...};
class B : virtual public A {...};
class C : virtual public A {...};
class D : public C, public D {...};</font></pre>
Le constructeur de D appellera une seule fois celui de A
<h2>
<a NAME="Heading26"></a>g) polymorphisme</h2>
Si plusieurs classes (point, ligne, segment) poss&egrave;dent des m&eacute;thodes
de m&ecirc;me signature (&eacute;criture similaire du prototype), on peut
&eacute;viter de r&eacute;&eacute;crire des fonctions dont le contenu serait
identique mais d'appliquant &agrave; des objets diff&eacute;rents (d&eacute;placer=&eacute;teindre+ajouter+allumer
pout tous mes objets). On peut pour cela utiliser les fonctions virtuelles
(dynamiques : le choix de la fonction a utiliser est d&eacute;termin&eacute;e
&agrave; l'ex&eacute;cution) ou les fonctions templates (statiques : le
choix des fonctions est fait &agrave; la compilation). Voyez l'exemple
complet.
<h1>
<a NAME="Heading27"></a>5) EXEMPLE COMPLET (comment&eacute;)</h1>

<pre><font color="#AAFF33">#include &lt;iostream.h>
#include "graphiq0.cpp"&nbsp; // petite biblio graphique. contient g_init,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // g_fin, g_pixel, g_ligne (voir plus loin)

class Point
&nbsp; {
&nbsp; protected: //accessible uniquement par h&eacute;ritage
&nbsp;&nbsp;&nbsp; int X;int Y;
&nbsp; public : // accessible partout
&nbsp;&nbsp;&nbsp; int GetX(void) {return X;}&nbsp; //hors h&eacute;ritage on ne peut que lire,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pas &eacute;crire
&nbsp;&nbsp;&nbsp; int GetY(void) {return Y;}
&nbsp;&nbsp;&nbsp; Point (int NewX=0, int NewY=0) {X=NewX;Y=NewY;}
&nbsp; };

//On peut surcharger &lt;&lt; (pour cout) : marche pour le point et ses h&eacute;ritiers :
ostream&amp; operator &lt;&lt; (ostream&amp; flux, Point&amp; P)
&nbsp; { flux &lt;&lt; "[" &lt;&lt; P.GetX() &lt;&lt; "," &lt;&lt; P.GetY() &lt;&lt; "]";
&nbsp;&nbsp;&nbsp; return flux;
&nbsp; }

class Pixel : public Point //d&eacute;rive de point
&nbsp; {
&nbsp; protected:
&nbsp;&nbsp;&nbsp; int couleur;
&nbsp; public :
&nbsp;&nbsp;&nbsp; Pixel (int nx=0,int ny=0,int coul=0);
&nbsp;&nbsp;&nbsp; virtual void allume(void);
&nbsp;&nbsp;&nbsp; virtual void allume(int couleur); //surcharge : on peut allumer avec une autre couleur
&nbsp;&nbsp;&nbsp; void eteind(void);&nbsp;&nbsp;&nbsp;&nbsp; // h&eacute;ritable dynamiquement
&nbsp;&nbsp;&nbsp; void ajoute(int plusx=1,int plusy=1);
&nbsp;&nbsp;&nbsp; void deplace(int plusx=1,int plusy=1);// h&eacute;ritable dynamiquement
&nbsp;&nbsp;&nbsp; int GetCouleur(void);
&nbsp; };

Pixel::Pixel(int nx,int ny,int coul):Point(nx,ny) //je passe ainsi les
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // arguments au constructeur de Point (sinon il prend
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // celui par d&eacute;faut, cad sans arguments
&nbsp; {couleur=coul;}
void Pixel::allume(void)
&nbsp; {g_pixel(X,Y,couleur);}
void Pixel::allume(int coul)
&nbsp; {g_pixel(X,Y,couleur=coul);}
void Pixel::eteind(void)
&nbsp; {allume(0);}&nbsp;&nbsp; //allume est virtuelle, toute classe d&eacute;riv&eacute;e
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //poss&eacute;dant allume poss&egrave;dera automatiquement &eacute;teint
void Pixel::ajoute(int plusx,int plusy)
&nbsp; {X+=plusx;Y+=plusy;}
void Pixel::deplace(int plusx,int plusy)
&nbsp; { int OldCol=couleur;eteind();couleur=OldCol;
&nbsp;&nbsp;&nbsp; ajoute(plusx,plusy);allume();}
int Pixel::GetCouleur(void)
&nbsp; {return couleur;}

class Segment : public Pixel
&nbsp; {
&nbsp; protected :
&nbsp;&nbsp;&nbsp; int LX;int LY;
&nbsp; public :
&nbsp;&nbsp;&nbsp; Segment (int x0=0,int y0=0,int lx=0,int ly=0,int coul=1);
&nbsp;&nbsp;&nbsp; void allume(void);
&nbsp;&nbsp;&nbsp; void allume(int couleur);&nbsp;
&nbsp;&nbsp;&nbsp; //le reste est h&eacute;rit&eacute;
&nbsp; };

Segment::Segment(int x0,int y0,int lx,int ly,int coul):Pixel(x0,y0,coul)
&nbsp; {LX=lx;LY=ly;}
void Segment::allume(void)
&nbsp; {g_ligne(X,Y,X+LX,Y+LY,couleur);}
void Segment::allume(int coul)
&nbsp; {g_ligne(X,Y,X+LX,Y+LY,couleur=coul);}

class Rectangle : public Pixel
&nbsp; {
&nbsp; protected :
&nbsp;&nbsp;&nbsp; int LX;int LY;
&nbsp; public :
&nbsp;&nbsp;&nbsp; Rectangle (int x0=0,int y0=0,int lx=0,int ly=0,int coul=1);
&nbsp;&nbsp;&nbsp; void allume(void);
&nbsp;&nbsp;&nbsp; void allume(int couleur);&nbsp;
&nbsp; };

Rectangle::Rectangle(int x0,int y0,int lx,int ly,int coul):Pixel(x0,y0,coul)
&nbsp; {LX=lx;LY=ly;}
void Rectangle::allume(void)
&nbsp; {
&nbsp;&nbsp; g_ligne(X,Y,X+LX,Y,couleur);
&nbsp;&nbsp; g_ligne(X+LX,Y,X+LX,Y+LY,couleur);
&nbsp;&nbsp; g_ligne(X+LX,Y+LY,X,Y+LY,couleur);
&nbsp;&nbsp; g_ligne(X,Y+LY,X,Y,couleur);
&nbsp; }
void Rectangle::allume(int coul)
&nbsp; {couleur=coul;this->allume();}

//utilisons le signe + pour additionner deux objets quels qu'ils soient:
template &lt;class T> //T est un type de classe "variable"
T operator+ (T &amp;P1,Point &amp;P2)
&nbsp; {T res(P1.GetX()+P2.GetX(),P1.GetY()+P2.GetY(),P1);return res;}
// ce qui ne marche pas pour les types autres que point : le constructeur
// prend les autres arguments par d&eacute;faut (longueur, couleur)

void main(void)
&nbsp;{
&nbsp; g_init();
&nbsp; Pixel *ptrPixel = new Pixel(100,100,1);
&nbsp; ptrPixel->allume(); //utilisation
&nbsp; cout &lt;&lt; *ptrPixel &lt;&lt; ':' &lt;&lt; ptrPixel->GetCouleur()&lt;&lt; '\n';
&nbsp; delete ptrPixel; //destruction, le destructeur par d&eacute;faut est souvent suffisant
&nbsp; Segment s(50,50,100,0,10);
&nbsp; s.allume();
&nbsp; Rectangle r(150,150,100,100,4);
&nbsp; r.allume();
&nbsp; cin.get();&nbsp; //&eacute;quivalent du getch
&nbsp; Point decal(-25,25);
&nbsp; cout &lt;&lt; (s+decal) &lt;&lt; endl;
&nbsp; (r+decal).allume();
&nbsp; s.deplace(0,100);
&nbsp; r.deplace(0,100);
&nbsp; cout &lt;&lt; r &lt;&lt; endl; //endl envoie un \n
&nbsp; cin.get();
&nbsp; g_fin();
&nbsp;}</font></pre>

<hr><b>----------- La biblioth&egrave;que graphique pour Tubo C (DOS) -
Graphiq0.cpp -----------&nbsp;</b>
<hr>
<pre><font color="#AAFF33">/* fichier inclus pour INTRO.CPP, version Turbo C 3.0 P.Trau 22/2/97 */

/* biblioth&egrave;que graphique minimale . Ce fichier contient les fonctions
&nbsp;&nbsp; qu'il faudra r&eacute;&eacute;crire si l'on change de compilateur. Il faut savoir :
&nbsp;&nbsp; - passer en mode graphique : g_init (sauf si vous y &ecirc;tes d&eacute;j&agrave;)
&nbsp;&nbsp; - quitter le mode graphique : g_fin
&nbsp;&nbsp; - allumer un point : g_pixel
&nbsp;&nbsp; - &agrave; la rigueur tracer une ligne : g_ligne (ou le laisser tel quel,
&nbsp;&nbsp;&nbsp;&nbsp; il n'utilise que g_pixel)
*/

#include &lt;graphics.h>

#define abs(X) ((X>0)?(X):(-(X)))

void g_init(void)
&nbsp;{
&nbsp; int gdriver = DETECT, gmode, errorcode;
&nbsp; initgraph(&amp;gdriver, &amp;gmode, "");
&nbsp; errorcode = graphresult();
&nbsp; if (errorcode != grOk)
#ifdef __cplusplus
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "g_erreur: " &lt;&lt; grapherrormsg(errorcode) &lt;&lt;"\n";
#else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("g_erreur: %s\n", grapherrormsg(errorcode));
#endif
&nbsp; setcolor(getmaxcolor());
&nbsp;}

void g_fin(void)
&nbsp;{closegraph();}

void g_pixel(int x,int y,int color)
&nbsp;{putpixel(x,y,color);}

void g_ligne(int xd,int yd,int xf,int yf,int color)
&nbsp;{
&nbsp; int somme,pasx,pasy,deltax,deltay;
&nbsp; deltax=abs(xf-xd);deltay=abs(yf-yd);
&nbsp; pasx=(xd&lt;xf)?1:-1;
&nbsp; pasy=(yd&lt;yf)?1:-1;
&nbsp; g_pixel(xd,yd,color);
&nbsp; if (deltax>deltay) /* ils sont d&eacute;j&agrave; positifs */
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; somme=deltax/2;
&nbsp;&nbsp;&nbsp; while(xd!=xf)
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xd+=pasx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; somme+=deltay;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(somme>=deltax) {somme-=deltax;yd+=pasy;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pixel(xd,yd,color);
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; }
&nbsp; else
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; somme=deltay/2;
&nbsp;&nbsp;&nbsp; while(yd!=yf)
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yd+=pasy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; somme+=deltax;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(somme>=deltay) {somme-=deltay;xd+=pasx;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pixel(xd,yd,color);
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; }
&nbsp;}</font></pre>

<hr size=4>
<br>&nbsp;
<br>&nbsp;
</body>
</html>
