<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0056)http://perso.wanadoo.fr/carlov/cours/chap2/tableaux.html -->
<HTML><HEAD><TITLE>La Programmation en C++ - Les tableaux</TITLE>
<META http-equiv=content-type content=text/html;charset=iso-8859-1>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY bgColor=white><FONT size=7><B><A name=page_top></A>Les tableaux</B></FONT> 

<DIV align=right>
<P><A 
href="http://perso.wanadoo.fr/carlov/src/Tableau.cpp">tableau.cpp</A></P></DIV>
<P>
<HR>

<P></P>
<P>Bonjour, bonjour.&nbsp;Aujourd'hui, nous abordons le second chapitre avec les 
<I><B>tableaux</B></I>.&nbsp;Qu'est-ce que c'est quoi donc? Rassurez-vous, nous 
n'allons pas nous mettre à peindre quoi que ce soit. Un tableau en C/C++ est une 
liste d'un certain nombre de valeurs du même type. Imaginons par exemple que 
nous voulions enregistrer les 20 derniers relevés de température.&nbsp;Une 
température peut être représentée par un <TT><B>float</B></TT>, et toutes ces 
températures forment un ensemble.&nbsp;On va donc les caser dans un tableau, où 
elles seront toutes rassemblées de manières cohérentes.</P>
<P>Il faudrait voir un tableau comme une famille de variables du même type, 
d'une taille prédéfinie à l'avance. Ces variables portent toutes le même nom, 
mais sont différenciées par leur place dans le tableau. Regardez plutôt :</P>
<DIV align=left>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>float</B> temp[20];<BR>temp[0] = 17.5;<BR>temp[1] = 
      20.3;<BR>temp[2] = 13.9;<BR><FONT color=gray><I>/* ... 
      */</I></FONT><BR>temp[19] = 15.7;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>La première ligne définit un tableau de 20 variables de type 
<TT><B>float</B></TT>.&nbsp;Le tableau portera le nom <TT>temp</TT>. Ensuite, 
chaque élément de ce tableau est repéré par son indice dans le tableau, <B>les 
indices commençant toujours à 0</B>. Donc dans notre tableau de 20 éléments, on 
a les variables de type <TT><B>float</B></TT> numérotés de <TT>temp[0]</TT> à 
<TT>temp[19]</TT>. On peut alors considérer <TT>temp[?]</TT> comme une variable 
normale, à laquelle on peut affecter une valeur et sur laquelle on peut 
effectuer des opérations. Ainsi, je peux très bien écrire quelque chose comme 
:</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT>temp[5] = (temp[4] +&nbsp;1) 
  /&nbsp;2;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>où <TT>temp[5]</TT> et <TT>temp[4]</TT> sont deux variables comme les autres, 
à la différence près que celles-ci, en plus de leur nom, sont caractérisées par 
un indice.</P>
<P>En mémoire, toutes ces 20 variables sont contigues, c'est-à-dire qu'elles 
sont placées les unes à la suite des autres. Un tableau de <TT>n</TT> éléments 
du type <TT><B>type</B></TT> occupe donc en mémoire 
<TT>n*<B>sizeof</B>(<B>type</B>)</TT> octets.</P></DIV>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center align=middle width=40><IMG height=48 
      src="La Programmation en C++ - Les tableaux_fichiers/exclaR.gif" 
    width=19></TD>
    <TD vAlign=center bgColor=#ffe4e1>
      <UL>Lorsque vous précisez le nombre d'éléments d'un tableau en le 
        déclarant, la valeur doit être une <B>constante entière</B>.&nbsp;Vous 
        ne pouvez pas créer un tableau à partir d'une valeur de variable. 
  </UL></TD></TR></TBODY></TABLE>
<P></P>
<DIV align=left>
<P><FONT size=5><B>Initialisation</B></FONT></P>
<P>Par défaut, les éléments d'un tableau sont initialisés à 0 lors de la 
création du tableau. Mais parfois, on veut créer un tableau contenant des 
valeurs prédéfinies. Il existe une syntaxe plus rapide que la méthode utilisée 
dans notre premier exemple.&nbsp;Voyons un exemple :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> premiers[5] = {2, 3, 5, 7, 
    11};</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Ce tableau contient 5 <TT><B>int</B></TT> représentant des nombres 
premiers.&nbsp;Comme on connaît les 5 premiers nombres premiers, on peut 
initialiser directement le tableau avec ces valeurs. En fait, si on utilise 
cette syntaxe, on n'a pas besoin de spécifier le nombre d'éléments qu'on veut 
mettre dans le tableau : si on indique 5 valeurs initiales, c'est <I>à 
priori</I> qu'on veut avoir 5 éléments.&nbsp;Le compilateur crée alors un 
tableau à 5 éléments, initialisés aux valeurs données entre accolades.&nbsp;La 
déclaration suivante fait exactement la même chose que la précédente :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> premiers[] = {2, 3, 5, 7, 
  11};</TT></DIV></TD></TR></TBODY></TABLE>
<P></P></DIV>
<P>Mais le nombre de valeurs précisées entre accolades ne doit pas forcément 
être le même que le nombre d'éléments dans le tableau.&nbsp;Autrement dit, vous 
n'êtes pas obligé de préciser de valeurs pour tous les éléments du 
tableau.&nbsp;Si il y a moins de valeurs dans la liste entre accolades que dans 
le tableau, ces valeurs seront appliquées aux premiers éléments du tableau, les 
éléments restant étant bien sûr initialisés à 0 :</P>
<DIV align=left>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> premiers[5] = {2, 3, 
      5};<BR><B>for</B>(<B>int</B> i = 0; i &lt;= 4; i++) cout &lt;&lt; 
      premiers[i] &lt;&lt; endl;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Cet exemple produit l'affichage suivant :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" bgColor=black border=3>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><FONT 
      color=silver><TT>2<BR>3<BR>5<BR>0<BR>0</TT></FONT></DIV></TD></TR></TBODY></TABLE>
<P></P></DIV>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center align=middle width=40><IMG height=48 
      src="La Programmation en C++ - Les tableaux_fichiers/exclaR.gif" 
    width=19></TD>
    <TD vAlign=center bgColor=#ffe4e1>
      <DIV align=left>
      <UL>Par contre, l'inverse n'est pas possible : vous ne pouvez pas 
        préciser plus de valeurs entre accolades qu'il n'y en a dans le tableau. 

        <P>
        <TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=3>
          <TBODY>
          <TR>
            <TD>
              <DIV align=left><TT><B>int</B> premiers[5] = {2, 3, 5, 7, 11, 13, 
              17};</TT></DIV></TD></TR></TBODY></TABLE>
        <P></P>
        <P>Si vous tentez de compiler cet exemple, le compilateur vous dira 
        quelque chose comme <FONT color=red><TT>Too many 
        initializers</TT></FONT>, soit trop de valeurs initiales. 
    </P></UL></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>On retiendra que si un nombre d'éléments est précisé dans la déclaration d'un 
tableau et que des valeurs initiales sont données entre accolades, le nombre de 
valeurs initiales doit être inférieur ou égal au nombre d'éléments du 
tableau.</P>
<P><FONT size=5><B>Les avantages des tableaux</B></FONT></P>
<P>Les avantages des tableaux ne sont pas immédiats à voir mais ils sont 
réels.&nbsp;Un tableau est la plupart du temps utilisé pour contenir un ensemble 
de valeurs qui vont subir plus ou moins les mêmes traitement.&nbsp;Il est 
complètement intutile de créer un tableau pour contenir des valeurs qui n'ont 
rien à voir les unes avec les autres, comme par exemple le nombre de voitures 
vendues dans le monde l'an dernier, l'âge du capitaine et le vitesse en MHz de 
votre processeur : ces valeurs n'ont rien en commun et vous n'en utiliserez pas 
2 de la même façon.&nbsp;Il est donc inutile de faire un tableau pour 
cela.&nbsp;Par contre, un tableau peut servir à regrouper les notes d'un élève, 
ou des températures enregistrées tous les mois, ou encore les différents prix 
d'un produit au cours du temps.&nbsp;Le traitement appliqué à l'un des éléments 
du tableau peut alors être appliqué à tous les autres éléments, et le résultat 
obtenu aura la même signification.</P>
<P>Aujourd'hui, nous sommes obligés de dire que les tableaux doivent être 
déclarés avec un nombre fixé de valeurs, car il nous manque quelques 
connaissances.&nbsp;Plus tard (dans pas trop longtemps, lorsque nous parlerons 
de la gestion dynamique de la mémoire), nous verrons qu'il est possible de créer 
des tableaux de tailles non définies à l'avance, c'est-à-dire avec des valeurs 
variables, ce qui nous donnera encore plus de flexibilité.&nbsp;On constatera 
alors qu'il est aussi aisé de manipuler un tableau de 5 éléments qu'un tableau 
de 5000 éléments.</P>
<P>Comme les valeurs d'un tableau sont indexées par un entier, tout traitement 
collectif de ces valeurs peut se faire grâce à une boucle, comme le montre l'un 
des exemples précédents où nous affichions les valeurs d'un tableau une à une. 
Ainsi, quelque soit la taille du tableau, on peut utiliser une simple boucle 
pour travailler dessus.&nbsp;Imaginez la galère que ce serait si on avait 500 
variables différentes et qu'on devait en faire la somme puis le produit!!! Avec 
un tableau de 500 éléments, ces calculs sont immediats :</P>
<DIV align=left>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>const int</B> NB_VALEURS = 500;<BR><B>int</B> 
      valeurs[NB_VALEURS];<BR><FONT color=gray><I>/*&nbsp;Initialisation des 
      valeurs<BR>(par saisie ou par calcul direct) */</I></FONT><BR><B>int</B> 
      somme = 0;<BR><B>int</B> produit = 1;</TT> 
      <P><TT><B>for</B>(<B>int</B> i = 0; i &lt; NB_VALEURS; i++)<BR>{</TT></P>
      <UL>
        <P><TT>somme += valeurs[i];<BR>produit *= valeurs[i];</TT></P></UL>
      <P><TT>}</TT></P></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Avouez que c'est facile, non?</P>
<P>Parfois, on se sert de tableaux pour stocker des valeurs précalculées, afin 
d'accélere un peu la vitesse d'exécution d'un programme.&nbsp;Par exemple, les 
calculs mettant en jeu les fonctions <TT>sin()</TT> et <TT>cos()</TT> (définies 
dans <TT>math.h</TT>) sont très longs, mais on en a souvent besoin d'en faire 
beaucoup lorsqu'on fait de la 3D par exemple.&nbsp;On peut alors créer deux 
tableaux <TT>tblSin[]</TT> et <TT>tblCos[]</TT> dans lesquels ont place toutes 
les valeurs de sin et de cos dont on aura besoin, et ainsi on peut les récuperer 
infiniment plus vite qu'en refaisant le calcul à chaque fois.&nbsp;On dit alors 
que ce sont des <I>lookup tables</I>.&nbsp;C'est une des nombreuses techniques 
qu'on utilise pour optimiser la vitesse d'exécution d'un programme, et je ne 
vous en parle qu'à titre indicatif : nous ne nous préocuperons pas de la vitesse 
de nos programme dans ce cours, car ce n'est ni nécessaire, ni simple. C'était 
juste pour vous donner encore un exemple d'avantages que peut représenter le 
tableau.</P>
<P>L'un des inconvénients du tableau est qu'il n'y a pas de moyen immédiat de 
connaître son nombre d'éléments. Ici, on a définit une constante pour fixer le 
nombre d'éléments du tableau, mais ce n'est pas toujours le cas. Par contre, il 
existe un moyen détourné.&nbsp;Prenons le tableau ci-dessus : il y a 
500&nbsp;<TT><B>int</B></TT>s, donc le tableau prend 500*4 octets (voir <A 
href="http://perso.wanadoo.fr/carlov/cours/annexes/types.html">Les types de 
variables</A> si ce n'est pas clair). L'opérateur <TT><B>sizeof</B></TT> permet 
de connaître la taille du tableau en octets, ainsi que la taille d'un 
<TT><B>int</B></TT>.&nbsp;On obtient alors le nombre d'éléments du tableau en 
faisant la division de l'un par l'autre :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> tableau[14];<BR>cout &lt;&lt; <FONT 
      color=blue>"Nombre d'éléments : "</FONT> &lt;&lt; (<B>sizeof</B>(tableau) 
      /&nbsp;<B>sizeof</B>(<B>int</B>)) &lt;&lt; 
endl;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P><FONT size=5><B>Tableaux à plusieurs dimensions</B></FONT></P>
<P>Dans une certaine mesure, <I>tableau</I> peut-être considéré comme un type en 
lui-même. Pourquoi alors ne pas faire un tableau de tableaux? Imaginons que nous 
sommes en train d'écrire un petit programme qui affiche une image. Une image est 
un quadrillage dont chaque point est défini par deux coordonnées et une couleur. 
Nous dirons que les couleurs sont codées sur des <TT><B>int</B></TT>. Notre 
image aura pour dimensions 50*25, c'est-à-dire 50 colonnes et 25 rangées, ou 
encore un tableau de 50 tableaux de 25 éléments chacuns.&nbsp;Ce n'est pas clair 
?</P>
<P>Dans un tableau d'entiers, chaque élément est un entier. On identifie chaque 
élément de la sorte : <TT>tabl[i]</TT>. Ici, tabl[i] est un entier. Si 
maintenant on crée un tableau de tableaux d'entiers, chaque élément est un 
tableau.&nbsp;On identifie alors chaque élément de la même façon, c'est-à-dire 
avec <TT>tabl[i]</TT>, à part que cette fois-ci, <TT>tabl[i]</TT> est un 
tableau, contenant lui-même des entiers. Prenons le premier tableau 
d'entiers.&nbsp;Il s'appelle <TT>tabl[0]</TT>.&nbsp;Le premier élément de ce 
tableau s'appelle alors, tout naturellement,<TT> tabl[0][0]</TT>. Le troisième 
entier du sixième tableau s'appelle, de la même façon, <TT>tabl[5][2]</TT>.</P>
<P>Imaginer des tableaux de tableaux n'est pas facile, surtout lorsqu'on arrive 
aux tableaux de tableaux de tableaux... et on peut continuer. Pour des tableaux 
de dimensions 2 ou 3, on peut imaginer qu'ils représentent un plan ou un espace, 
et que chaque élément de ces tableaux sont repérés par leurs coordonnées (2 dans 
un plan, 3 dans un espace). Si on revient à notre image à dessiner, on peut très 
bien utiliser deux coordonnées pour placer un point. On fera alors :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> image[50][25];<BR>image[13][10] = 
      COULEUR_ROUGE;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>On crée un plan de dimensions 50*25, chaque case contenant un 
<TT><B>int</B></TT>, et après on décide que la case <TT>(13, 10)</TT> contient 
du rouge (en supposant qu'il y ait une constante <TT>COULEUR_ROUGE</TT> définie 
quelque part avant).</P>
<P>Un autre exemple : on veut maintenant créer un jeu de dames.&nbsp;Il y a un 
damier de 8 cases sur 8, avec des cases noires et des cases blanches. Supposons 
que 0 signifie noir, 1 signifie blanc, voici comment déclarer et initialiser 
notre damier :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> damier[8][8];<BR><B>for</B>(<B>int</B> x = 
      0; x &lt; 8; x++)</TT> 
      <UL>
        <P><TT><B>for</B>(<B>int</B> y = 0; y &lt; 8; y++)</TT></P>
        <UL>
          <P><TT>damier[x][y] = (x +&nbsp;y) %&nbsp;2;</TT> 
  </P></UL></UL></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>On aura alors un cadrillage comme il faut. Il existe, pour initialiser un 
tableau à deux dimensions, une syntaxe similaire à celle de l'initialisation 
d'un simple tableau. Prenons comme exemple un tableau d'entiers de 3*3 :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> tabl[3][3] = {{4, 3, 6},{10, 0, 0},{-1, 5, 
      3}};</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Voici le tableau créé par cette ligne :</P>
<P>
<TABLE cellSpacing=2 cellPadding=0 border=4>
  <TBODY>
  <TR>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>4</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>10</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>-1</TT></TD></TR>
  <TR>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>3</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>0</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>5</TT></TD></TR>
  <TR>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>6</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>0</TT></TD>
    <TD align=middle width=16 bgColor=#e6e6fa><TT>3</TT></TD></TR></TBODY></TABLE>
<P></P>
<P>où <TT>tabl[2][1] == 5</TT>.</P>
<P><FONT size=5><B>Affichage</B></FONT></P>
<P>Vous savez maintenant qu'une variable de type fondamental peut être affichée 
avec <TT>cout</TT>. Mais pour afficher un tableau, il n'y a pas de moyen 
prédéfini, il faut donc le faire soi-même.&nbsp;Pour l'exemple on utilisera le 
tableau définit ci-dessus.</P>
<P>Nous avons vu qu'il y avait des caractères spéciaux qui, lors de l'affichage, 
permettaient de contrôler un peu celui-ci. Ainsi, le caractère <FONT 
color=blue><TT>'\n'</TT></FONT> permet de revenir à la ligne.&nbsp;Aujourd'hui, 
je vais introduire le caractère <FONT color=blue><TT>'\t'</TT></FONT> qui permet 
de faire une tabulation, et donc de faire des colonnes. Voici un moyen 
d'afficher joliment le tableau ci-dessus :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> tabl[3][3] = {{4, 3, 6},{10, 0, 0},{-1, 5, 
      3}};</TT> 
      <P><TT><B>for</B>(<B>int</B> y = 0; y &lt; 3; y++)<BR>{</TT></P>
      <UL>
        <P><TT><B>for</B>(<B>int</B> x = 0; x &lt; 3; x++)</TT></P>
        <UL>
          <P><TT>cout &lt;&lt; tabl[x][y] &lt;&lt; <FONT 
          color=blue>'\t'</FONT>;</TT></P></UL></UL>
      <UL>
        <P><TT>cout &lt;&lt; endl;</TT></P></UL>
      <P><TT>}</TT></P></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Voici l'affichage produit par ce programme :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" bgColor=black border=3>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left>
      <TABLE cellSpacing=0 cellPadding=0 width="100%" bgColor=black border=0>
        <TBODY>
        <TR>
          <TD width="10%">
            <DIV align=left><FONT color=silver><TT>4</TT></FONT></DIV></TD>
          <TD width="10%"><FONT color=silver><TT>10</TT></FONT></TD>
          <TD width="80%"><FONT color=silver><TT>-1</TT></FONT></TD></TR>
        <TR>
          <TD width="10%"><FONT color=silver><TT>3</TT></FONT></TD>
          <TD width="10%"><FONT color=silver><TT>0</TT></FONT></TD>
          <TD width="80%"><FONT color=silver><TT>5</TT></FONT></TD></TR>
        <TR>
          <TD width="10%"><FONT color=silver><TT>6</TT></FONT></TD>
          <TD width="10%"><FONT color=silver><TT>0</TT></FONT></TD>
          <TD width="80%"><FONT 
      color=silver><TT>3</TT></FONT></TD></TR></TBODY></TABLE></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Le caractère tabulation permet donc d'aligner verticalement tous les nombres. 
Bien sûr, rien ne vous empêche d'afficher votre tableau autrement, ceci n'est 
qu'une proposition.</P>
<P><FONT size=5><B>Un tableau comme argument d'une fonction</B></FONT></P>
<P>Bien sûr, au même titre que les autres types de variables, vous pouvez passer 
un tableau comme argument d'une fonction :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>void</B> AfficheTableau(<B>int</B> tableau[], 
      <B>int</B> n)<BR>{</TT> 
      <UL>
        <P><TT><B>for</B>(<B>int</B> i = 0; i &lt; n; i++)<BR>{</TT></P>
        <UL>
          <P><TT>cout &lt;&lt; tableau[i] &lt;&lt; <FONT 
          color=blue>'\t'</FONT>;<BR><B>if</B>(i%5 == 4) cout &lt;&lt; 
          endl;</TT></P></UL></UL>
      <UL>
        <P><TT>}</TT></P></UL>
      <P><TT>}</TT></P>
      <P><TT><B>int</B> main(<B>void</B>)<BR>{</TT></P>
      <UL>
        <P><TT><B>int</B> table[100];<BR><B>for</B>(<B>int</B> i =&nbsp;0; i 
        &lt; 100; i++)</TT></P>
        <UL>
          <P><TT>table[i] = i*i;</TT></P></UL></UL>
      <UL>
        <P><TT>AfficheTableau(table, 100);</TT></P></UL>
      <P><TT>}</TT></P></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Ce petit programme affiche sur 5 colonnes les valeurs du tableau 
<TT>table</TT> grâce à la fonction <TT>AfficheTableau()</TT>, qui prend comme 
paramètre un tableau d'entiers et la taille du tableau (le nombre d'éléments 
qu'il contient).&nbsp;Dans la fonction <TT>AfficheTableau()</TT>, vous ne pouvez 
pas savoir la taille du tableau grâce à l'opérateur <TT><B>sizeof</B></TT>, vous 
devez donc passer comme argument sa taille.&nbsp;</P>
<P><FONT size=5><B>Lecture/écriture en dehors des limites d'un 
tableau</B></FONT></P>
<P>Que se passe-t-il si on fait référence à une case d'un tableau lorsque 
celle-ci n'est plus dans les limites du tableau ?</P>
<P>Le C, créé à la base pour faire des programmes rapides (et ainsi remplacer 
dans une certaine mesure l'assembleur), ainsi que le C++, ne font absolument 
aucune vérification concernant les tableaux lors de l'exécution et de la 
compilation d'un programme.&nbsp;Ainsi, vous pouvez impunément écrire quelque 
chose du genre :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>int</B> tabl[3] = {2, 3, 4};<BR>cout &lt;&lt; 
      tabl[3] &lt;&lt; endl;<BR>tabl[4] = 7;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Manifestement, <TT>tabl[3]</TT> et <TT>tabl[4]</TT> n'ont pas été définis, 
puisque <TT>tabl</TT> est un tableau à 3 éléments (0 ... 2). Et pourtant, ce 
programme va compiler.&nbsp;Et si vous avez de la chance, il va même s'exécuter 
correctement, et plus loin dans le programme, vous pourrez utiliser 
<TT>tabl[4]</TT> comme n'importe quelle autre variable.</P>
<P>Par contre, si vous avez moins de chance, et c'est ce qui arrive le plus 
souvent, la tentative d'écriture se passera assez mal et votre programme 
plantera.&nbsp;Qui fait le malin tombe dans le ravin, comme dirait un ami à moi 
:-) La lecture, elle, devrait dans tous les cas vous produire un résultat pour 
le moins inatendu : la valeur de l'élément fantome n'ayant pas été initialisée, 
elle est celle que contient cet endroit de la mémoire à ce moment-là. Souvent, 
c'est n'importe quoi, en particulier avec les tableaux de 
<TT><B>char</B></TT>.</P>
<P>Vous l'aurez compris, mieux vaut ne rien faire en dehors des limites d'un 
tableau, sous peine de se voir renvoyé comme un malpropre par le système. Pas 
toi, je t'ai déjà dit pas de baskets!</P>
<P><FONT size=5><B><A name=strings></A>Un type de tableaux 
particulier</B></FONT></P>
<P>Nous avons déjà vu les <A 
href="http://perso.wanadoo.fr/carlov/pages/index.html#chaine_caracteres">chaînes 
de caractères</A> : <FONT color=blue><TT>"ceci est une chaîne"</TT></FONT>. Et 
bien en réalité, ce ne sont ni plus ni moins que des tableaux de 
<TT><B>char</B></TT>s.&nbsp;Voici un exemple :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>char</B> chaine[] = {<FONT color=blue>'c'</FONT>, 
      <FONT color=blue>'o'</FONT>, <FONT color=blue>'u'</FONT>, <FONT 
      color=blue>'c'</FONT>, <FONT color=blue>'o'</FONT>, <FONT 
      color=blue>'u'</FONT>, <FONT color=blue>'!'</FONT>};<BR>cout &lt;&lt; 
      chaine &lt;&lt; endl;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Nous reconnaissons bien sûr la déclaration d'un tableau, son initialisation, 
et une instructions d'affichage.</P>
<P>La première remarque que vous pourriez me faire, c'est que l'initialisation 
semble très laborieuse : faut-il vraiment écrire toutes ces apostrophes et ces 
accolades pour représenter une chaîne&nbsp;? Alors que nous les avons écrites 
avec des guillemets jusqu'ici&nbsp;? Vous avez parfaitement 
raison.&nbsp;L'exemple que je vous ai donné là est la manière standard pour 
initialiser un tableau, quelque soit le type utilisé. Un tableau de 
<B><TT>char</TT></B> est donc initialisé avec une liste de <B><TT>char</TT></B>. 
Mais voilà : ce n'est pas pratique, et les chaînes de caractères sont tellement 
courantes que le C++ (comme le C) nous permet de l'écrire avec des guillemets, 
plus simples :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>char</B> chaine[] = <FONT 
      color=blue>"coucou!"</FONT>;<BR>cout &lt;&lt; chaine &lt;&lt; 
      endl;</TT></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>La notation avec les guillemets est donc réservée aux chaînes de caractères. 
Bien sûr, vous pouvez accéder (lecture/écriture) à chaque caractère de cette 
chaine de la même manière que vous accedez aux éléments d'un tableau d'entiers. 
Pour écrire une lettre sur 2 à l'écran, faites :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 bgColor=#ffdead border=0>
  <TBODY>
  <TR>
    <TD>
      <DIV align=left><TT><B>char</B> chaine[] = <FONT color=blue>"coucou, c'est 
      nous!"</FONT>;<BR><B>for</B>(<B>int</B> i = 0; i &lt; 
      <B>sizeof</B>(chaine) - 1; i += 2)</TT> 
      <UL>
        <P><TT>cout &lt;&lt; chaine[i];</TT></P></UL>
      <P><TT>cout &lt;&lt; endl;</TT></P></DIV></TD></TR></TBODY></TABLE>
<P></P>
<P>Deux petits mots sur cet exemple : tout d'abord, les <TT><B>char</B></TT> ne 
font qu'un octet, il n'y a donc pas besoin de faire de division avec l'opérateur 
<TT><B>sizeof</B></TT> pour obtenir la longueur de la chaîne.</P>
<P>Si vous avez bien regardé, vous vous êtes sans doute rendu compte que la 
boucle s'arrête à l'avant-dernier élément de la chaîne.&nbsp;Parquoi diable 
?</P>
<P>Ce qu'il faut savoir (et que vous ne savez pas encore), c'est qu'une chaîne 
de caractères au sens C/C++ se termine toujours par un caractère nul : encore un 
caractère spécial, noté <FONT color=blue><TT>'\0'</TT></FONT>. Dans le premier 
exemple que je vous ai donné, le tableau de char contenait exactement la liste 
de char donnée entre accolades.&nbsp;Mais avec les guillemets, le caractère nul 
est rajouté à la fin de la chaîne.&nbsp;Donc une chaine de 5 lettres occupera 6 
octets en mémoire.&nbsp;Comme écrire un caractère nul n'est pas plus passionant 
que cela, on s'arrête avant celui-ci.</P>
<P>Je ne m'avancerais pas plus loin dans les chaînes de caractères pour le 
moment, mais sachez que leur manipulation pourrait faire l'objet de tout un 
livre (bon, d'accord, pas un livre trop gros, mais au moins un petit bouquin de 
poche! :-). Plus tard, j'y consacrerais un cours, mais d'ici là, nous verrons 
plusieurs outils qui nous permettront de mieux comprendre les tableaux et les 
chaînes de caractères.</P>
<P><FONT size=5><B>Application</B></FONT></P>
<P>Pour le programme du jour, je vous propose de remplir un tableau avec des 
entiers et ensuite de le trier par ordre croissant.&nbsp;L'algorithme n'est pas 
difficile :</P>
<UL>
  <LI>Autant de fois qu'il y a d'éléments dans le tableau : 
  <UL>
    <LI>Pour chaque élément du tableau, jusqu'à l'avant dernier : 
    <UL>
      <LI>Si celui-ci est plus grand que l'élément suivant, permuter les deux 
      </LI></UL></LI></UL></LI></UL>
<P>A la fin, le tableau sera classé dans l'ordre. La permutation se fait grâce à 
une variable intermédiaire.&nbsp;Voici le programme :</P></DIV>
<P>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=right bgColor=#008488><FONT 
      color=white><TT>1</TT></FONT> 
      <P><FONT color=white><TT>2<BR>3</TT></FONT></P>
      <P><FONT color=white><TT>4<BR>5<BR>6</TT></FONT></P>
      <P><FONT color=white><TT>7</TT></FONT></P>
      <P><FONT color=white><TT>8</TT></FONT></P>
      <P><FONT color=white><TT>9<BR>10</TT></FONT></P>
      <P><FONT color=white><TT>11<BR>12<BR>13</TT></FONT></P>
      <P><FONT color=white><TT>14</TT></FONT></P>
      <P><FONT color=white><TT>15</TT></FONT></P>
      <P><FONT color=white><TT>16</TT></FONT></P>
      <P><FONT color=white><TT>17</TT></FONT></P></TD>
    <TD width=15 bgColor=#ffdead></TD>
    <TD vAlign=top bgColor=#ffdead><FONT color=#008400><TT>#include 
      &lt;iostream.h&gt;</TT></FONT> 
      <P><TT><B>int</B> main(<B>void</B>)<BR>{</TT></P>
      <UL>
        <P><TT><B>int</B> tabl[] = {10, 4, 5, 2, 1, 7, 10, 3};<BR><B>int</B> 
        longueur = <B>sizeof</B>(tabl) /&nbsp;<B>sizeof</B>(int);<BR><B>int</B> 
        temp = 0;</TT></P>
        <P><TT><B>for</B>(<B>int</B> i = 1; i &lt;= longueur; i++)</TT></P>
        <UL>
          <P><TT><B>for</B>(<B>int</B> j = 0; j &lt; longueur - 1; j++)</TT></P>
          <UL>
            <P><TT><B>if</B>(tabl[j] &gt; tabl[j+1])<BR>{</TT></P>
            <UL>
              <P><TT>temp = tabl[j];<BR>tabl[j] = tabl[j+1];<BR>tabl[j+1] = 
              temp;</TT></P></UL>
            <P><TT>}</TT></P></UL></UL>
        <P><TT><B>while</B>(longueur--)</TT></P>
        <UL>
          <P><TT>cout &lt;&lt; tabl[longueur] &lt;&lt; endl;</TT></P></UL></UL>
      <P><TT>}</TT></P></TD></TR></TBODY></TABLE>
<P></P>
<P>Je ne pense pas que ce programme ne nécessite plus d'explications que cela. A 
la ligne 15, je ne m'encombre pas d'une boucle <TT><B>for</B></TT> : je sais que 
<TT>longueur</TT> contient exactement le nombre d'éléments du tableau 
<TT>tabl</TT>, et je ne m'en servirais plus par la suite, ce qui fait que je 
peux l'utiliser comme compteur.&nbsp;Notez que dans cette boucle, d'abord la 
valeur de <TT>longueur</TT> est utilisée pour le test, ensuite celle-ci est 
décrémentée et enfin, l'affichage se produit (la décrémentation se fait juste 
avant le contenu de la boucle dans ce cas-ci).</P>
<P>Voici les quelques points importants :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center align=middle width=40><IMG height=48 
      src="La Programmation en C++ - Les tableaux_fichiers/exclaR.gif" 
    width=19></TD>
    <TD vAlign=center bgColor=#ffe4e1>
      <UL>
        <LI>Un tableau à n éléments est un ensemble de n variables contigües en 
        mémoire et différenciées par un index. Toutes ces variables sont de même 
        type au sein d'un même tableau. 
        <LI>Les membres d'un tableau à n éléments sont compris <B>entre 0 et 
        n-1</B>. 
        <LI>L'opérateur <TT><B>sizeof</B></TT> permet de connaître la taille 
        d'un tableau (moyennant une petite division). 
        <LI>Le nombre d'éléments d'un tableau est précisé avec une variable 
        <B>entière</B> et <B>constante</B>. 
        <LI>Lorsqu'on initialise un tableau avec une liste (<TT>{a, b, 
        ...}</TT>), le nombre d'éléments retenu est celui précisé entre crochets 
        (si il est précisé), sinon c'est le nombre d'éléments compris dans la 
        liste. 
        <LI>Une tentative d'écriture en dehors des limites d'un tableau peut se 
        solder par un plantage du programme. </LI></UL></TD></TR></TBODY></TABLE>
<P></P>
<P>Et pour vous faire la main avec les tableaux, très importants :</P>
<P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center align=middle width=40><IMG height=47 
      src="La Programmation en C++ - Les tableaux_fichiers/interroB.gif" 
      width=35></TD>
    <TD vAlign=center bgColor=#e6e6fa>
      <UL>
        <LI>Faites un petit programme qui crée 2 tableaux de même taille et qui 
        copie le contenu de l'un dans l'autre. 
        <LI>Implémentez ceci dans le programme du jour afin qu'une copie du 
        tableau d'origine seulement soit classée (l'original restant intact). 
        <LI>Il existe de nombreuses manières de classer un tableau, et j'ai 
        exposé ici la plus économique en code.&nbsp;C'est sans doute l'une des 
        moins efficaces, et je vous encourage à en chercher d'autres par 
        vous-même.&nbsp;Même celle-ci peut être un peu 
        optimisée.&nbsp;Cependant, vu le nombre d'éléments à classer, vous ne 
        verriez pas la différence entre les méthodes.&nbsp;Mais aussi pourriez 
        vous utiliser un tableau plus grand (10000 éléments!!!) et le remplir 
        grâce à une boucle (en impliquant un sinus, par exemple, afin de ne pas 
        avoir les nombres déjà classés). 
        <LI>Faites un petit programme qui fait la moyenne des valeurs contenues 
        dans un tableau (somme des valeurs divisée par le nombre de valeurs). 
        <LI>Rajoutez au programme du jour une belle petite fonction pour 
        afficher le résultat sur des colonnes. 
        <LI>En créant deux chaînes de caractères de même longueur, recopiez le 
        contenu de l'une dans l'autre. Ensuite, la même chose, mais en sens 
        inverse (pensez au dernier caractère nul, qui lui doit être à la fin!). 
        <LI>Attention, voici un petit défi pour les plus hardis d'entre vous : 
        <P>Il s'agid du problème des huit reines.&nbsp;Il s'agit de placer huit 
        reines sur un échiquier de 64 cases (8x8) sans qu'aucune d'entre-elles 
        ne puisse en prendre une autre (je vous rappelle qu'une reine peut aller 
        vers le haut, le bas, gauche, droite et diagonales, d'autant de cases 
        qu'elle veut).&nbsp;Je vous propose donc de faire un petit programme qui 
        tente de placer (de manière bête et disciplinée) ces 8 reines.</P>
        <P>Pour l'échiquier, on pourra utiliser un tableau à 2 dimensions (8x8 
        également), dont les cases marquées d'un 1 sont occupées, les autres 
        étant à 0.&nbsp;Pour chaque tentative de placer une reine dans une case 
        vide, il faut au préalable vérifier toute la rangée, la colonne et les 4 
        diagonales, afin de s'assurer qu'aucune reine ne fait obstacle. Ce 
        programme se fait de manière récursive le plus élégamment du monde, 
        chaque étage de la récursivité s'occupant de placer une reine et se 
        rappellant pour placer la suivante. Il ne faut pas trop de temps pour 
        trouver la solution (quelques secondes),&nbsp;et dès que la solution est 
        trouvée, les coordonnées des huit reines s'affichent à l'écran, afin que 
        vous puissiez vérifier la solution. C'est un poil compliqué, mais 
        abordable pour ceux qui ont déjà fait de la programmation.</P>
        <P>Je vous conseille de revoir le cours sur <A 
        href="http://perso.wanadoo.fr/carlov/cours/chap1/recursivite.html">la 
        récursivité</A> pour bien vous en imprégnier. Cet exercice vous fera 
        travailler à la fois les tableaux, mais aussi la récursivité, les 
        fonctions et tout plein de petites choses qui croustillent sous la 
        dent.</P>
        <P><B>Comme l'exercice est un peu difficile, les trois meilleures 
        solutions que vous <A 
        href="mailto:snakesoft@wanadoo.fr?subject=Les 8 Reines">m'enverrez</A> 
        seront publiées <A 
        href="http://perso.wanadoo.fr/carlov/pages/8reines.html">ici</A>! Alors, 
        à vos claviers.</B> </P></LI></UL></TD></TR></TBODY></TABLE>
<P></P>
<DIV align=left>
<P>Si vous réussissez le dernier exo, vous savez que vous êtes bien parti!!! 
Enfin bon.&nbsp;La semaine prochaine, nous verrons comment créer nos propres 
types de variables, qui seront des assemblages de données, afin de créer des 
groupes cohérents.&nbsp;Nous verrons également un type un peu particulier de 
constantes.</P>
<P>
<HR>

<P></P></DIV>
<P><B>Voir aussi:</B> <A 
href="http://perso.wanadoo.fr/carlov/cours/annexes/types.html">Les types de 
variables</A> - <A 
href="http://perso.wanadoo.fr/carlov/cours/chap1/recursivite.html">la 
récursivité</A></P>
<P>
<HR>

<P></P>
<P><A href="http://perso.wanadoo.fr/carlov/cours/index_cours.html"><IMG 
height=50 src="La Programmation en C++ - Les tableaux_fichiers/coursBtn.gif" 
width=138 border=0></A><A title="Haut de la page" 
href="http://perso.wanadoo.fr/carlov/cours/chap2/tableaux.html#page_top"><IMG 
height=50 src="La Programmation en C++ - Les tableaux_fichiers/hautBtn.gif" 
width=69 border=0></A><A title="La récursivité" 
href="http://perso.wanadoo.fr/carlov/cours/chap1/recursivite.html"><IMG 
height=50 src="La Programmation en C++ - Les tableaux_fichiers/precBtn.gif" 
width=68 border=0></A><A title="Structures, unions et énumérations de données" 
href="http://perso.wanadoo.fr/carlov/cours/chap2/structures.html"><IMG height=50 
src="La Programmation en C++ - Les tableaux_fichiers/suivBtn.gif" width=68 
border=0></A> </P></BODY></HTML>
