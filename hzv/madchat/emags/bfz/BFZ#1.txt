!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BBBBBBBBBB!!RRRRRRRRRR!!!!!!!!@!!!!!!III!!NNN!!!!!NNN!
!!BBBBBBBBBB!!RRRRRRRRRR!!!!!!@@@!!!!!!!!!!NNNN!!!!NN!!
!!!BB!!!!BBB!!!RR!!!!RRR!!!!!@@!@@!!!!III!!NN!N!!!!NN!!   -- { http://www.brainfaktor.org } --
!!!BB!!!!BBB!!!RR!!!!RRR!!!!@@!!!@@!!!III!!NN!NN!!!NN!!
!!BBBBBBBBB!!!RRRRRRRRR!!!@@@@@!@@@@@!III!!NN!!NN!!NN!!                 Enjoy !
!!BBBBBBBBB!!!RRRRRRRRR!!!@@@@@@@@@@@!III!!NN!!NN!!NN!!
!!!BB!!!!BBB!!!RR!!!!RR!!!!@@!!!!!@@!!III!!NN!!!NN!NN!!             irc.worldnet.net
!!!BB!!!!BBB!!!RR!!!!RR!!!!@@!!!!!@@!!III!!NN!!!!N!NN!!               #brainfaktor
!!BBBBBBBBBB!!RRRR!!!RRR!!!@@!!!!!@@!!III!!NN!!!!NNNN!!
!BBBBBBBBBB!!RRRRRR!!RRRR!@@@@!!!@@@@!III!NNN!!!!!NNN!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !FFFFFFFFFFF!!!!!!@!!!!!!KKKK!!!!KKK!TTTTTTTTTT!!!OOOOO!!!RRRRRRRRRR!!!
 nn       nn            !!FFFFFFFFFF!!!!!@@@!!!!!!KKK!!!KKK!!TTTTTTTTTT!!OOOOOOO!!!RRRRRRRRRR!!
 \ \     / /            !!!FF!!!!!!F!!!!@@!@@!!!!!!KK!!KK!!!!T!!!TT!!!T!OO!!!!!OO!!!RR!!!!RRR!!
     ___                !!!FF!!F!!!!!!!@@!!!@@!!!!!KK!KK!!!!!!!!!TT!!!!!OO!!!!!OO!!!RR!!!!RRR!!
    /___\__             !!FFFFFF!!!!!@@@@@!@@@@@!!!KKKK!!!!!!!!!!TT!!!!!OO!!!!!OO!!!RRRRRRRR!!!
   ( @ @ )              !!FFFFFF!!!!!@@@@@@@@@@@!!!KKKK!!!!!!!!!!TT!!!!!OO!!!!!OO!!!RRRRRRRR!!!
    \ ° /               !!!FF!!F!!!!!!@@!!!!!@@!!!!KK!KK!!!!!!!!!TT!!!!!OO!!!!!OO!!!RR!!!!RR!!!
     \=/                !!!FF!!!!!!!!!@@!!!!!@@!!!!KK!!KK!!!!!!!!TT!!!!!OO!!!!!OO!!!RR!!!!RR!!!
  / /   \ \             !!FFFF!!!!!!!!@@!!!!!@@!!!KKK!!!KKK!!!!!TTTT!!!!!OOOOOOO!!!RRRR!!!RRR!!
  uu     uu             !FFFFFF!!!!!!@@@@!!!@@@@!KKKK!!!!KKK!!!TTTTTT!!!!!OOOOO!!!RRRRRR!!RRRR!
                        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 	      !EEEEEEEEEEE!!!!ZZZZZZZZZZ!!!!III!!!NNN!!!!!!NN!!!EEEEEEEEEEE!!
	      !!EEEEEEEEEEE!!!ZZZZZZZZZZ!!!!!!!!!!NNNN!!!!!NN!!!!EEEEEEEEEEE!
	      !!!EE!!!!!!!!!!!!!!!!!!ZZZ!!!!III!!!NN!N!!!!!NN!!!!!EE!!!!!!!!!
	      !!!EE!!!!!!!!!!!!!!!!!ZZZ!!!!!III!!!NN!NN!!!!NN!!!!!EE!!!!!!!!!
	      !!!EEEEEEE!!!!!!!!!!!ZZZ!!!!!!III!!!NN!!NN!!!NN!!!!!EEEEEEE!!!!
	      !!!EEEEEEE!!!!!!!!!!ZZZ!!!!!!!III!!!NN!!NN!!!NN!!!!!EEEEEEE!!!!
	      !!!EE!!!!!!!!!!!!!!ZZZ!!!!!!!!III!!!NN!!!NN!!NN!!!!!EE!!!!!!!!!
	      !!!EE!!!!!!!!!!!!!ZZZ!!!!!!!!!III!!!NN!!!!N!!NN!!!!!EE!!!!!!!!!
	      !!EEEEEEEEEEE!!!!ZZZZZZZZZZZ!!III!!!NN!!!!NNNNN!!!!EEEEEEEEEEE!
	      !EEEEEEEEEEE!!!!!ZZZZZZZZZZZ!!III!!!NN!!!!!NNNN!!!EEEEEEEEEEE!!
	      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		Editeur > agonn (root@brainfaktor.org)

			Redacteurs > agonn (root@brainfaktor.org
				     slugg (slugger@ifrance.com)

				Questions, articles > la crew (zine@brainfaktor.org)


              -=-=-=-=-=-=-=-=-=-==-[ EDITO ]-=-=-=-=-=-=-=-=-=-=-=-

	Salut a tous, j'ai le plaisir de vous annoncer la sortie du premier
numero de BFZ ! Ce zine est orienté h/p/c/v/a et maintenu par la BrAinfAktor
crew (brainfaktor.org). Notre objectif n'est pas de prouver que nous sommes des
l33t mais bel et bien d'essayer de faire évoluer la scène francaise.
Voilà, premier edito pour moi et je vais en profiter pour passer un coup de gueule...
Un coup de gueule contre notre cher gouvernement Raffarin III qui, non content
d'enrichir les riches et d'appauvrir de plus en plus les pauvres, se permet de nous
voter une loi qui est destinée a CENSURER l'internet. Je parle bien entendu de la loi
LCEN dont je m'etonne qu'il n'y ait pas eu plus de réactions que ca dans l'underground.
Pourtant, un des articles devrait nous inquiéter:

"Art. 323-3-1.
Le fait, sans motif légitime, d'importer, de détenir, d'offrir, de céder ou de mettre à
disposition un équipement, un instrument, un programme informatique ou toute donnée
connus ou specialement adaptés pour commettre une ou plusieurs des infractions prévues
par les articles 323-1 à 323-3 est puni des peines prévues respectivement pour l'infraction
elle-meme ou pour l'infraction la plus severement reprimée."

Comme vous le voyez, selon cet article, nous n'avons pas le droit de diffuser, d'écrire
ou même de posséder (!) des codes sources, programmes, articles.. sur le h/p/c/v/a a
moins bien sur que nous ayons un "motif légitime".. Bref c'est du n'importe quoi. Je
suis donc dans l'illégalité en écrivant ce zine car je présume que partager son savoir
ne fait pas parti des motifs légitimes definis par cette loi.. J'espère qu'on attendra
pas 2008 pour se révolter sinon ce sera déjà trop tard, chacun de nos faits et gestes
sera surveillé par Big Brother et a chaque faux pas >> PRISON.. Et j'exagère a peine..
Bref, la révolution sera numérique ou ne le sera pas.

agonn



              -=-=-=-=-=-=-=-=-=-==-[ SOMMAIRE ]-=-=-=-=-=-=-=-=-=-=-=-

#      Titre                              Auteur          Taille
1.1 :  La conscience d'un Hacker          The Mentor      3.6 ko
1.2 :  Scène?                             agonn           3.6 ko
1.3 :  A phreaking overview               agonn           4.7 ko
1.4 :  Backdoors demystified              agonn           5.6 ko
1.5 :  Programmation reseau               agonn           11.2 ko
1.6 :  Cryptologie                        slugg           31.3 ko
1.7 :  UndergroundZ links                 N/A             /



              -=-=-=-=-=-=-=-=-=-==-[ LET'S GO ]-=-=-=-=-=-=-=-=-=-=-=-


--------------------------------------------------------
BFZ#1/ La conscience d'un Hacker              The Mentor
--------------------------------------------------------

        Un autre s'est fait prendre aujourd'hui, c'est partout dans les
journaux. "Scandale: Un adolescent arreté pour crime informatique",
"Arrestation d'un 'hacker' après le piratage d'une banque"...
        Satanés gosses, tous les mêmes.

        Mais avez vous, dans votre psychologie en trois piece et votre profil
technocratique de 1950, un jour pensé à regarder le monde derriere les yeux
d'un hacker?  Ne vous etes vous jamais demandé ce qui l'avait fait agir,
quelles forces l'avaient modelé?
        Je suis un hacker, entrez dans mon monde...
        Le mien est un monde qui commence avec l'école... Je suis plus
astucieux que la pluspart des autres enfants, les conneries qu'ils m'apprennent
me lassent...

        Je suis au collège ou au lycée.  J'ai écouté les professeurs expliquer
pour la quizieme fois comment réduire une fraction.  Je l'ai compris.
"Non Mme Dubois, je ne peux pas montrer mon travail.  Je l'ai fait dans ma tête"
        Satané gosses. Il l'a certainnement copié. Tous les mêmes.

        J'ai fait une découverte aujourd'hui.  J'ai trouvé un ordinateur.
Attends une minute, c'est cool.  Ca fait ce que je veux.  Si ca fait une
erreur, c'est parce que je me suis planté.
        Pas parce qu'il ne m'aime pas...
        Ni parce qu'il se sent menacé par moi...
        Ni parce qu'il pense que je suis petit filoux...
        Ni parce qu'il n'aime pas enseigner et qu'il ne devrait pas être là...
        Satan‚s gosses. Tout ce qu'il fait c'est jouer. Tous les mêmes.

        Et alors c'est arrivé... une porte s'est ouverte sur le monde... Se
pr‚cipitant a travers la ligne telephonique comme de l'héroine dans les veines
d'un accro, une impulsion electronique est envoyée, on recherche un refuge a
l'incompetence quotidienne... un serveur est trouvé.

        Vous vous repetez que nous sommes tous pareils... On a été nourri a la
petite cuillere de bouffe pour bébé a l'école quand on avait faim d'un steak...
Les fragments de viande que l'on nous a laissé êtaient pré-machés et sans gout.
On a été dominés par des sadiques ou ignorés par des apathiques.  Les seuls qui
avaient des choses a nous apprendre trouvèrent des élèves volontaires, mais
ceux ci sont comme des gouttes dans le desert.

        C'est notre monde maintenant... Le monde de l'electron et de
l'interrupteur, la beauté du baud.  Nous utilisons un service déja existant,
sans payer ce qui pourrait être bon marché si ce n'était pas la propriété
de gloutons profiteurs, et vous nous appelez criminels.  Nous explorons... et
vous nous appelez criminels.  Nous recherchons la connaissance... et vous nous
appelez criminels.  Nous existons sans couleur de peau, sans nationalité, sans
dogme religieux... et vous nous appelez criminels.
Vous construisez des bombes atomiques, vous financez les guerres,
vous ne punissez pas les patrons de la mafia aux riches avocats,
vous assassinez et trichez, vous manipulez et nous mentez en essayant de nous
faire croire que c'est pour notre propre bien être, et nous sommes encore des
criminels.

        Oui, je suis un criminel.  Mon crime est celui de la curiosité.  Mon
crime est celui de juger les gens par ce qu'ils pensent et dise, pas selon leur
apparence.
Mon crime est de vous surpasser, quelque chose que vous ne me pardonnerez
jamais.

        Je suis un hacker, et ceci est mon manifeste.  Vous pouvez arreter cet
individu, mais vous ne pouvez pas tous nous arreter...
aprŠs tout, nous sommes tous les mêmes.

                                +++The Mentor+++




--------------------------------------------------------
BFZ#1/ Scène?                                      agonn
--------------------------------------------------------

La scène est-elle morte?
Voilà la question que je me pose... Depuis la mort de Madchat, j'ai l'impression que la scene
s'est évanouie.. Quand je parle de la scene, je parle bien sur de veritables groupes innovants
et inventifs, prets a partager leur savoir et a CONSTRUIRE l'underground. Je ne compte donc
pas tous ces pseudos-hackers membres de l'IHC ou toute autre organisations là juste pour la
fame... Et pourtant, ce sont ces même groupes que les newbies croient être la scene, et bien
NON!!

Regardez aux USA, là bas, leur scene est vraiment dévelopée: beaucoup de releases, des ezines
qui pullulent, des nouveaux groupes tous les mois.. et pourtant, ils n'ont pas vraiment
d'organisation particulière mais cet ensemble fonctionne. En france c'est pas pareil.. Il ya
bien sur des teams vraiment douées (niveau technique) mais qui ne rendent public quasiment
rien et qui preferent rester cachées dans leur coin.. On pourrait dire que EUX representent
la scene, mais non, la scene c'est avant tout un ensemble d'organismes INDEPENDANTS mais
SOLIDAIRES entre eux, la scene c'est la diffusion du savoir au plus grand nombre, c'est la
scene qui se doit de respecter la liberté d'expression et d'opinion sur le net (en faisant
face par exemple a la LEN ou aux brevets logiciels), la scene se doit de s'autoreguler et de
ne pas se laisser mourir.. Heureusement, on assiste de plus en plus a une recrudescence de
teams véritablement fortes au niveau technique mais qui ont aussi une ethique et une vraie
conscience de ce qu'est l'underground..


agonn        root@brainfaktor.org/agonn@linuxmail.org




--------------------------------------------------------
BFZ#1/ A phreaking overview                        agonn
--------------------------------------------------------

Tout d'abord, je tiens a signaler que ce texte ne vous apprendra en aucun cas des nouvelles
techniques de phreaking, il traite juste des différentes techniques actuellement connues...

Pour commencer, je vais vous parler des techniques dites de "soft phreak": elles regroupent le
hack de PABX (pour phoner gratos), le hack de vmb (pour faire des conferences telephoniques par
ex..) et le scanning de numeros verts (qui correspondent justement a des PABX ou VMB)
Un PABX (Private Automatic Branch eXchanger) est un central telephonique gérant les appels entrant
et sortant. Il permet par exemple a un employé de telephoner vers l'exterieur a partir de son
bureau en donnant un numero d'user et un mot de passe au central. Chaque employé dispose également
d'une boite vocale (VMB= Voice mail box).
Les PABX sont souvent accessibles par un numero vert (appel gratuit). Pour les numeros verts,
vous pouvez les scanner a la main (plutot chiant mais bon) ou avec un logiciel comme TONELOC.
Un fois le numero trouvé, il suffit donc de le composer et de voir si ca correspond bien a une
VMB. Là ya plusieurs solutions, soit ya quelqu'un qui décroche et dans ce cas là vous l'envoyer
chier, soit vous tombez sur un répondeur automatique (Souvent c'est bon signe) soit on vous demande
un mot de passe (BINGO !!!) .
Donc, si vous tombez sur le repondeur, essayer d'appuyez sur les touches "0","#","1","9","*" de
votre phone et si c'est bien un PABX, vous accedez a un menu vous permettant d'acceder a votre
boite vocale, de laisser un message ou de composer un numero et c'est gagné ! sinon bah.. vous
avez plus qu'a retourner scanner.
Si vous tombez sur une identification de mot de passe, ca va etre plus dur, d'abord essayer les
mots de passe par défaut du genre "1234","0000","9876".. et si ca marche pas.. bah vous essayez
plusieurs combinaisons, et si ca marche vraiment pas vous laissez tomber (vous en trouverez
d'autres ;)). Ah oui, souvent, vous etes déconnecté au bout de 3 tentatives et votre appel est
loggé sur la machine donc faites gaffe..
Une fois que vous avez gagné l'acces a votre VMB, vous pouvez demander a vos potes de vous laisser
un message dessus, vous pouvez organiser des conferences telephonique a plusieurs (mais essayez
quand même de prendre un poste qui n'est pas déjà occupé par un employé)...
Si vous voulez plus de détails a propos des VMB, je vous rapporte aux excellents articles de
NoRoute, NoWay etc.. (notamment pour les commandes a l'interieur de la vmb..)

Ensuite ya le "hard phreak" qui comprend toutes les techniques de boxing, qui sont de simples
montages electroniques permettant de ne pas payer la communication telephonique, de laisser son
voisin la payer ou encore d'electrocuter son interlocuteur (là je garantis rien).. les boxes
sont representées selon un nom de couleurs, par exemple beige box, black box, red box pour ne
citer que les plus connues.. Malheureusement pour nous, la plupart de ces boxs ne fonctionnent
qu'aux Etats-Unis et même si certaines techniques marchent chez nous, je conseille vraiment pas
de les utiliser, FT ayant renforcé la sécurité de leur reseau, c'est vraiment hyper trace (a moins
de beige boxer sur une cabine telephonique..)

Enfin il y a le hack de GSM qui en est encore a ses balbutiements en France mais qui se développe
assez rapidement (on en reparlera surement dans un prochain numero)..

Il ya aussi le wardriving (pour squatter les spots WiFi >> acces internet gratuit) qui peut être
sympa a utiliser si vous habitez dans les grandes villes :)

Voilà pour la partie phreaking de cette issue, c'est un peu bref mais ca vous donne le sommaire
des prochains numeros :)
Ah oui! j'ai aussi entendu parler d'une rumeur selon quoi on pourrait telephoner gratos grace a
son portable et a une cabine telephoniques, il suffirait d'appeler le numero de la cabine avec
son portable (le telephone n'etant pas décroché donc), de raccrocher avec le portable et ensuite
de décrocher le telephon ete on aurait la ligne.. Je sais plus ou j'ai vu ca mais si vous avez
plus d'infos mailez moi..

BONUS: LE MATOS DU PARFAIT PETIT PHREACKER:

-Toujours avoir une beige box en permanence sur soi (ca peut toujours servir..)

-Un pied de biche (pour defoncer les bornes FT)

-Un logiciel de wardriving du genre WarLinux (http://sf.net/warlinux/)

-Un bon scanner de numeros verts (par ex TONELOC dispo sur le site)

-Une bonne paire de couilles (se faire chopper par un flic a 1h du mat en train de defoncer une
borne FT je dois dire que c'est pas très marrant..)

-Une cagoule si vous phreaker la nuit (comme ca le flic vous reconnaitra pas..)


agonn    root@brainfaktor.org/agonn@linuxmail.org




--------------------------------------------------------
BFZ#1/ Backdoors demystified                       agonn
--------------------------------------------------------

	Pour commencer cet article, je vais tenter de vous expliquer ce qu'est une backdoor (du
point de vue technique) et a quoi elle sert.Nous verrons ensuite les différents types
de backdoors existantes et enfin, je vous donnerais des codes sources de backdoor (dossier
 src/) relativement simples que j'essayerais de commenter au maximum.

So, what is a backdoor?

	Une backdoor est un programme utilisé afin de récupérer un accès root sur un serveur.
Quand un pirate réussi a devenir root sur un serveur, il met généralement en place une backdoor
qui lui servira a reprendre l'acces quand il le souhaitera. Les fonctions principales
d'une backdoor sont de réussir a reprendre l'acces root le plus vite possible en laisser lemoins
de traces possibles (en utilisant un log cleaner integré au programme par exemple) et en
faisant attention de ne pas se faire repérer par l'administrateur de la machine cible.
Pour cela, le pirate va chercher plusieurs "failles" dans le systeme ce qui lui permet de
toujours avoir un acces même si l'administrateur réussit a détecter la backdoor.

Voilà pour le principe, maintenant, voyons voir les différents types de backdoor existantes,
leur descriptions et leur effets sur un serveur vulnérable (ceci est une liste non exhaustive):

/etc/passwd Backdoor
--------------------

	Cette methode consiste a cracker un mot de passe se situant dans le fichier /etc/passwd/ ou
a ajouter une ligne dans ce fichier nous permettant de nous logger en tant qu'user "legal"
du systeme. Cette technique est peu utilisée car souvent la premiere chose qu'un administrateur
fait lorsque sont systeme a été attaqué est de vérifier ce fichier. A ne pas
conseiller donc.

Rhosts Backdoor
---------------

	Cette backdoor consiste a exploiter le systeme d'authentification Rlogin et RSH. Il suffit
de modifier le fichier $HOME/.rhosts en y ajoutant un ligne "+ +" ce qui a pour effet que n'importe
qui peut se logger a distance sans avoir besoin de fournir de mot de passe, ce qui peut etre
un inconvenient car n'importe quel crasher qui aura repéré la faille pourra se connecter aussi
(NOTE: Pour eviter ce probleme, il suffit de ne mettre qu'un seul "+" dans le .rhosts mais vous
ne pourrez vous logger qu'en local..). Encore une fois, c'est une des premieres choses que
l'administrateur verifie. Il suffirait dans ce cas de développer un systeme de client/serveur
qui permettrait d'ajouter cette ligne lorsque le pirate se connecte au serveur de la backdoor,
il n'aurait alors plus qu'a effacer la ligne une fois le controle repris.. mais ceci sera développé
plus loin.

Bootblock backdoor
------------------

	Cette technique consiste a insérer une sorte de virus dans le secteur de boot du systeme.
Cette technique peut s'avérer très efficace car les administrateurs ne possèdent souvent pas
d'outils pour verifier le secteur de boot mais elle est aussi très complexe a mettre en oeuvre.

Shell SUID backdoor
-------------------

	Coniste a rendre un shell (/bin/bash par exemple) suid root, c'est a dire qu'un user
qui utilisera ce shell aura les privileges root lors de son execution. Il suffit pour cela de
copier le shell vers un autre fichier qui representera notre shell suid (ex: cp /bin/bash
/bin/shellsuid ) et de le rendre suid root en tappant "chmod 7555 /bin/shellsuid". Il suffit
ensuite d'executer notre "faux" shell pour avoir les privileges root.

LKM (Loadable Kernel Modules)
-----------------------------

	Les LKM sont utilisés par le kernel pour lui rajouter ou expandre ses fonctionnalités
(modifier les appels systeme par exemple.. :)). Ces modules sont chargés dynamiquement, c'est a
dire qu'ils ne necessitent aucune compilation du kernel pour fonctionner ! Ils sont la plupart
du temps utilisés pour les drivers de materiel. Seul le root peut les installer (normal..).
Pour forcer le systeme a charger un module, tappez ceci dans votre term (vous devez etre root):

#insmod module.o

Pour voir la liste des modules en execution:

#lsmod
Module                  Size  Used by    Tainted: PF
nvidia               1672832  10  (autoclean)
snd                    40868   4  [snd-seq-oss snd-seq-midi-event snd-seq snd-pcm-oss snd-mixer-oss
snd-via82xx snd-ac97-codec snd-pcm snd-timer snd-mpu401-uart snd-rawmidi snd-seq-device]
cdrom                  31648   0  [sr_mod ide-cd]
floppy                 55132   0
module		           1   0

Vous pouvez egalement enlever vos modules avec:

#rmmod module
Module                  Size  Used by    Tainted: PF
nvidia               1672832  10  (autoclean)
snd                    40868   4  [snd-seq-oss snd-seq-midi-event snd-seq snd-pcm-oss snd-mixer-oss
snd-via82xx snd-ac97-codec snd-pcm snd-timer snd-mpu401-uart snd-rawmidi snd-seq-device]
cdrom                  31648   0  [sr_mod ide-cd]
floppy                 55132   0

Bien sur il existe des methodes pour cacher ce module :)
Vous voyez ou je veux en venir? Eh oui, on peut tout simplement installer une backdoor dans le
kernel sans que l'admin sans apercoive (le module etant invisible). Pour l'aspect programmation
c'est un peu plus dur mais pas insurmontable (a voir dans un prochain article)


TCP Backdoor
------------

	Une TCP Backdoor agit comme un serveur sur la cible. Nous pouvons alors nous y connecter
via telnet ou un client specifique. On peut également l'associer a un LKM pour cacher le
processus ou cacher l'executable.. Quand le serveur est activée, il agit alors comme une backdoor
"normale" (ajout de .rhost, de comptes utilisateurs..) et vous n'avez plus qu'a faire disparaitre
les logs et a relancer l'executable :)




--------------------------------------------------------
BFZ#1/ Programmation reseau                        agonn
--------------------------------------------------------

I - Introduction
================

	Ce document est basé sur la traduction de "BASIC C Socket Programming In Unix For Newbie
by Bracaman". Je donc vais vous apprendre a creer des applications reseau pour UNIX. Avant toute
chose, je tiens a dire que ce paper pose juste les BASES de la programmation reseau, il serait
utopique de vouloir tout expliquer a ce sujet. Nous allons donc voir ensemble les différentes
fonctions et structures utiles a la programmation de sockets et nous allons construire un serveur
et un client très basique. Let's go!

II - Les Structures
===================

	En programmation de socket, les structures servent a stocker les informations a propos des
adresses. Notre premiere structure est la struct sockaddr qui stocke les informations sur le socket:

	struct sockaddr{
		unsigned short  sa_family;    /* address family */
		char	        sa_data[14];  /* 14 bytes of protocol address */
	};

Mais il y a une autre structure qui peut vous aider a referencer les elements du socket:

	struct sockaddr_in {
		short int	     sin_family;  /* Address family */
		unsigned short int   sin_port;	  /* Port */
		struct in_addr	     sin_addr;	  /* Internet Address */
		unsigned char	     sin_zero[8]; /* Same size as struct sockaddr */
	};

La structure hosetnt sert a obtenir des informatuions a propos de l'host, elle se définit comme suit:

	struct hostent
	{
	  char *h_name;                 /* Official name of host.  */
	  char **h_aliases;             /* Alias list.  */
	  int h_addrtype;               /* Host address type.  */
	  int h_length;                 /* Length of address.  */
	  char **h_addr_list;           /* List of addresses from name server.  */
	#define h_addr  h_addr_list[0]  /* Address, for backward compatibility.  */
	};

Ca peut paraitre compliqué a certains mais au fur et a mesure vous apprendrez a vous servir et a
comprendre ces structures.

III - Adresses IP
==================

Je vais parler ici de différentes fonctions servant a manipuler les adresse IP.
inet_addr() qui convertit une adresse IP en un unsigned long:

	dest.sin_addr.s_addr = inet_addr("127.0.0.1");

inet_ntoa() convertit un string d'adresse IP en long:

	char *IP;
	ip = inet_ntoa(dest.sin_addr);
	printf("l'adresse est: %s\n", ip);

IV - Les Fonctions
==================

	On passe au plus interessant.. Je vais ici vous présenter les différentes fonctions
utiles pour programmer des sockets. Je mets egalement la syntaxe avec les header pour vous faciliter
la tache. Pour voir ces fonctions en action, vous pouvez passer aux codes sources du client et du
serveur...

	1 - socket()
	============

	#include <sys/types.h>
	#include <sys/socket.h>

	int socket(int domain,int type,int protocol);

	  La fonction socket() sert a.. définir un socket. Elle retourne -1 en cas d'erreur
          Voila, passons aux arguments:

	  	domain   = AF_INET pour utiliser le protocole internet, on ne s'occupera pas des
		           autres types car ils ne sont pratiquement jamais utilisés..
		type     = SOCK_STREAM pour utiliser les stream sockets (qui utilisent le protocole
		           TCP) ou SOCK_DGRAM pour les datagram sockets (qui utilisent UDP)
		protocol = On le le met a 0


	2 - bind()
	==========

        #include <sys/types.h>
	#include <sys/socket.h>

	int bind(int fd, struct sockaddr *my_addr,int addrlen);

	  La fonction bind() est utilisée pour associer un socket a un port. Elle retourne -1 en cas
	  d'erreur.
	  Arguments:

	  	fd      = Le descripteur de socket retourné par socket()
		my_addr = un pointeur pour la structure sockaddr
		addrlen = sizeof(struct sockaddr)

	3 - connect()
	=============

	#include <sys/types.h>
	#include <sys/socket.h>

	int connect(int fd, struct sockaddr *serv_addr, int addrlen);

	  La fonction socket() est utilisée pour connecter une adresse IP a un port défini. Elle
	  retourne -1 en cas d'erreur.
	  Arguments:

	  	fd        = Le desrcipteur de socket retourné par socket()
		serv_addr = Un pointeur pour la structure sockaddr qui contient l'adresse IP de
		            destination et le port
		addrlen   = sizeof(struct sockaddr)

	4 - listen()
	============

	#include <sys/types.h>
	#include <sys/socket.h>

	int listen(int fd,int backlog);

		listen() est utilisée pour attendre une connection. Avant cela, vous devez
                appeler la fonction bind() pour définir le port a écouter et après avoir appelé
		listen(), vous devez appeler accept() pour accepter les connections entrantes.
		listen() retourne -1 en cas d'erreur
		Arguments:

			 fd      = Le descripteur de socket retourné par socket()
			 backlog = Le nombre de connections autorisées

	5 - accept()
	============

	#include <sys/socket.h>

	int accept(int fd, void *addr, int *addrlen);

		Utilisé pour accepter une connection (comme par hasard..). Retourne -1 en cas d'erreur.
		Arguments:
			fd      = Le descripteur de socket retourné par l'appel a listen()
			addr    = Un pointeur pour la struct sockaddr_in où vous pouvez déterminer
			          quel host vous appelle depuis quel port.
			addrlen = La taille de la struct sockaddr_in

	6 - send()
	==========

	int send(int fd,const void *msg,int len,int flags);

		Transmet des données. Retourne -1 en cas d'erreur.
		Arguments:

			fd    = Le descripteur de socket où vous voulez envoyer des données
			msg   = Pointeur vers les données que vous voulez envoyer
			len   = la taille des données que vous voulez transmettre (en bits)
			flags = 0

	7 - recv()
	==========

	int recv(int fd, void *buf, int len, unsigned int flags);

		Recoit les données. Retourne -1 en cas d'erreur.
		Arguments:

			fd    = le descripteur de socket dans le lequel lire les données
			buf   = le buffer où lire les données
			len   = la taille de données maximum du buffer
			flags = 0

	8 - sendto()
	============

	int sendto(int fd,const void *msg, int len, unsigned int flags,
	           const struct sockaddr *to, int tolen);

		Même fonction que send() mais avec 2 arguments en plus. Sert seulement pour les
		datagram sockets non connectés. Retourne -1 en cas d'erreur.
		Arguments:

			fd, msg, len ,flags = Pareil que send()
			to                  = Un pointeur pour la struct sockaddr
			tolen               = sizeof(struct sockaddr)

	9 - recvfrom()
	==============

	int recvfrom(int fd,void *buf, int len, unsigned int flags
		     struct sockaddr *from, int *fromlen);

		La même chose que recv() pour les datagram sockets non connectés. Retourne -1 en cas
		d'erreur.
		Arguments:

			fd, buf, len, flags = Pareil que recv()
			from                = Pointeur pour la struct sockaddr
			dromlen             = sizeof(struct sockaddr)

	10 - close()
	============

	close(fd)

		Ferme la connection.

	11 - gethostname()
	==================

	#include <unistd.h>

	int gethostname(char *hostname, size_t size);

		gethostname() sert a trouver le nom d'une machine locale.
		Arguments:

			hostname = Un pointeur vers un array qui contient hostname
			size     = La taille de l'array hostname (en bytes)


V - Codes Sources
=================

	Quelques exemples de ce qu'on peut faire avec les sockets :)

<----------- CUT HERE -------------------------------------------->
*/ serveur.c
   $gcc serveur.c -o serveur
   Code by Bracaman */

 #include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 3455   /* Le port que nous allons utiliser */
#define BACKLOG 2   /* L enombre de connections autorisées */

main()
{

  int fd, fd2;   /* descripteurs de socket */

  struct sockaddr_in server;  /* informations sur le serveur */
  struct sockaddr_in client;  /* informations sur le client */

  int sin_size;

  if ((fd=socket(AF_INET, SOCK_STREAM, 0)) == -1 ){  /* Si socket() est egal -1 : erreur */
    printf("socket() error\n");
    exit(-1);
  }    /* Si pas d'erreur notre socket est créé */

  server.sin_family = AF_INET;
  server.sin_port = htons(PORT);   /* Convertit notre port  */
  server.sin_addr.s_addr = INADDR_ANY;  /* INADDR_ANY définit votre adresse IP */
  bzero(&(server.sin_zero),8); /* On met a zero le reste de la structure */


  if(bind(fd,(struct sockaddr*)&server,sizeof(struct sockaddr))==-1){ /* On appelle bind() */
      printf("bind() error\n");
      exit(-1);
  }

  if(listen(fd,BACKLOG) == -1){  /* On appelle listen() */
      printf("listen() error\n");
      exit(-1);
  }

while(1){
  sin_size=sizeof(struct sockaddr_in);
  if ((fd2 = accept(fd,(struct sockaddr *)&client,&sin_size))==-1){ /* On appelle accept() */
    printf("accept() error\n");
    exit(-1);
  }

  printf("You got a connection from %s\n",inet_ntoa(client.sin_addr) ); /* On nous donne l'IP du
                                                                           client */

  send(fd2,"Welcome to my server.\n",22,0); /* On lui envoie un message de bienvenue */

  close(fd2); /*  close fd2 */
}
}

<----------- CUT HERE --------------------------------------------------->

<----------- CUT HERE --------------------------------------------------->

*/ client.c
   $gcc client.c -o client
   Code by Bracaman */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>        /* Pour struct hostent */

#define PORT 3550	  /* Port */
#define MAXDATASIZE 100   /* Nombre maximum de bits de données */

int main(int argc, char *argv[])
{
  int fd, numbytes;	  /* descripteur de socket */
  char buf[MAXDATASIZE];  /* Le buffer qui va stocker le texte recu */

  struct hostent *he;         /* Structure qui prend les informations sur l'host */
  struct sockaddr_in server;  /* Informations sur l'adresse du serveur */

  if (argc !=2) {	      /* Notre programme a besoin de 2 arguments */
    printf("Usage: %s <IP Address>\n",argv[0]);
    exit(-1);
  }

  if ((he=gethostbyname(argv[1]))==NULL){	/* appel a gethostbyname() */
    printf("gethostbyname() error\n");
    exit(-1);
  }

  if ((fd=socket(AF_INET, SOCK_STREAM, 0))==-1){  /* creation du socket */
    printf("socket() error\n");
    exit(-1);
  }

  server.sin_family = AF_INET;
  server.sin_port = htons(PORT); /* Conversion */
  server.sin_addr = *((struct in_addr *)he->h_addr);  /*he->h_addr passe les infos sur he a "h_addr" */
  bzero(&(server.sin_zero),8);

  if(connect(fd, (struct sockaddr *)&server,sizeof(struct sockaddr))==-1){ /* on appelle connect() */
    printf("connect() error\n");
    exit(-1);
  }

  if ((numbytes=recv(fd,buf,MAXDATASIZE,0)) == -1){  /* on appelle recv() */
    printf("recv() error\n");
    exit(-1);
  }

      buf[numbytes]='\0';

      printf("Server Message: %s\n",buf); /* On recoit le message du serveur */

      close(fd);   /* Ferme la connection */
}

<------------ CUT HERE -------------------------------------------------------------->

VI - Outro
==========

	Voilà, j'espère que vous en saurez un peu plus sur la programmation reseau (même si ce n'est
pas super complet..). Si vous voulez d'autres codes sources, j'en ai mit un dans le dossier /src,
c'est en fait le code d'une backdoor TCP qui fait office de serveur :)
Je rappelle que cet article est basé sur "BASIC C Socket Programming In Unix For Newbies by Bracaman",
vous pouvez lui écrire a BracaMan@clix.pt.
Enjoy !


agonn      < root@brainfaktor.org >




--------------------------------------------------------
BFZ#1/ Cryptologie                                 slugg
--------------------------------------------------------


   CCCC  RRRRR  YY  YY PPPPP  TTTTTT  OOOO  LL      OOOO   GGGG  II EEEEEE
  CCCCCC RR  RR YY  YY PP  PP TTTTTT OOOOOO LL     OOOOOO GGGGGG    EEEEEE
  CC  CC RR  RR YY  YY PP  PP   TT   OO  OO LL     OO  OO GG  GG II EE
  CC     RRRRR   YYYY  PPPPP    TT   OO  OO LL     OO  OO GG     II EEEE
  CC     RR  RR   YY   PP       TT   OO  OO LL     OO  OO GG     II EEEE
  CC  CC RR  RR   YY   PP       TT   OO  OO LL     OO  OO GG GGG II EE
  CCCCCC RR  RR   YY   PP       TT   OOOOOO LLLLLL OOOOOO GG G G II EEEEEE
   CCCC  RR  RR   YY   PP       TT    OOOO  LLLLLL  OOOO   GGG G II EEEEEE




 1. INTRODUCTION
****************

    La cryptologie est LA science du message secret. Elle se partage en deux parties,
  la CRYPTOGRAPHIE, qui est l'etude des techniques destines a assurer la confidentialite,
  l'integrite, et l'authentification des donnees, et la CRYPTANALYSE, qui consiste a
  casser ces techniques cryptographiques.

    On va donc voir comment proteger ses donnees en les chiffrant (avec des systemes de
  chiffrement classiques), et voir comment on peut casser ces chiffrages. On essaiera
  ensuite de creer une application en C, qui pourrai simplifier tout ce shlimblick, dans
  certains cas seulement, j'vais pas vous macher tout le boulot non plus :-).

    Enfin je tenai a dire qu'a l'heure ou les libertes numeriques (s'il y avait que celles
  la) ne cessent de reculer (en France en tout cas), il devient indispensable de s'interesser
  a ce domaine (qui plus est, fort interessant).
  Treve de bavardarge... LET's GO !!


 2. TABLE DES MATIERES
******************

    1. Introduction
    2. Table des matieres
    3. Chiffrement par transposition
       3.1. Transposition simple
       3.2. Variantes
       3.3. Cryptanalyse
    4. Chiffrement par substitution
       4.1 Substitution monoalphabetique
           4.1.1. La substitution monoalphabetique decalee : CESAR
           4.1.2. Cryptanalyse d un systeme monoalphabetique
       4.2 Substitution polyalphabetique
           4.2.1 Le chiffre de Vigenere
           4.2.2 Cryptanalyse du chiffre de Vigenere
    5. Epilogue
    6. Annexe


 3. LE CHIFFREMENT PAR TRANSPOSITION
************************************

    Le chiffrement par transposition consiste a melanger les lettres de votre message, en
  utilisant un principe mathematique de permutation :


  3.1.Transposition simple
  ========================
        On ecrit le message horizontalement dans une grille predefinie (appelee matrice),
      puis on retrouve le message crypte en lisant la grille verticalement. Pour decrypter
      il suffit de realiser le procede inverse.


        Texte en clair : CECI EST UN EXEMPLE DE TRANSPOSITION SIMPLE PAR COLONNE
        utilisant une matrice [7;7].
        (7 colonnes, 7 lignes)

                  _______________
                  |C|E|C|I|E|S|T|
                  |U|N|E|X|E|M|P|
                  |L|E|D|E|T|R|A|
                  |N|S|P|O|S|I|T|
                  |I|O|N|S|I|M|P|
                  |L|E|P|A|R|C|O|
                  |L|O|N|N|E|

              Texte crypte : CULNILLENESOEOCEDPNPNIXEOSANEETSIRESMRIMCTPATPO

      ==> La cle est une matrice [7;7]


  3.2.Variantes
  =============
        Ici on commence par choisir un MOT CLE. Celui-ci doit avoir autant de lettres
      qu'il y a de colonnes dans notre matrice, ni plus, ni moins. De plus le mot cle ne
      doit surtout pas contenir 2 fois la meme lettre.
        Ensuite on attribue a chaque lettre du mot cle, un numero de sequence, commancant
      a 1 et finissant au nombre de lettre composant notre mot cle. On obtient les numeros
      de sequence en partant de la gauche vers la droite, et en donnant l'ordre d'apparition
      dans l'alphabet.
        Ceci fait on peut maintenant placer notre message dans la matrice, toujours
      horizontalement,et on lit le message crypte verticalement en suivant le numero de
      sequence :


      Notre mot cle est : CRYPTO
      L'ordre d'apparition dans l'alphabet est : COPRTY
      Texte clair : CECI EST UNE VARIANTE AVEC UN MOT CLE
      Matrice [6;5]

                   C R Y P T O
                   1 4 6 3 5 2
                  _____________
                  |C|E|C|I|E|S|
                  |T|U|N|E|E|X|
                  |E|M|P|L|E|D|
                  |E|V|A|R|I|A|
                  |N|T|E|A|V|E|
                  |C|U|N|M|O|T|
                  |C|L|E|


        Texte crypte :

      ==> La cle est une matrice [6;5]transposition CRYPTO


        Il existe plusieurs variantes pour ameliorer la confidentialite du texte chiffre :
      une rotation de la grille, un ajout de lettres inutiles, etc...


  3.3.Cryptanalyse du chiffrement par transposition
  =================================================
        Un chiffrement par transposition est rarement utilise seul; il est plus souvent
      utilise avant ou apres un autres algorithme de cryptage. De plus, une simple analyse
      de frequence des caracteres(cf plus bas) est inutile, puisque les lettres avant le 
      chiffrage sont les memes qu apres.
        Le nombre de possibilites augmentant avec le nombre de lettre, je vous recommande
      de vous armer de votre patience pour TOUTE cryptanalyse, meme avec un ordinateur puissant :
      ici, pour un message de "n" lettres, il y a : n!=1*2*...*(n-1)*n possibilites.

        Donc, le plus simple serait de retrouver le nombre de colonnes que comprend la
      matrice, en cherchant a prendre qu une lettre sur 2 (sur 3, sur 4,....sur 7 dans
      notre premier cas). Regardons ce que ca donne avec la matrice :

                  _______________
                  |C|E|C|I|E|S|T|
                  |U|N|E|X|E|M|P|
                  |L|E|D|E|T|R|A|
                  |N|S|P|O|S|I|T|
                  |I|O|N|S|I|M|P|
                  |L|E|P|A|R|C|O|
                  |L|O|N|N|E|

              Texte crypte : Culnill Enesoeo Cedpnpn Ixeosan Eetsire Smrimc Tpatpo

         J'ai decoupe en 7 blocs, pour bien reperer les colonnes. Vous remarquerez que les
       premieres lettres de chaque block nous donne le debut de notre texte non chiffre.
       Arrivee au dernier block, on recommence en s interessant a la 2e lettres de chaque block,
       puis a la troisieme, et ainsi de suite.
         Cette methode marche tres bien, avec un petit nombre de caractere, et dans le cas
       d'une transposition simple.


 4. LE CHIFFREMENT PAR SUBSTITUTION
***********************************

    Le principe de substitution consiste a remplacer un ou plusieurs caracteres par d'autres
  caracteres. Contrairement au chiffrement par transposition, la substitution change
  (totalement ou partiellement) les lettres et peut dans certains cas utiliser d autres symboles,
  ou alphabets. Il existe plusieurs procedes de substitution, nous n'en verrons que deux :
  la substitution monoalphabetique (dite simple) et la substitution polyalphabetique.


  4.1.La substitution monoalphabetique
  =====================================
        La substitution monoalphabetique se dit simple puisqu'il suffit d'attribuer a un alphabet
      clair un equivalent chiffre,cet alphabet chiffre sera conserve tout au long du processus
      de chiffrement. Ce type de chiffrement est tres peu sur.
        On retrouve dans cette categorie, les alphabet desordonne, ou reversible, le carre de
      polybe, le chiffre de "CESAR" que nous allons etudier.

      4.1.1. La substitution monoalphabetique par décalage
      ----------------------------------------------------
             "Le chiffre de CESAR" consiste a choisir une lettre (la cle) qui definira le
             decalage a effectuer a l ensemble du texte clair (Modulo 26 pour que ca boucle
             correctement).


             CLAIR  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                +1  B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
                +2  C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
                +3  D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
                    . . . . . . . . . . . . . . . . . . . . . . . . . .
                    . . . . . . . . . . . . . . . . . . . . . . . . . .
                    . . . . . . . . . . . . . . . . . . . . . . . . . .
               +23  X Y Z A B C D E F G H I J K L M N O P Q R S T U V W
               +24  Y Z A B C D E F G H I J K L M N O P Q R S T U V W X
               +25  Z A B C D E F G H I J K L M N O P Q R S T U V W X Y


             Par exemple, en prennant comme decalage (cle) +2, le texte clair :
             "La substitution monoalphabetique est simple" devient
             "Nc uwduvkvwvkqp oqpqcnrjcdgvkswg guv ukorng"

             Pour dechiffre, il faut faire le decalage OPPOSE (le signe change), c'est a dire -2.

             Qui a dit que la crypto etait compliquee ?

             Bon maintenant on va essayer d'automatiser tout ca avec un petit code.
            
-------------8<-------------cut-------------8<-----------------cut-------------8<-------------

#include <stdio.h>
#include <string.h>
#define TAILLE 100              /* modifie ici pour un texte de plus de 100 caracteres */

int main (int argc , char **argv)
{
   int i ,
       cle ;
   char mode [6] ;              /* mode encode ou decode */
   char entree[TAILLE] ;        /* texte entree par l utilisateur */
   char sortie[TAILLE] ;        /* texte sortie apres modification */

   if(argc < 4)
      {
      printf("aide : %s <\"texte\"> <cle> <mode : (E)ncode ou (D)ecode>",argv[0]) ;
      exit(0);
      }

   strcpy(entree, argv[1]) ;
   strcpy(mode, argv[3]) ;
   cle = atoi(argv[2]) ;

   if ((mode[0] == 'E') || (mode[0] == 'e'))
      {
      for(i=0 ; i<strlen(entree) ; i++)
	      {
          sortie[i] = entree[i] + cle ;
	      }
      printf ("Voici le texte code : %s \n",sortie);
      }
   else if ((mode[0] == 'D') || (mode[0] == 'd'))
        {
        for(i=0 ; i<strlen(entree) ; i++)
	       {
	       sortie[i] = entree[i] - cle ;
	       }
   	    printf ("Voici le texte decode : %s \n",sortie);
   	    }
   return 0;
}

-------------8<-------------cut-------------8<-----------------cut-------------8<-------------


      4.1.2. Cryptanalyse d un systeme monoalphabetique
      -------------------------------------------------
             Pour analyser un chiffrement de ce type, il suffit de tester les 26 possibilites.

             On peut aussi faire un analyse de frequence. Cette analyse correspond a observer la
             frequence d'apparition des lettres (ou caracteres) pour une langues donnees, et a
             comparer cette observation avec une table de frequence de la langue.
             Voici la frequences des caracteres dans un texte francais :

                         A : 0.083944
			 B : 0.007669
			 C : 0.033297
			 D : 0.040699
			 E : 0.145037
			 F : 0.012109
			 G : 0.009495
			 H : 0.007973
			 I : 0.081828
			 J : 0.006377
			 K : 0.000638
			 L : 0.058405
			 M : 0.029355
			 N : 0.075570
			 O : 0.053669
			 P : 0.032087
			 Q : 0.012613
			 R : 0.070209
			 S : 0.080091
			 T : 0.074775
			 U : 0.059808
			 V : 0.015791
			 W : 0.000067
			 X : 0.004098
			 Y : 0.003155
			 Z : 0.001240

             On voit que le E apparait plus frequement que le reste de l'alphabet.

             Ainsi pour l exemple precedent, on voit que les lettre qui apparaisse le plus sont :
             V / KUG / CW / OP / JS...

             On pourrai donc croire que le E a ete remplace un V par des E.En applicant le decalage
             au reste du texte ca donne :

             WL DFMDETEFETZY XZYZLWASLMPETBFP PDE DTXAWP ==>ca veut pas dire grand chose,
                                                            on passe a V=A
             SH ZBIZAPABAPVU TVUVHSWOHILAPXBL LZA ZPTWSL ==>ca veut rien dire non plus,

             On continu avec v=S, puis v=I, puis v=T, jusqu a ce qu on trouve :
             avec v=T ==>JACKPOT, on trouve une phrase qui signifie quelque chose :
             LA SUBSTITUTION MONOALPHABETIQUE EST SIMPLE (le texte clair).

             L'analyse de frequence est plus performante avec les gros textes.
             Vous avez compris ? Passons au code :

-------------8<-------------cut-------------8<-----------------cut-------------8<-------------

#include <stdio.h>
#include <string.h>
#define alpha 26
#define TAILLE 100                  /* modifie ici pour un texte de plus de 100 caracteres */


void init(void);                    /* initialisation */

char caractere[alpha][2] ;
char texte[TAILLE] ;                /* texte a analyser */
int compte[alpha] ;                 /* pour compter les differentes lettres */
float pourcent[alpha] ;             /* pour calculer le pourcentage */

int total = 0 ;                     /* nombre total de caractere dans le texte */


int main(int argc, char **argv)
{
   int i, j ;
   init() ;

   if(argc < 2)
      {
      printf("aide : %s <\"texte\"> ",argv[0]) ;
      exit(0) ;
      }

   strcpy(texte, argv[1]) ;

   for (i=0 ; i<strlen(texte) ; i++)
      {
      total++ ;
      for (j=0 ; j<26 ; j++)
         {
         if ((texte[i] == caractere[j][0])||(texte[i] == caractere[j][1]))
                 compte[j]++ ;
         }
      }


   printf("Voici l\'analyse de frequence :\n\n");

   for (i=0 ; i<alpha ; i++)
      if (compte[i] != 0)
      {
      pourcent[i] = ( compte[i] * 100 ) / total ;
      printf("\t%.2f%% de %c.\n", pourcent[i], caractere[i][0]);
      }

   return 0 ;
}


void init(void)
{
   int i ;
   for(i=0 ; i<alpha ; i++)
      {
      caractere[i][0]='A'+i;
      caractere[i][1]='a'+i;
      compte[i] = 0 ;
      pourcent[i] = 0 ;
      }
}

-------------8<-------------cut-------------8<-----------------cut-------------8<-------------



             On peut aussi faire une analyse de frequence des bigrammes ou des trigrammes.
             (cf l'annexe pour une table de frequence des bigrammes :-)



  4.2.La substitution polyalphabetique
  ====================================
        On vient de voir de dans la substitution monoalphabetique, qu'on utilisait un alphabet
      chiffre par alphabet clair, et qu on gardait cette alphabet chiffre tout au long du
      chiffrement. Avec la subtitution polyalphabetique, l'alphabet chiffre varie en fonction de
      la cle choisie, ce qui le rendra beaucoup plus sur que le precedent. Par exemple, on pourra
      utiliser x subtitution monoalphabetique.
        On trouve dans cette categorie le XOR (OU exclusif), le chiffre de VIGENERE que nous
      etudirons,le chiffre de Gronsfeld (un adaptation de CESAR), le chiffre de beaufort (une
      variante du chiffre de VIGENERE), et bien d'autres... :-)

      4.2.1.LE CHIFFRE DE VIGENERE
      ----------------------------
              Le chiffre de vigere repose sur une grille, comportant 26 alphabets decales. Cette
            grille est appelee CARRE DE VIGENERE :


              CLE/CLAIR |a b c d e f g h i j k l m n o p q r s t u v w x y z
             _______________________________________________________________
               a (0)    |A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
               b (1)    |B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
               c (2)    |C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
               d (3)    |D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
               e (4)    |E F G H I J K L M N O P Q R S T U V W X Y Z A B C D
               f (5)    |F G H I J K L M N O P Q R S T U V W X Y Z A B C D E
               g (6)    |G H I J K L M N O P Q R S T U V W X Y Z A B C D E F
               h (7)    |H I J K L M N O P Q R S T U V W X Y Z A B C D E F G
               i (8)    |I J K L M N O P Q R S T U V W X Y Z A B C D E F G H
               j (9)    |J K L M N O P Q R S T U V W X Y Z A B C D E F G H I
               k (10)   |K L M N N O Q R S T U V W X Y Z A B C D E F G H I J
               l (11)   |L M N O P Q R S T U V W X Y Z A B C D E F G H I J K
               m (12)   |M N O P Q R S T U V W X Y Z A B C D E F G H I J K L
               n (13)   |N O P Q R S T U V W X Y Z A B C D E F G H I J K L M
               o (14)   |O P Q R S T U V W X Y Z A B C D E F G H I J K L M N
               p (15)   |P Q R S T U V W X Y Z A B C D E F G H I J K L M N O
               q (16)   |Q R S T U V W X Y Z A B C D E F G H I J K L M N O P
               r (17)   |R S T U V W X Y Z A B C D E F G H I J K L M N O P Q
               s (18)   |S T U V W X Y Z A B C D E F G H I J K L M N O P Q R
               t (19)   |T U V W X Y Z A B C D E F G H I J K L M N O P Q R S
               u (20)   |U V W X Y Z A B C D E F G H I J K L M N O P Q R S T
               v (21)   |V W X Y Z A B C D E F G H I J K L M N O P Q R S T U
               w (22)   |W X Y Z A B C D E F G H I J K L M N O P Q R S T U V
               x (23)   |X Y Z A B C D E F G H I J K L M N O P Q R S T U V W
               y (24)   |Y Z A B C D E F G H I J K L M N O P Q R S T U V W X
               z (25)   |Z A B C D E F G H I J K L M N O P Q R S T U V W X Y

              La premier ligne correspond a l'alphabet normal, et en dessous on retrouve les 26
            alphabets tous decales les uns par rapports au autres. La colonne de gauche, on a la
            cle correspondant a l alphabet decale.

              Dans le chiffre de CESAR, on utiliser qu un seul de ces alphabets decales pour obtenir,
            le texte chiffe. Avec Vigenere, on utilise plusieurs alphabets, avec un systeme de mot cle
            qui sera utilise periodiquement (plusieurs fois).
              Prenons comme exemple, le texte VIGENERE EST TRES SIMPLE comme texte clair, avec la
            cle CRYPTO :


            txt clair   :  V|I|G|E|N|E| |R|E|E|S|T|T| |R|E|S|S|I|M| |P|L|E
            CLE         :  C|R|Y|P|T|O| |C|R|Y|P|T|O| |C|R|Y|P|T|O| |C|R|Y
            txt chiffre :  X|Z|E|T|G|S| |T|V|D|G|M|H| |T|V|Q|H|B|A| |R|C|D


              On prend la lettre du message clair, puis on la chiffre avec l'alphabet correspond a la
            du mot cle juste en dessous. Pour le V, on regarde l alphabet C, et ainsi de suite...
              Le mot cle est reutilise plusieur fois, mais rien ne vous empeche de prendre une cle
            aussi longue que le texte  lui meme, d'ailleurs je vous le recommande vivement.
              Ce type de chiffrement est plus securise que les precedents, on se rend compte (dans le
            cas ou le mot cle est re-utilise) qu'une meme lettre clair peut avoir plusieurs correspondances
            chiffrees :
            dans l'exemple, la lettre E est chiffre en T, S, V, D...

      4.2.2.Cryptanalyse de VIGENERE
      ------------------------------

              Pour analyser un chiffrement par Vigenere, il nous faut la taille de la cle. Car on a vu,
            que pour une cle de "x" caractere, les caracteres du texte clair sont chiffres avec le meme
            decalage tous les "x" caractere.

              Prenons un exemple :

            Texte chiffre : NVAWBT HICSXJ KXCCXF GVQINB GJSQLH KKSIBC PGMARO NGFPUS VZOJXH TVQHBA
                            RCCSXD NLQXES UKNANG UVAJKW UVOJXZ GTFXYT TVBTVS URP

            Taille de la cle : 6

            _____________
            |N|V|A|W|B|T|         Dans ce tableau, on obtient 6 groupes, chacun chiffre avec une
            |H|I|C|S|X|J|       lettre de la cle :
            |K|X|C|C|X|F|
            |G|V|Q|I|N|B|       .le premier groupe :   NHKGGKPNVTRNUUUGTU ont le meme decalage
            |G|J|S|Q|L|H|       .le deuxieme groupe :  VIXVJKGGZVCLKVVTVR
            |K|K|S|I|B|C|       .le troisieme :        ACCQSSMFOQCQNAOFBP
            |P|G|M|A|R|O|       .le quatrieme :        WSCIQIAPJHSXAJJXT
            |N|G|F|P|U|S|       .le cinquieme :        BXXNLBRUXBXENKXYV
            |V|Z|O|J|X|H|       .et enfin le sixieme : TJFBHCOSHADSGWZTS
            |T|V|Q|H|B|A|
            |R|C|C|S|X|D|         On peut maintenant effectuer un analyse de frequence pour chacun des
            |N|L|Q|X|E|S|       groupes.
            |U|K|N|A|N|G|         Donc a vous de jouer... la reponse  se trouve a la fin de l annexe. :-)
            |U|V|A|J|K|W|
            |U|V|O|J|X|Z|
            |G|T|F|X|Y|T|
            |T|V|B|T|V|S|
            |U|R|P|


 5. EPILOGUE
************

    Voila la crypto c'est fini pour aujourd'hui. On a vu quelques chiffrements tres simple.
  J'espere que vous avez bien assimiler leur principes. Interrogation ecrite dans le prochain numero ;)

    Que dire de plus, si ce n'est que la cryptographie est la seule methode pour proteger vos donnees
  des regards indiscrets et des petits curieux. De plus si vous-meme etes un petit curieux, il vous
  est indispensable de connaitre un maximum d'algorithme de cryptage... et d'en exploiter leur
  puissance et leur faiblesse.

  Quelques liens pour vous aider au cas ou  :
      http://www.apprendre-en-ligne.net/crypto/index.html
      http://www.uqtr.ca/~delisle/Crypto/

 6. ANNEXE
**********

    Fréquences des doublets:
    ========================

 AA : 0.000252 	 AB : 0.001760 	 AC : 0.003482 	 AD : 0.001960
 AE : 0.000200 	 AF : 0.001307 	 AG : 0.002012 	 AH : 0.000126
 AI : 0.016051 	 AJ : 0.000304 	 AK : 0.000000 	 AL : 0.005650
 AM : 0.002910 	 AN : 0.013957 	 AO : 0.000200 	 AP : 0.003727
 AQ : 0.000393 	 AR : 0.007298 	 AS : 0.005405 	 AT : 0.006199
 AU : 0.005420 	 AV : 0.004603 	 AW : 0.000000 	 AX : 0.000030
 AY : 0.000445 	 AZ : 0.000260 	 BA : 0.000601 	 BB : 0.000015
 BC : 0.000030 	 BD : 0.000037 	 BE : 0.000802 	 BF : 0.000000
 BG : 0.000000 	 BH : 0.000000 	 BI : 0.001188 	 BJ : 0.000074
 BK : 0.000000 	 BL : 0.002086 	 BM : 0.000000 	 BN : 0.000030
 BO : 0.000935 	 BP : 0.000007 	 BQ : 0.000000 	 BR : 0.001062
 BS : 0.000238 	 BT : 0.000097 	 BU : 0.000431 	 BV : 0.000000
 BW : 0.000000 	 BX : 0.000000 	 BY : 0.000037 	 BZ : 0.000000
 CA : 0.002821 	 CB : 0.000015 	 CC : 0.000876 	 CD : 0.000342
 CE : 0.008456 	 CF : 0.000045 	 CG : 0.000022 	 CH : 0.004417
 CI : 0.002747 	 CJ : 0.000015 	 CK : 0.000045 	 CL : 0.001232
 CM : 0.000067 	 CN : 0.000119 	 CO : 0.006511 	 CP : 0.000126
 CQ : 0.000097 	 CR : 0.001626 	 CS : 0.000260 	 CT : 0.002138  
 CU : 0.001292 	 CV : 0.000007 	 CW : 0.000000 	 CX : 0.000000
 CY : 0.000015 	 CZ : 0.000007 	 DA : 0.004603 	 DB : 0.000230
 DC : 0.000780 	 DD : 0.000356 	 DE : 0.019570 	 DF : 0.000126
 DG : 0.000067 	 DH : 0.000171 	 DI : 0.004157 	 DJ : 0.000245
 DK : 0.000007 	 DL : 0.000371 	 DM : 0.000445 	 DN : 0.000215
 DO : 0.002487 	 DP : 0.000371 	 DQ : 0.000067 	 DR : 0.001329
 DS : 0.000549 	 DT : 0.000527 	 DU : 0.003838 	 DV : 0.000171
 DW : 0.000000 	 DX : 0.000000 	 DY : 0.000015 	 DZ : 0.000000
 EA : 0.003378 	 EB : 0.000802 	 EC : 0.008330 	 ED : 0.008449
 EE : 0.002851 	 EF : 0.002925 	 EG : 0.001618 	 EH : 0.000393
 EI : 0.002576 	 EJ : 0.001811 	 EK : 0.000171 	 EL : 0.012220
 EM : 0.008018 	 EN : 0.021248 	 EO : 0.001225 	 EP : 0.007365
 EQ : 0.002881 	 ER : 0.014470 	 ES : 0.023809 	 ET : 0.008634
 EU : 0.006622 	 EV : 0.002873 	 EW : 0.000052 	 EX : 0.001544
 EY : 0.000059 	 EZ : 0.000705 	 FA : 0.002858 	 FB : 0.000000
 FC : 0.000022 	 FD : 0.000386 	 FE : 0.000854 	 FF : 0.001247
 FG : 0.000000 	 FH : 0.000000 	 FI : 0.002056 	 FJ : 0.000000
 FK : 0.000000 	 FL : 0.000334 	 FM : 0.000007 	 FN : 0.000000
 FO : 0.001648 	 FP : 0.000074 	 FQ : 0.000030 	 FR : 0.001908
 FS : 0.000111 	 FT : 0.000067 	 FU : 0.000483 	 FV : 0.000022
 FW : 0.000000 	 FX : 0.000000 	 FY : 0.000000 	 FZ : 0.000000
 GA : 0.000950 	 GB : 0.000007 	 GC : 0.000030 	 GD : 0.000082
 GE : 0.002791 	 GF : 0.000015 	 GG : 0.000097 	 GH : 0.000015
 GI : 0.000854 	 GJ : 0.000022 	 GK : 0.000000 	 GL : 0.000297
 GM : 0.000067 	 GN : 0.001522 	 GO : 0.000453 	 GP : 0.000030
 GQ : 0.000037 	 GR : 0.001076 	 GS : 0.000134 	 GT : 0.000200
 GU : 0.000787 	 GV : 0.000015 	 GW : 0.000000 	 GX : 0.000007
 GY : 0.000007 	 GZ : 0.000000 	 HA : 0.001604 	 HB : 0.000015
 HC : 0.000022 	 HD : 0.000037 	 HE : 0.002376 	 HF : 0.000000
 HG : 0.000000 	 HH : 0.000007 	 HI : 0.000802 	 HJ : 0.000007
 HK : 0.000000 	 HL : 0.000082 	 HM : 0.000089 	 HN : 0.000074
 HO : 0.001485 	 HP : 0.000141 	 HQ : 0.000030 	 HR : 0.000319
 HS : 0.000238 	 HT : 0.000089 	 HU : 0.000342 	 HV : 0.000007
 HW : 0.000007 	 HX : 0.000000 	 HY : 0.000200 	 HZ : 0.000000
 IA : 0.001685 	 IB : 0.000579 	 IC : 0.002866 	 ID : 0.003964
 IE : 0.007038 	 IF : 0.000950 	 IG : 0.001418 	 IH : 0.000015
 II : 0.000223 	 IJ : 0.000327 	 IK : 0.000022 	 IL : 0.010178
 IM : 0.002034 	 IN : 0.008723 	 IO : 0.004833 	 IP : 0.000839
 IQ : 0.002056 	 IR : 0.006132 	 IS : 0.011314 	 IT : 0.014596
 IU : 0.000119 	 IV : 0.001529 	 IW : 0.000000 	 IX : 0.000334
 IY : 0.000000 	 IZ : 0.000052 	 JA : 0.001373 	 JB : 0.000000
 JC : 0.000000 	 JD : 0.000000 	 JE : 0.003036 	 JF : 0.000007
 JG : 0.000000 	 JH : 0.000000 	 JI : 0.000052 	 JJ : 0.000000
 JK : 0.000000 	 JL : 0.000007 	 JM : 0.000000 	 JN : 0.000022
 JO : 0.001106 	 JP : 0.000015 	 JQ : 0.000007 	 JR : 0.000000
 JS : 0.000000 	 JT : 0.000126 	 JU : 0.000609 	 JV : 0.000007
 JW : 0.000000 	 JX : 0.000000 	 JY : 0.000007 	 JZ : 0.000000
 KA : 0.000208 	 KB : 0.000000 	 KC : 0.000000 	 KD : 0.000000
 KE : 0.000052 	 KF : 0.000000 	 KG : 0.000015 	 KH : 0.000000
 KI : 0.000097 	 KJ : 0.000000 	 KK : 0.000000 	 KL : 0.000007
 KM : 0.000000 	 KN : 0.000000 	 KO : 0.000037 	 KP : 0.000000
 KQ : 0.000000 	 KR : 0.000007 	 KS : 0.000007 	 KT : 0.000000
 KU : 0.000193 	 KV : 0.000000 	 KW : 0.000000 	 KX : 0.000000
 KY : 0.000015 	 KZ : 0.000000 	 LA : 0.011737 	 LB : 0.000089
 LC : 0.000579 	 LD : 0.000869 	 LE : 0.018835 	 LF : 0.000564
 LG : 0.000193 	 LH : 0.000490 	 LI : 0.004729 	 LJ : 0.000319
 LK : 0.000030 	 LL : 0.005338 	 LM : 0.000772 	 LN : 0.001062
 LO : 0.002836 	 LP : 0.000735 	 LQ : 0.000587 	 LR : 0.000327
 LS : 0.001552 	 LT : 0.001247 	 LU : 0.004299 	 LV : 0.000468
 LW : 0.000000 	 LX : 0.000000 	 LY : 0.000742 	 LZ : 0.000007
 MA : 0.005872 	 MB : 0.001032 	 MC : 0.000059 	 MD : 0.001210
 ME : 0.008619 	 MF : 0.000022 	 MG : 0.000007 	 MH : 0.000000
 MI : 0.003586 	 MJ : 0.000022 	 MK : 0.000000 	 ML : 0.000074
 MM : 0.002487 	 MN : 0.000134 	 MO : 0.003051 	 MP : 0.002205
 MQ : 0.000022 	 MR : 0.000245 	 MS : 0.000037 	 MT : 0.000119
 MU : 0.000453 	 MV : 0.000000 	 MW : 0.000000 	 MX : 0.000000
 MY : 0.000097 	 MZ : 0.000000 	 NA : 0.004469 	 NB : 0.000200
 NC : 0.005108 	 ND : 0.007246 	 NE : 0.010668 	 NF : 0.001440
 NG : 0.001425 	 NH : 0.000319 	 NI : 0.003229 	 NJ : 0.000423
 NK : 0.000022 	 NL : 0.001166 	 NM : 0.001151 	 NN : 0.002866
 NO : 0.003809 	 NP : 0.001760 	 NQ : 0.000831 	 NR : 0.000973
 NS : 0.009132 	 NT : 0.017009 	 NU : 0.000987 	 NV : 0.001054
 NW : 0.000000 	 NX : 0.000015 	 NY : 0.000193 	 NZ : 0.000074
 OA : 0.000052 	 OB : 0.000735 	 OC : 0.001284 	 OD : 0.000423
 OE : 0.000163 	 OF : 0.000557 	 OG : 0.000587 	 OH : 0.000067
 OI : 0.005999 	 OJ : 0.000089 	 OK : 0.000015 	 OL : 0.001641
 OM : 0.003385 	 ON : 0.016207 	 OO : 0.000089 	 OP : 0.001136
 OQ : 0.000290 	 OR : 0.004529 	 OS : 0.002064 	 OT : 0.001515
 OU : 0.011782 	 OV : 0.000342 	 OW : 0.000000 	 OX : 0.000015
 OY : 0.000705 	 OZ : 0.000000 	 PA : 0.007580 	 PB : 0.000000
 PC : 0.000223 	 PD : 0.000126 	 PE : 0.003378 	 PF : 0.000000
 PG : 0.000000 	 PH : 0.000601 	 PI : 0.001277 	 PJ : 0.000015
 PK : 0.000000 	 PL : 0.003096 	 PM : 0.000015 	 PN : 0.000037
 PO : 0.004781 	 PP : 0.001448 	 PQ : 0.000007 	 PR : 0.007313
 PS : 0.000475 	 PT : 0.000631 	 PU : 0.001076 	 PV : 0.000000
 PW : 0.000000 	 PX : 0.000000 	 PY : 0.000000 	 PZ : 0.000007  
 QA : 0.000030 	 QB : 0.000000 	 QC : 0.000000 	 QD : 0.000000
 QE : 0.000000 	 QF : 0.000007 	 QG : 0.000000 	 QH : 0.000007
 QI : 0.000000 	 QJ : 0.000000 	 QK : 0.000000 	 QL : 0.000000
 QM : 0.000000 	 QN : 0.000000 	 QO : 0.000000 	 QP : 0.000000
 QQ : 0.000000 	 QR : 0.000000 	 QS : 0.000000 	 QT : 0.000000
 QU : 0.012569 	 QV : 0.000000 	 QW : 0.000000 	 QX : 0.000000
 QY : 0.000000 	 QZ : 0.000000 	 RA : 0.010201 	 RB : 0.000238
 RC : 0.002257 	 RD : 0.003437 	 RE : 0.016622 	 RF : 0.000601
 RG : 0.000965 	 RH : 0.000104 	 RI : 0.005115 	 RJ : 0.000371
 RK : 0.000141 	 RL : 0.003660 	 RM : 0.001908 	 RN : 0.001084
 RO : 0.004744 	 RP : 0.001307 	 RQ : 0.000831 	 RR : 0.002457
 RS : 0.007164 	 RT : 0.004106 	 RU : 0.001455 	 RV : 0.001321
 RW : 0.000000 	 RX : 0.000015 	 RY : 0.000037 	 RZ : 0.000067
 SA : 0.007595 	 SB : 0.000520 	 SC : 0.003274 	 SD : 0.005034
 SE : 0.011864 	 SF : 0.001032 	 SG : 0.000327 	 SH : 0.000371
 SI : 0.007535 	 SJ : 0.000898 	 SK : 0.000111 	 SL : 0.004224
 SM : 0.002873 	 SN : 0.000831 	 SO : 0.005820 	 SP : 0.004247
 SQ : 0.002220 	 SR : 0.001396 	 SS : 0.006830 	 ST : 0.008077
 SU : 0.003935 	 SV : 0.000802 	 SW : 0.000007 	 SX : 0.000000
 SY : 0.000260 	 SZ : 0.000007 	 TA : 0.008790 	 TB : 0.000371
 TC : 0.002094 	 TD : 0.004944 	 TE : 0.012940 	 TF : 0.000616
 TG : 0.000312 	 TH : 0.000690 	 TI : 0.009154 	 TJ : 0.000809
 TK : 0.000067 	 TL : 0.003779 	 TM : 0.001522 	 TN : 0.000653
 TO : 0.003816 	 TP : 0.003630 	 TQ : 0.001752 	 TR : 0.007105
 TS : 0.004172 	 TT : 0.004469 	 TU : 0.002546 	 TV : 0.000490
 TW : 0.000000 	 TX : 0.000000 	 TY : 0.000052 	 TZ : 0.000000
 UA : 0.001685 	 UB : 0.001039 	 UC : 0.001455 	 UD : 0.001344
 UE : 0.008248 	 UF : 0.000468 	 UG : 0.000364 	 UH : 0.000104
 UI : 0.007246 	 UJ : 0.000497 	 UK : 0.000007 	 UL : 0.002405
 UM : 0.001218 	 UN : 0.006637 	 UO : 0.000631 	 UP : 0.001990
 UQ : 0.000186 	 UR : 0.009688 	 US : 0.005360 	 UT : 0.004544
 UU : 0.000371 	 UV : 0.001908 	 UW : 0.000000 	 UX : 0.002131
 UY : 0.000238 	 UZ : 0.000045 	 VA : 0.003786 	 VB : 0.000000
 VC : 0.000059 	 VD : 0.000082 	 VE : 0.004625 	 VF : 0.000000
 VG : 0.000007 	 VH : 0.000007 	 VI : 0.002725 	 VJ : 0.000007
 VK : 0.000000 	 VL : 0.000223 	 VM : 0.000007 	 VN : 0.000052
 VO : 0.003007 	 VP : 0.000007 	 VQ : 0.000022 	 VR : 0.000883
 VS : 0.000111 	 VT : 0.000022 	 VU : 0.000156 	 VV : 0.000000
 VW : 0.000000 	 VX : 0.000000 	 VY : 0.000000 	 VZ : 0.000000
 WA : 0.000015 	 WB : 0.000000 	 WC : 0.000000 	 WD : 0.000000
 WE : 0.000015 	 WF : 0.000000 	 WG : 0.000007 	 WH : 0.000000
 WI : 0.000015 	 WJ : 0.000000 	 WK : 0.000000 	 WL : 0.000000
 WM : 0.000000 	 WN : 0.000000 	 WO : 0.000000 	 WP : 0.000000
 WQ : 0.000007 	 WR : 0.000000 	 WS : 0.000000 	 WT : 0.000007
 WU : 0.000000 	 WV : 0.000000 	 WW : 0.000000 	 WX : 0.000000
 WY : 0.000000 	 WZ : 0.000000 	 XA : 0.000698 	 XB : 0.000015
 XC : 0.000319 	 XD : 0.000267 	 XE : 0.000423 	 XF : 0.000148
 XG : 0.000007 	 XH : 0.000059 	 XI : 0.000379 	 XJ : 0.000074
 XK : 0.000000 	 XL : 0.000163 	 XM : 0.000245 	 XN : 0.000015
 XO : 0.000082 	 XP : 0.000497 	 XQ : 0.000208 	 XR : 0.000030
 XS : 0.000148 	 XT : 0.000267 	 XU : 0.000015 	 XV : 0.000007
 XW : 0.000000 	 XX : 0.000007 	 XY : 0.000022 	 XZ : 0.000000
 YA : 0.000831 	 YB : 0.000000 	 YC : 0.000119 	 YD : 0.000052
 YE : 0.000401 	 YF : 0.000015 	 YG : 0.000030 	 YH : 0.000000
 YI : 0.000007 	 YJ : 0.000022 	 YK : 0.000000 	 YL : 0.000037
 YM : 0.000089 	 YN : 0.000067 	 YO : 0.000067 	 YP : 0.000327
 YQ : 0.000030 	 YR : 0.000030 	 YS : 0.000950 	 YT : 0.000052
 YU : 0.000015 	 YV : 0.000015 	 YW : 0.000000 	 YX : 0.000000
 YY : 0.000000 	 YZ : 0.000000 	 ZA : 0.000267 	 ZB : 0.000007
 ZC : 0.000030 	 ZD : 0.000052 	 ZE : 0.000208 	 ZF : 0.000015
 ZG : 0.000015 	 ZH : 0.000007 	 ZI : 0.000030 	 ZJ : 0.000022
 ZK : 0.000000 	 ZL : 0.000134 	 ZM : 0.000045 	 ZN : 0.000015
 ZO : 0.000015 	 ZP : 0.000104 	 ZQ : 0.000022 	 ZR : 0.000007
 ZS : 0.000030 	 ZT : 0.000037 	 ZU : 0.000015 	 ZV : 0.000148
 ZW : 0.000000 	 ZX : 0.000000 	 ZY : 0.000007 	 ZZ : 0.000007



Reponse de la cryptanalyse du chiffre de Vigenere :
"Le chiffre de Vigenere est une substitution polyalphabetique tres simple.
 De plus il est plus securise que le chiffre de cesar."




--------------------------------------------------------
BFZ#1/ UndergroundZ links                            N/A
--------------------------------------------------------

>>> http://www.brainfaktor.org
	Le site de la crew. reposito, forum, newsletter..

>>> http://www.madchat.org
	Le bon vieux chat

>>> http://la-cave.homelinux.com
	Plein de bonnes docs sur le phreaking

>>> http://abyssal.homelinux.org
	Le site a groar, beaucoup de docs

>>> http://lsdp.net/~lotfree/
	Land of the free mag

>>> http://ouah.org
	Excellent site !

>>> http://hyatus.newffr.com (voir aussi newffr.com)
	Reposito, forum..

>>> http://miaouw.c0m.st
	Orienté anar, cyberpunk..


              -=-=-=-=-=-=-=-=-=-==-[ Zi End ]-=-=-=-=-=-=-=-=-=-=-=-

	Voilà, c'est la fin de ce premier numero. Si vous avez des articles que vous
voulez voir publié dans BFZ, ecrivez a zine@brainfaktor.org. On accepte tous types
d'articles, ca peut aller du truc super technique a de la philo etc...
A bientôt pour la 2eme issue !

Le Staff


                                     - EOF -

