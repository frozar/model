<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Appendix D: Solutions to Selected Exercises</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<BODY>
<H1><a name="D_0"><I>Solutions to Selected Exercises</I></a></H1>
<H3>Chapter 1</H3>
<P>
<B>1.1</B> The value is 2<SUP>7</SUP>-2
(126) plus 2<SUP>14</SUP> - 2 (16,382) plus 2<SUP>21</SUP> - 2
(2,097,150) for a total of 2,113,658. We subtract 2 in each calculation
since a network ID of all zero bits or all one bits is invalid.
<P>
<B>1.2</B> Figure D.1 shows a
plot of the values through August 1993.
<P>
<CENTER><a name="fig_D_1"><img src="f_d_1.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_d_1.gif"></a><br>
<B>Figure D.1</B> Number
of networks announced to NSFNET.</CENTER>
<P>
The dashed line estimates that the maximum number
of networks will be reached in the year 2000, if the exponential
growth continues.
<P>
<B>1.3</B> &quot;Be liberal in
what you accept, and conservative in what you send.&quot;
<H3>Chapter 3</H3>
<P>
<B>3.1</B> No, any class A address
with a network ID of 127 is OK, although most systems use 127.0.0.1.
<P>
<B>3.2</B> <TT>kpno</TT>
has five interfaces: three point-to-point links and two Ethernets.
RIO has four Ethernet interfaces, <TT>gateway</TT>
has three interfaces: two point-to-point links and one Ethernet.
Finally, <TT>netb</TT> has one Ethernet interface
and two point-to-point links.
<P>
<B>3.3</B> There's no difference:
both have a subnet mask of 255.255.255.0, as does a class C address
that is not subnetted.
<P>
<B>3.5</B> It's valid and it's
called a <I>noncontiguous subnet mask</I> since the 16 bits for
the subnet mask are not contiguous. The RECs, however, recommend
against using noncontiguous subnet masks.
<P>
<B>3.6</B> It's a historical
artifact. The value is 1024+512 but the MTU values printed include
any required headers. Solaris 2.2 sets the MTU of the loopback
interface to 8232 (8192 + 40), which allows room for 8192 bytes
of user data along with the normal 20-byte IP header and 20-byte
TCP header.
<P>
<B>3.7</B> First, datagrams eliminate
the need for connection state in the routers. Second, datagrams
provide the basic building block on which unreliable (UDP) and
reliable (TCP) transport layers can be built. Third, datagrams
represent the minimal network layer assumption, allowing a wide
range of data-link layers to be used.
<H3>Chapter 4</H3>
<P>
<B>4.1</B> Issuing an <TT>rsh</TT>
command establishes a TCP connection with the other host. Doing
that causes IP datagrams to be exchanged between the two hosts.
This requires the ARP cache on the other host to have an entry
for our host. Therefore, even if the ARP cache was empty before
we executed the <TT>rsh</TT> command, it's
guaranteed to have an entry for our host when the <TT>rsh</TT>
server executes the <TT>arp</TT> command.
<P>
<B>4.2</B> Make sure that your
host does not have an entry in its ARP cache for some other host
on its Ethernet, say <TT>foo</TT>. Make sure
<TT>foo</TT> sends a gratuitous ARP request
when it bootstraps, perhaps running tcpdump on another host when
<TT>foo</TT> bootstraps. Then shut down the
host <TT>foo</TT> and enter an incorrect entry
into the ARP cache on your system for <TT>foo</TT>,
using the arp command and being sure to specify the temp option.
Bootstrap <TT>foo</TT> and when it's up, look
at your host's ARP cache entry for it to see whether the incorrect
entry has been corrected.
<P>
<B>4.3</B> Read Section 2.3.2.2
of the Host Requirements REC and <a href="udp_user.htm#11_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/udp_user.htm#11_9">Section 11.9</a> of this text.
<P>
<B>4.4</B> Assuming that a completed
ARP entry existed for the server on the client when the server
was taken down, if we continually try to contact the (down) server,
the ARP timeout gets extended for another 20 minutes. When the
server finally reboots with a new hardware address, if it doesn't
issue a gratuitous ARP, the old, invalid ARP entry will still
exist on the client. We won't be able to contact the server at
its new hardware address until we either manually delete the ARP
cache entry or stop trying to contact it for 20 minutes.
<H3>Chapter 5</H3>
<P>
<B>5.1</B> A separate frame type
is not an absolute requirement, since the <I>op</I> field in Figure
4.3 has a different value for all four operations (ARP request,
ARP reply, RARP request, and RARP reply). But the implementation
of an RARP server, separate from the kernel's ARP server, is made
easier with the different frame type field.
<P>
<B>5.2</B> Each RARP server can
delay for a small random time before sending a response.
<P>
As a refinement, one RARP server can be designated
the primary and the others as secondaries. The primary server
can respond without a delay, and the secondaries with random delays.
<P>
As yet another refinement, with a primary and secondaries,
the secondaries can be programmed to respond only to a duplicate
request received in a short time frame. This assumes that the
reason for the duplicate request is that the primary is down.
<H3>Chapter 6</H3>
<P>
<B>6.1</B> If there were one
hundred hosts on the local cable, each could try to send an ICMP
port unreachable at about the same time. Many of these transmissions
could lead to collisions (if an Ethernet is being used), which
can render the network useless for a second or two.
<P>
<B>6.2</B> It is a &quot;should.&quot;
<P>
<B>6.3</B> An ICMP error is always
sent with a TOS of 0, as we indicated in <a href="ip_inter.htm#fig_3_2" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/ip_inter.htm#fig_3_2">Figure 3.2</a>. An ICMP query
request can be sent with any TOS, and the corresponding reply
should be sent with the same TOS.
<P>
<B>6.4</B> <TT>netstat
-s</TT> is the common way to see the per-protocol
statistics. On a SunOS 4.1.1 host (<TT>gemini</TT>)
that has received 48 million IP datagrams, the ICMP statistics
are:
<TABLE>
<TR><TD COLSPAN=2 WIDTH=310><TT>Output histogram:</TT></TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>echo reply: 1757</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>destination unreachable: 700</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>time stamp reply: 1</TT>
</TD></TR>
<TR><TD COLSPAN=2 WIDTH=310><TT>Input histogram:</TT></TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>echo reply: 211</TT></TD>
</TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>destination unreachable: 3071</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>source quench: 249</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>routing redirect: 2789</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>echo: 1757</TT></TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>#10: 21</TT></TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>time exceeded: 56</TT>
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=255><TT>time stamp: 1</TT></TD>
</TR>
</TABLE>
<P>
The 21 input messages of type 10 are router solicitations
that SunOS 4.1.1 doesn't support.
<P>
SNMP can also be used (<a href="snmp_sim.htm#fig_25_26" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/snmp_sim.htm#fig_25_26">Figure 25.26</a>) and some systems,
such as Solaris 2.2, generate <TT>netstat -s</TT>
output that uses SNMP variable names.
<H3>Chapter 7</H3>
<P>
<B>7.2</B> 86 bytes divided by
960 bytes/sec, times 2 gives 179.2 ms. When ping is run at this
speed, the printed values are 180 ms.
<P>
<B>7.3</B> (86 + 48) bytes divided
by 960 bytes/sec, times 2 gives 279.2 ms. The additional 48 bytes
are because the final 48 bytes of the 56 bytes in the data portion
must be escaped: <TT>0xc0</TT> is the SLIP
END character.
<P>
<B>7.4</B> CSLIP only compresses
the TCP and IP headers for TCP segments. It has no effect on the
ICMP messages used by <TT>ping</TT>.
<P>
<B>7.5</B> On a SPARCstation
ELC a ping of the loopback address yields an RTT of 1.310 ms,
while a ping of the host's Ethernet address yields an RTT of 1.460
ms. This difference is the additional processing done by the Ethernet
driver, to determine that the datagram is really destined for
the local host. You need a version of ping that outputs microsecond
resolution to measure this.
<H3>Chapter 8</H3>
<P>
<B>8.1</B> If an incoming datagram
has a TTL of 0, doing the decrement and then test would set the
TTL to 255 and let the datagram continue. Although a router should
never receive a datagram with a TTL of 0, it has occurred.
<P>
<B>8.2</B> We noted that <TT>traceroute</TT>
stores 12 bytes of data in the data portion of the UDP datagram,
part of which is the time the datagram was sent. From <a href="icmp_int.htm#fig_6_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/icmp_int.htm#fig_6_9">Figure 6.9</a>,
however, we see that ICMP only returns the first 8 bytes of the
IP datagram that was in error, and we noted there that this is
the 8-byte UDP header. Therefore the time value stored by <TT>traceroute</TT>
is not returned in the ICMP error message. <TT>traceroute</TT>
saves the time when it sends a packet, and when an ICMP reply
is received, fetches the current time and subtracts the two value
to get the RTT.
<P>
Recall from <a href="pingprog.htm#7_0" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/pingprog.htm#7_0">Chapter 7</a> that <TT>ping</TT>
stored the time in the outgoing ICMP echo request and this data
was echoed by the server. This allowed <TT>ping</TT>
to print the correct RTT, even if the packets were returned out
of order.
<P>
<B>8.3</B> The first line of
output is correct and identifies R1.
The next probe starts with a TTL of 2, and this is decremented
by R1.
When R2 receives this it decrements the TTL from 1 to 0 but incorrectly
forwards it to R3. R3 sees that the incoming TTL is 0 and sends
back the time exceeded. This means the second line of output (for
the TTL of 2) identifies R3, not R2. The third line of output
correctly identifies R3. The clue that this bug is present is
two consecutive lines of output that identify the same router.
<P>
<B>8.4</B> In this case the TTL
of 1 identifies R1,
the TTL of 2 identifies R2, and the TTL of 3 identifies R3; but
when the TTL is 4 the UDP datagram gets to the destination with
an incoming TTL of 1. The ICMP port unreachable is generated,
but its TTL is 1 (incorrectly copied from the incoming TTL). This
ICMP message goes to R3 where the TTL is decremented and the message
discarded. An ICMP time exceeded is <I>not</I> generated, since
the datagram that was discarded was an ICMP error message (port
unreachable). A similar scenario occurs for the probe with a TTL
of 5, but this time the outgoing port unreachable starts with
a TTL of 2 (the incoming TTL) and makes it back to R2, where it's
discarded. The port unreachable corresponding to the probe with
a TTL of 6 makes it back to R1,
where it's discarded. Finally the port unreachable for the probe
with a TTL of 7 makes it all the way back, where it arrives with
an incoming TTL of 1. (<TT>traceroute</TT>
considers an arriving ICMP message with a TTL of 0 or 1 to be
suspicious, so it prints an exclamation point after the RTT.)
In summary, the lines for a TTL of 1, 2, and 3 correctly identify
R1,
R2, and R3, followed by three lines each containing three timeouts,
followed by the line for a TTL of 7 that identifies the destination.
<P>
<B>8.5</B> It appears that all
these routers initialize the outgoing TTL of an ICMP message to
255. This is common. The incoming value of 255 from <TT>netb</TT>
is what we expect, but the value of 253 from <TT>butch</TT>
means there is probably a missing router between it and <TT>netb</TT>.
Otherwise we would expect an incoming TTL of 254 at this point.
Similarly, from <TT>enss142.UT.westnet.net</TT>
we expect a value of 252, not 249. It appears these missing routers
are not handling the outbound UDP datagram correctly, but they
are decrementing the TTL on the returned ICMP message correctly.
<P>
We must be careful when looking at the incoming TTL,
since sometimes a value other than what we expect can be caused
by the return ICMP message taking a different path from the outbound
UDP datagram. In this example, however, it confirms what we suspect-there
are missing routers that <TT>traceroute</TT>
is not finding when the loose source routing option is used.
<P>
<B>8.7</B> The <TT>ping</TT>
client sets the identifier field in the ICMP echo request message
(<a href="pingprog.htm#fig_7_1" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/pingprog.htm#fig_7_1">Figure 7.1</a>) to its process ID. The ICMP echo reply contains
this identifier field. Each client looks at this returned identifier
field and handles only those that it sent.
<P>
The <TT>traceroute</TT> client
sets its UDP source port number to the logical-OR of its process
ID and 32768. Since the returned ICMP message always contains
the first 8 bytes of the IP datagram that generated the error
(<a href="icmp_int.htm#fig_6_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/icmp_int.htm#fig_6_9">Figure 6.9</a>), which includes the entire UDP header, this
source port number is returned in the ICMP error.
<P>
<B>8.8</B> The <TT>ping</TT>
client sets the optional data portion of the ICMP echo request
message to the time at which the packet is sent. This optional
data must be returned in the ICMP echo reply. This allows <TT>ping</TT>
to calculate the accurate round-trip time, even if packets are
returned out of order.
<P>
The <TT>traceroute</TT> client
can't operate this way because all that's returned in the ICMP
error is the UDP header (<a href="icmp_int.htm#fig_6_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/icmp_int.htm#fig_6_9">Figure 6.9</a>), none of the UDP data.
Therefore <TT>traceroute</TT> must remember
when it sends a request, wait for the reply, and calculate the
time difference.
<P>
This illustrates another difference between Ping
and Traceroute: Ping sends one packet a second, regardless of
whether it receives any replies, while Traceroute sends a request
and then waits for either a reply or a timeout before sending
the next request.
<P>
<B>8.9</B> Since Solaris 2.2
starts ephemeral UDP port numbers at 32768 by default, there is
a much greater chance that the destination port is in use on the
destination host.
<H3>Chapter 9</H3>
<P>
<B>9.1</B> When the ICMP standard
was first specified, RFC 792 [Postel 1981b], subnetting was not
in use. Also, using a single network redirect instead of <I>N</I>
host redirects (for all <I>N</I> hosts on the destination network)
saves some space in the routing table.
<P>
<B>9.2</B> The entry is not required,
but if it is removed, all IP datagrams to <TT>slip</TT>
are sent to the default router (<TT>sun</TT>),
which then forwards them to the router <TT>bsdi</TT>.
Since <TT>sun</TT> is forwarding a datagram
out the same interface on which it was received, it sends an ICMP
redirect to <TT>svr4</TT>. This creates the
same routing table entry on svr4 that we removed, although this
time it is created by a redirect instead of being added at bootstrap
time.
<P>
<B>9.3</B> When the 4.2BSD host
receives the datagram destined for 140.1.255.255 it finds that
it has a route to the network (140.1) so it tries to forward the
datagram. To do this it sends an ARP broadcast looking for 140.1.255.255.
No reply is received for this ARP request, so the datagram is
eventually discarded. If there are many of these 4.2BSD hosts
on the cable, every one sends out this ARP broadcast at about
the same time, swamping the network temporarily.
<P>
<B>9.4</B> This time a reply
is received for each ARP request, telling each 4.2BSD host to
send the datagram to the specified hardware address (the Ethernet
broadcast). If there are <I>k</I> of these 4.2BSD hosts on the
cable, all receive their own ARP reply, causing each one to generate
another broadcast. Each host receives each broadcast IP datagram
destined to 140.1.255.255, and since every host now has an ARP
cache entry, the datagram is forwarded again to the broadcast
address. This continues and generates an <I>Ethernet meltdown.</I>
[Manber 1990] describes other forms of chain reactions in networks.
<H3>Chapter 10</H3>
<P>
<B>10.1</B> Thirteen of the routes
came from <TT>kpno</TT>: all except 140.252.101.0
and 140.252.104.0, the other networks to which <TT>gateway</TT>
is directly connected.
<P>
<B>10.2</B> Sixty seconds will
pass before the 25 routes advertised in the lost datagram are
updated. This isn't a problem because RIP normally requires 3
minutes without an update before it declares a route dead.
<P>
<B>10.3</B> RIP runs on top of
UDP, and UDP provides an optional checksum for the data portion
of the UDP datagram (<a href="udp_user.htm#11_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/udp_user.htm#11_3">Section 11.3</a>). OSPF, however, runs on top
of IP. The IP checksum covers only the IP header, so OSPF must
add its own checksum field.
<P>
<B>10.4</B> Load balancing increases
the chances of packets being delivered out of order, and possibly
distorts the round-trip times calculated by the transport layer.
<P>
<B>10.5</B> This is called simple
split horizon.
<P>
<B>10.6</B> In <a href="broadcas.htm#fig_12_1" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/broadcas.htm#fig_12_1">Figure 12.1</a> we
show that each of the 100 hosts processes the broadcast UDP datagram
through the device driver, IP layer, and UDP layer, where it'll
finally be discarded when it's discovered that UDP port 520 is
not in use.
<H3>Chapter 11</H3>
<P>
<B>11.1</B> Since there are 8
additional bytes of header when IEEE 802 encapsulation is used,
1465 bytes of user data is the smallest size
that causes fragmentation.
<P>
<B>11.3</B> There are 8200 bytes
of data for IP to send, the 8192 bytes of user data and the 8-byte
UDP header. Using the tcpdump notation, the first fragment is
1480@0+ (1480 bytes of data, offset of 0, with the &quot;more
fragments&quot; bit set). The second is 1480@1480+, the third
is 1480@2960+, the fourth is 1480@4440+, the fifth is 1480@5920+,
and the sixth is 800@7400. 1480 x 5+ 800 = 8200, which is the
number of bytes to send.
<P>
<B>11.4</B> Each 1480-byte fragment
is divided into three pieces: two 528-byte fragments and one 424-byte
fragment. The largest multiple of 8 less than 532 (552 - 20) is
528. The 800-byte fragment is divided into two pieces: a 528-byte
fragment and a 272-byte fragment. Thus, the original 8192-byte
datagram becomes 17 frames across the SLIP link.
<P>
<B>11.5</B> No. The problem is
that when the application times out and retransmits, the IP datagram
generated by the retransmission has a new identification field.
Reassembly is done only for fragments with the same identification
field.
<P>
<B>11.6</B> The identification
field in the IP header (47942) is the same.
<P>
<B>11.7</B> First, from Figure
11.4 we see that <TT>gemini</TT> does not
have outgoing UDP checksums enabled. It's highly probable that
the operating system on this host (SunOS 4.1.1) is one that never
verifies an incoming UDP checksum unless outgoing UDP checksums
are enabled. Second, it could be that most of the UDP traffic
is local traffic, instead of WAN traffic, and therefore not subject
to all the vagaries of WANs.
<P>
<B>11.8</B> The loose and strict
source routing options are copied into each fragment. The timestamp
option and the record route option are not copied into each fragment-they
appear only in the first fragment.
<P>
<B>11.9</B> No. We saw in <a href="udp_user.htm#11_12" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/udp_user.htm#11_12">Section 11.12</a>
that many implementations can filter incoming datagrams
destined for a given UDP port number based on the destination
IP address, source IP address, and source port number.
<H3>Chapter 12</H3>
<P>
<B>12.1</B> Broadcasting by itself
does not add to network traffic, but it adds extra host processing.
Broadcasting can lead to additional network traffic if the receiving
hosts incorrectly respond with errors such as ICMP port unreachables.
Also, routers normally don't forward broadcast packets, whereas
bridges normally do, so broadcasts on a bridged network can travel
much farther than they would on a routed network.
<P>
<B>12.2</B> Every host receives
a copy of every broadcast. The interface layer receives the frame,
and passes it to the device driver. If the type field is for some
other protocol, it is the device driver that discards the frame.
<P>
<B>12.3</B> First execute <TT>netstat
-r</TT> to see the routing table. This shows the
names of all the interfaces. Then execute <TT>ifconfig</TT>
(<a href="ip_inter.htm#3_8" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/ip_inter.htm#3_8">Section 3.8</a>) for each interface: the flags tell if the interface
supports broadcasting, and if so the broadcast address is also
output.
<P>
<B>12.4</B> Berkeley-derived
implementations do not allow a broadcast datagram to be fragmented.
When we specified the length of 1472 bytes, the resulting IP datagram
was exactly 1500 bytes, the Ethernet MTU. Refusing to allow a
broadcast datagram to be fragmented is a policy decision-there
is no technical reason (other than a desire to reduce the number
of broadcast packets).
<P>
<B>12.5</B> Depending on the
multicasting support in the various Ethernet interface cards in
the 100 hosts, the multicast datagram can be ignored by the interface
card, or discarded by the device driver.
<H3>Chapter 13</H3>
<P>
<B>13.1</B> Use some host-unique
value when generating the random value. The IP address and link-layer
address are two values that should differ on every host. The time-of-day
is a bad choice, especially if all the hosts run a protocol such
as NTP to synchronize their clocks.
<P>
<B>13.2</B> They added an application
protocol header that included a sequence number
and a timestamp.
<H3>Chapter 14</H3>
<P>
<B>14.1</B> A resolver is always
a client, but a name server is both a client and server.
<P>
<B>14.2</B> The question is returned,
which accounts for the first 44 bytes. The single answer occupies
the remaining 31 bytes: a 2-byte pointer for the domain name (i.e.,
a pointer to the domain name in the question), 10 bytes for the
fixed-size fields (type, class, TTL, and resource length), and
19 bytes for the resource data (a domain name). Notice that the
domain name in the resource data (<TT>svr4.tuc.noao.edu.</TT>)
doesn't share a suffix with the domain name in the question (<TT>34.13.252.140.in-addr.arpa.</TT>)
so a pointer can't be used.
<P>
<B>14.3</B> Reversing the order
means using the DNS first, and if that fails, trying to convert
the argument as a dotted-decimal number. This means every time
a dotted-decimal number is specified, the DNS is used, involving
a name server. This is a waste of resources.
<P>
<B>14.4</B> Section 4.2.2 of
RFC 1035 specifies that a 2-byte length precedes the actual DNS
message.
<P>
<B>14.5</B> When a name server
starts it normally reads the (possibly out of date) list of root
servers from a disk file. It then tries to contact one of these
root servers, requesting the name server records (a query type
of NS) for the root domain. This returns the current up-to-date
list of root servers. Minimally this requires one of the root
server entries in the start-up disk file to be current.
<P>
<B>14.6</B> The registration
services of the InterNIC updates the root servers three times
a week.
<P>
<B>14.7</B> Since the resolver
comes and goes, as applications come and go, if the system is
configured to use multiple name servers and the resolver maintains
no state, the resolver cannot keep track of the round-trip times
to its various name servers. This can lead to timeouts for resolver
queries that are too short, causing unnecessary retransmissions.
<P>
<B>14.8</B> Sorting the A records
should be done by the resolver, not the name server, since the
resolver normally knows more than the server about the network
topology of the client. (Newer releases of BIND provide for resolver
sorting of A records.)
<H3>Chapter 15</H3>
<P>
<B>15.1</B> TFTP requests sent
to the broadcast address should be ignored. As stated in the Host
Requirements RFC, responding to a broadcast request can create
a significant security hole. A problem, however, is that not all
implementations and APIs provide the destination address of a
UDP datagram to the process that receives the datagram (<a href="udp_user.htm#11_12" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/udp_user.htm#11_12">Section 11.12</a>).
For this reason many TFTP servers don't enforce this restriction.
<P>
<B>15.2</B> Unfortunately, the
RFC says nothing about this block number wrap. Implementations
should be able to transfer files up through 33,553,920 bytes (65535
x 512). Many
implementations fail when the size of the file exceeds 16,776,704
(32767 x 512) since they incorrectly maintain the block number
as a signed 16-bit integer instead of an unsigned integer.
<P>
<B>15.3</B> This simplifies coding
a TFTP client to fit in read-only memory, because the server is
the sender of the bootstrap files, so the server must implement
the timeout and retransmission.
<P>
<B>15.4</B> With its stop-and-wait
protocol, TFTP can transfer a maximum of 512 bytes per client-server
round trip. The maximum throughput of TFTP is then 512 bytes divided
by the round-trip time between the client and server. On an Ethernet,
assuming a round-trip time of 3 ms, the maximum throughput is
around 170,000 bytes/sec.
<H3>Chapter 16</H3>
<P>
<B>16.1</B> A router could forward
an RARP request to some other host on one of the router's other
attached networks, but sending a reply then becomes a problem.
The router would also have to forward RARP replies.
<P>
BOOTP doesn't have this reply problem since the address
to reply to is a normal IP address that the routers know how to
forward anyway. The problem is that RARP uses only link-layer
addresses, and routers don't normally know these values for hosts
on other, nonattached, networks.
<P>
<B>16.2</B> It could use its
own hardware address, which should be unique, and which is set
in the request and returned in the reply.
<H3>Chapter 17</H3>
<P>
<B>17.1</B> All are mandatory
except the UDP checksum. The IP checksum covers only the
IP header, while the others start immediately
after the IP header.
<P>
<B>17.2</B> The source IP address,
source port number, or protocol field might have been
corrupted.
<P>
<B>17.3</B> Many Internet applications
use a carriage return and linefeed to mark the end of each application
record. This is NVT ASCII coding (<a href="telnet.htm#26_4" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/telnet.htm#26_4">Section 26.4</a>). An alternative
technique is to prefix each record with a byte count, which is
used by the DNS (Exercise 14.4) and Sun RPC (<a href="nfs_netw.htm#29_2" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/nfs_netw.htm#29_2">Section 29.2</a>).
<P>
<B>17.4</B> As we saw in <a href="javascript:if(confirm('http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/imp_int.htm  \n\nThis file was not retrieved by Teleport Pro, because the server reports that this file cannot be found.  \n\nDo you want to open it from the server?'))window.location='http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/imp_int.htm#6_5'" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/imp_int.htm#6_5">Section 6.5</a>,
an ICMP error must return at least the first 8 bytes beyond
the IP header of the IP datagram that caused the error. When TCP
receives an ICMP error it needs to examine the two port numbers
to determine which connection the error corresponds to, so the
port numbers must be in the first 8 bytes of the TCP header.
<P>
<B>17.5</B> There are options
at the end of the TCP header, but there are no options in the
UDP header.
<H3>Chapter 18</H3>
<P>
<B>18.1</B> The ISN is a 32-bit
counter that wraps around from 4,294,912,000 to 8,704 approximately
9.5 hours after the system was bootstrapped. After approximately
another 9.5 hours it will wrap around to 17,408, then 26,112 after
another 9.5 hours, and so on. Since the ISN starts at 1 when the
system is bootstrapped, and since the lowest order digit cycles
through 4, 8, 2, 6, and 0, the ISN should always be an odd number.
<P>
<B>18.2</B> In the first case
we used our sock program, and by default it transmits the Unix
newline character as itself-the single ASCII character 012 (octal).
In the second case we used the Telnet client and it converts the
Unix newline into two ASCII characters-a carriage return (octal
015) followed by a linefeed (octal 012).
<P>
<B>18.3</B> On a half-closed
connection one end has sent a FIN and is waiting for either data
or a FIN from the other end. A half-open connection is when one
end crashes, unbeknown to the other end.
<P>
<B>18.4</B> The 2MSL wait state
is only entered for a connection that has gone through the
ESTABLISHED state.
<P>
<B>18.5</B> First, the daytime
server does the active close of the TCP connection after writing
the time and date to the client. This is indicated by the message
printed by our sock program: &quot;connection closed by peer.&quot;
The client's end of the connection goes through the passive close
states. This puts the socket pair in the TIME_WAIT state on the
server, not the client.
<P>
Next, as shown in <a href="tcp_conn.htm#18_6" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_conn.htm#18_6">Section 18.6</a>, most Berkeley-derived
implementations allow a new connection request to arrive for a
socket pair currently in the TIME_WAIT state, which is exactly
what's happening here.
<P>
<B>18.6</B> A reset is sent in
response to the FIN, because the FIN arrived for a connection
that was CLOSED.
<P>
<B>18.7</B> The party that dials
the number does the active open. The party whose telephone rings
does the passive open. Simultaneous opens are not permitted, but
a simultaneous close is OK.
<P>
<B>18.8</B> We would only see
ARP requests, not TCP SYN segments, but the ARP requests
would have the same timing as in the figure.
<P>
<B>18.9</B> The client is on
the host <TT>solaris</TT> and the server is
on the host <TT>bsdi</TT>. The client's ACK
of the server's SYN is combined with the first data segment from
the client (line 3). This is perfectly legal under the rules of
TCP, although most implementations don't do this. Next, the client
sends its FIN (line 4) before waiting for the ACK of its data.
This allows the server to acknowledge both the data and the FIN
in line 5.
<P>
This exchange (sending one segment of data from the
client to the server) requires seven segments. The normal connection
establishment and termination (<a href="tcp_conn.htm#fig_18_13" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_conn.htm#fig_18_13">Figure 18.13</a>), along with a single
data segment and its acknowledgment, requires nine segments.
<P>
<B>18.10</B> First, the server's
ACK of the client's FIN is normally not delayed (we discuss delayed
ACKs in <a href="tcp_int.htm#19_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_int.htm#19_3">Section 19.3</a>) but sent as soon as the FIN arrives. It
takes the application a while to receive the EOF and tell its
TCP to close its end of the connection. Second, the server that
receives the FIN does not have to close its end of the connection
on receiving the FIN from the client. As we saw in <a href="tcp_conn.htm#18_5" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_conn.htm#18_5">Section 18.5</a>,
data can still be sent.
<P>
<B>18.11</B> If an arriving segment
that generates an RST has an ACK field, the sequence number of
the RST is the arriving ACK field. The ACK value of 1 in line
6 is relative to the ISN of 26368001 in line 2.
<P>
<B>18.12</B> See [Crowcroft et
al. 1992] for comments on layering.
<P>
<B>18.13</B> Five queries are
issued. Assume there are three packets to establish the connection,
one for the query, one to ACK the query, one for the response,
one to ACK the response, and four to terminate the connection.
This means II packets per query, for a total of 55 packets. Using
UDP reduces this to 10 packets.
<P>
This can be reduced to 10 packets per query if the
ACK of the query is combined with the response (<a href="tcp_int.htm#19_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_int.htm#19_3">Section 19.3</a>).
<P>
<B>18.14</B> The limit is about
268 connections per second: the maximum number of TCP port numbers
(65536 -1024 = 64512, ignoring the well-known ports) divided by
the TIME_WAIT state of 2MSL.
<P>
<B>18.15</B> The duplicate FIN
is acknowledged and the 2MSL timer is restarted.
<P>
<B>18.16</B> The receipt of an
RST while in the TIME_WAIT state causes the state to be prematurely
terminated. This is called <I>TIME_WAIT assassination.</I> RFC
1337 [Braden 1992a] discusses this in detail and shows the potential
problems. The simple fix proposed by this RFC is to ignore RST
segments while in the TIME_WAIT state.
<P>
<B>18.17</B> It's when the implementation
does not support a half-close. Once the application causes a FIN
to be sent, the application can no longer read from the connection.
<P>
<B>18.18</B> No. Incoming data
segments are demultiplexed using the source IP address, source
port number, destination IP address, and destination port number.
For incoming connection requests we saw in <a href="tcp_conn.htm#18_11" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_conn.htm#18_11">Section 18.11</a> that
a TCP server can normally prevent connections from being accepted
based on the destination IP address.
<H3>Chapter 19</H3>
<P>
<B>19.1</B> Two application writes,
followed by a read, cause a delay because the Nagle algorithm
will probably be invoked. The first segment (with 8 bytes of data)
is sent and its ACK is waited for before sending the 12 bytes
of data. If the server implements delayed ACKs, there can be a
delay of up to 200 ms (plus the RTT) before this ACK is received.
<P>
<B>19.2</B> Assuming 5-byte CSLIP
headers (IP and TCP) and 2 bytes of data, the RTT across the SLIP
link for these segments is about 14.5 ms. We have to add to this
the RTT across the Ethernet (normally 5-10 ms), plus the routing
time on sun and bsdi. So yes, the observed times do appear correct.
<P>
<B>19.3</B> In <a href="tcp_int.htm#fig_19_6" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_int.htm#fig_19_6">Figure 19.6</a> the
time difference between segments 6 and 9 is 533 ms. In Figure
19.8 the time difference between segments 8 and 12 is 272 ms.
(We measured the time for the F2 key, not the Fl key, since the
first echo of the Fl key was lost in the second figure.)
<H3>Chapter 20</H3>
<P>
<B>20.1</B> Byte number 0 is
the SYN and byte number 8193 is the FIN. The SYN and FIN each
occupy 1 byte in the sequence number space.
<P>
<B>20.2</B> The first application
write causes the first segment to be sent with the PUSH flag.
Since BSD/386 always uses slow start, it waits for the first ACK
before sending any more data. During this time the next three
application writes occur, and the sending TCP buffers the data
to send. The next three segments do not contain the PUSH flag
since there is more data in the buffer to send. Eventually slow
start catches up with the application writes and every application
write causes a segment to be sent, and since that segment is the
last one in the buffer, the PUSH flag is set.
<P>
<B>20.3</B> Solving the bandwidth-delay
equation for the capacity, it is 1,920 bytes for the first case,
and 2,062 for the satellite case. It appears that the receiving
TCP is only advertising a window of 2,048 bytes.
<P>
A window greater than 16,000 bytes should be able
to saturate the satellite link.
<P>
<B>20.4</B> No, because TCP can
repacketize data after a timeout, as we'll see in Section <a href="tcp_time.htm#21_11" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_time.htm#21_11">21.11</a>.
<P>
<B>20.5</B> Segment 15 is a window
update sent automatically by the TCP module as a result of the
application reading data, which causes the window to open. This
is similar to segment 9 in that figure. Segment 16, however, is
a result of the application closing its end of the connection.
<P>
<B>20.6</B> This can cause the
sender to inject packets into the network at a rate faster than
the network can really handle. This is called <I>ACK compression</I>
or <I>ACK smashing </I>[Mogul 1993, Sec. 15.8.13]. This reference
indicates that ACK compression occurs on the Internet, although
it rarely leads to congestion.
<H3>Chapter 21</H3>
<P>
<B>21.1</B> The next timeout
is for 48 seconds: 0+4x12. The factor of 4 is the next multiplier
in the exponential backoff.
<P>
<B>21.2</B> It appears SVR4 still
uses the factor <I>ID</I> instead of 4D in the calculation of
<I>RTO.</I>
<P>
<B>21.3</B> The stop-and-wait
protocol used by TFTP is limited to 512 bytes of data per round
trip. 32768/512 x 1.5 is 96 seconds.
<P>
<B>21.4</B> Show four segments,
numbered 1,2,3, and 4. Assume the order of receipt is 1, 3, 2,
and 4. The ACKs generated by the receiver will be ACK 1 (a normal
ACK), ACK 1 (a duplicate ACK when segment 3 is received out of
order), ACK 3 when segment 2 is received (acknowledging both segments
2 and 3), and then ACK 4. Here one duplicate ACK is generated.
If the order of receipt were 1, 3, 4, 2, two duplicate ACKs would
be generated.
<P>
<B>21.5</B> No, because the slope
is still up and to the right, not downward.
<P>
<B>21.6</B> See <a href="append_e.htm#fig_E_1" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/append_e.htm#fig_E_1">Figure E.1</a>.
<P>
<B>21.7</B> In <a href="tcp_time.htm#fig_21_2" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_time.htm#fig_21_2">Figure 21.2</a> the
segments contain 256 bytes of data, which takes approximately
250 ms to transfer across the 9600 bits/sec CSLIP link between
slip and bsdi. Assuming the data segments are not queued somewhere
between bsdi and vangogh, they arrive at vangogh about 250 ms
apart. Since this exceeds the 200-ms delayed ACK timer, each segment
is acknowledged when the next delayed ACK timer expires.
<H3>Chapter 22</H3>
<P>
<B>22.1</B> The ACKs are probably
all delayed on the host bsdi, because there is no reason to send
them immediately. That's why the relative times have 0.170 and
0.370 as the fractional part. It also appears that the 200-ms
timer on bsdi is running about 18 ms behind the same timer on
sun.
<P>
<B>22.2</B> The FIN flag, just
like the SYN flag, occupies 1 byte in the sequence number space.
&quot;The advertised window appears to be 1 byte smaller because
TCP allows room for the 1 byte of sequence number space occupied
by the FIN flag.
<H3>Chapter 23</H3>
<P>
<B>23.1</B> It is usually simpler
to invoke the keepalive option than explicitly coding application
probes; the keepalive probes take less network bandwidth than
application probes (since keepalive probes and answers contain
no data); no probes are sent unless the connection is idle.
<P>
<B>23.2</B> The keepalive option
can cause a perfectly good connection to be dropped because of
a temporary network outage; the probe interval (2 hours) is normally
not configurable on an application basis;
<H3>Chapter 24</H3>
<P>
<B>24.1</B> It means the sending
TCP supports the window scale option, but doesn't need to scale
its window for this connection. The other end (that receives this
SYN) can then specify a window scale factor (that can be 0 or
nonzero).
<P>
<B>24.2</B> 64000: the receive
buffer size (128000) right shifted 1 bit. 55000: the receive buffer
size (220000) right shifted 2 bits.
<P>
<B>24.3</B> No. The problem is
that acknowledgments are not reliably delivered (unless they're
piggybacked with data) so a scale change appearing on an ACK could
get lost.
<P>
<B>24.4</B> 2<SUP>32</SUP>x8/120
equals 286 Mbits/sec, 2.86 times the FDDI data rate.
<P>
<B>24.5</B> Each TCP would have
to remember the last timestamp received on any connection from
each host. Read Appendix B.2 of RFC 1323 for additional details.
<P>
<B>24.6</B> The application must
set the size of the receive buffer <I>before</I> establishing
the connection with the other end, since the window scale option
is sent in the initial SYN segment.
<P>
<B>24.7</B> If the receiver ACKs
every second data segment, the <I>throughput</I> is 1,118,881
bytes/sec. Using a window of 62 segments, with an ACK for every
31 segments, the value is 1,158,675.
<P>
<B>24.8</B> With this option
the timestamp echoed in the ACK is always from the segment that
caused the ACK. There is no ambiguity about which retransmitted
segment the ACK is for, but the other part of Karn's algorithm,
dealing with the exponential backoff on retransmission, is still
required.
<P>
<B>24.9</B> The receiving TCP
queues the data, but it cannot be passed to the application until
the three-way handshake is complete: when the receiving TCP moves
into the ESTABLISHED state.
<P>
<B>24.10</B> Five segments are
exchanged:
<OL>
<LI>Client to server: SYN, data (request), and FIN.
The server must queue the data as described in the previous exercise.
<LI>Server to client: SYN and ACK of client's SYN.
<LI>Client to server: ACK of server's SYN and client
FIN (again). This causes the server to move to the ESTABLISHED
state, and the queued data from segment 1 is passed to the server
application.
<LI>Server to client: ACK of client FIN (which also
acknowledges client data), data (server's reply), and server's
FIN. This assumes that the SPT is short enough to allow this delayed
ACK. When the client TCP receives this segment, the reply is passed
to the client application, but the total time has been twice the
RTT plus the SPT.
<LI>Client to server: ACK of server's FIN.
</OL>
<P>
<B>24.11</B> 16,128 transactions
per second (64,512 divided by 4).
<P>
<B>24.12</B> The transaction
time using T/TCP cannot be faster than the time required to exchange
a UDP datagram between the two hosts. T/TCP should always take
longer, since it still involves state processing that UDP doesn't
do.
<H3>Chapter 25</H3>
<P>
<B>25.1</B> If a system is running
both a manager and agent, they are probably different processes.
The manager listens on UDP port 162 for traps, and the agent listens
on UDP port 161 for requests. If the same port were used for both
traps and requests, separating the manager from the agent would
be hard.
<P>
<B>25.2</B> Refer to the section
&quot;Table Access&quot; in <a href="snmp_sim.htm#25_7" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/snmp_sim.htm#25_7">Section 25.7</a>.
<H3>Chapter 26</H3>
<P>
<B>26.1</B> We expect segments
2, 4, and 9 from the server to be delayed. The time difference
between segments 2 and 4 is 190.7 ms and the time difference between
segments 2 and 9 is 400.7 ms.
<P>
All the ACKs from the client to the server appear
to be delayed: segments 6, II, 13, 15, 17, and 19. The time differences
of the last five from segment 6 are 400.0, 600.0, 800.0, 1000.0,
and 2.600 ms.
<P>
<B>26.2</B> If one end of a connection
is in TCP's urgent mode, then every time a segment is received,
one is sent. This segment does not tell the receiver anything
new (it is not acknowledging new data, for example), and it contains
no data, it just reiterates that urgent mode has been entered.
<P>
<B>26.3</B> There are only 512
of these reserved ports (512-1023), limiting a host to 512 Rlogin
clients. The limit is normally less than 512 in real life, since
some of the port numbers in this range are used as well-known
ports by various servers, such as the Rlogin server.
<P>
TCP's limitation is that the socket pair defining
a connection (the 4-tuple) must be unique. Since the Rlogin server
always uses the same well-known port (513) multiple Rlogin clients
on a given host can use the same reserved port only if they're
connected to different server hosts. Rlogin clients, however,
don't use this technique of trying to reuse reserved ports. If
this technique were used, the theoretical limit is a maximum of
512 Rlogin clients at any one time that are all connected to the
same server host.
<H3>Chapter 27</H3>
<P>
<B>27.1</B> Theoretically the
connection cannot be established while the socket pair is in the
2MSL wait on either end. Realistically, however, we saw in <a href="tcp_conn.htm#18_6" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/tcp_conn.htm#18_6">Section 18.6</a>
that most Berkeley-derived implementations do accept a new
SYN for a connection in the TIME_WAIT state.
<P>
<B>27.2</B> These lines are not
part of a server reply that begins with a 3-digit reply code,
so they cannot be from the server.
<H3>Chapter 28</H3>
<P>
<B>28.1</B> A <I>domain literal
is</I> a dotted-decimal IP address within square brackets. For
example: <TT>mail rstevens@[140.252.1.54]</TT>.
<P>
<B>28.2</B> Six round trips:
the HELO command, MAIL, RCPT, DATA, body of the message, and QUIT.
<P>
<B>28.3</B> This is legal and
is called <I>pipelining</I> [Rose 1993, Sec. 4.4.4]. Unfortunately
there exist brain-damaged SMTP receiver implementations that clear
their input buffer after each command is processed, causing this
technique to fail. If this technique is used, naturally the client
cannot discard the message until all the replies have been checked
to verify that the message was accepted by the server.
<P>
<B>28.4</B> Consider the first
five network round trips from Exercise 28.2. Each is a small command
(probably a single segment) that places little load on the network.
If all five make it through to the server without retransmission,
the congestion window could be six segments when the body is sent.
If the body is large, the client could send the first six segments
at once, which the network might not be able to handle.
<P>
<B>28.5</B> Newer releases of
BIND shuffle the MX records with the same value, as a form of
load balancing.
<H3>Chapter 29</H3>
<P>
<B>29.1</B> No, because tcpdump
cannot distinguish an RPC request or reply from any other UDP
datagram. The only time it interprets the contents of UDP datagrams
as NFS packets is when the source or destination port number is
2049. Random RPC requests and replies can use an ephemeral port
number on each end.
<P>
<B>29.2</B> From <a href="introduc.htm#1_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/introduc.htm#1_9">Section 1.9</a>
recall that a process must have superuser privileges to assign
itself a port number less than 1024 (a well-known port). While
this is OK for system-provided servers, such as the Telnet server,
the FTP server, and the Port Mapper, we wouldn't want this restriction
for all RPC servers.
<P>
<B>29.3</B> Two concepts in this
example are that the client ignores any server reply that doesn't
have the XID that the client is waiting for, and UDP queues received
datagrams (up to some limit) until the application reads the datagram.
Also, the XID does not change on a timeout and retransmission,
it changes only when another server procedure is called.
<P>
The events performed by the client stub are as follows:
time 0: send request 1; time 4: time out and retransmit request
1; time 5: receive server's reply 1, return reply to application;
time 5: send request 2; time 9: time out and retransmit request
2; time 10: receive server's reply 1, but ignore it since we're
waiting for reply 2; time II: receive server's reply 2, return
reply to application.
<P>
The events at the server are as follows: time 0:
receive request 1, start operation; time 5: send reply 1; time
5: receive request 1 (from client's retransmission at time 4),
start operation; time 10: send reply 1; time 10: receive request
2 (from client's transmission at tune 5), start operation; time
II: send reply 2; time II: receive request 2 (from client's retransmission
at time 9), start operation; time 12: send reply 2. This final
server reply is just queued by the client's UDP for the next receive
done by the client. When the client reads it, the XID will be
wrong, and the client will ignore it.
<P>
<B>29.4</B> Changing the server's
Ethernet card changes its physical address. Even though we noted
in <a href="arp_addr.htm#4_7" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/arp_addr.htm#4_7">Section 4.7</a> that SVR4 does not send a gratuitous ARP on bootstrap,
it still must send an ARP request for the physical address of
sun before it can reply to its NFS requests. Since sun already
has an ARP entry for svr4, it updates this entry with the sender's
(new) hardware address from the ARP request.
<P>
<B>29.5</B> The second of the
client's block I/O daemons (reading at offset 73728) is out of
sync with the first by about 0.74 seconds. That is, this second
daemon times out 0.74 seconds after the first in lines 131-145.
It appears the server never saw the request in line 167, but did
see the request in line 168. The second block I/O daemon won't
retransmit until 0.74 seconds after line 168, and in the mean
time the first block I/O daemon continues issuing requests.
<P>
<B>29.6</B> If TCP is used, and
the TCP segment containing the server's reply is lost in the network,
the server's TCP will time out and retransmit the reply when it
doesn't receive an ACK from the client's TCP. Eventually the segment
will arrive at the client's TCP The difference here is that the
two TCP modules do the timeout and retransmission, not the NFS
client and server. (When UDP is used, the NFS client code performs
the timeout and retransmission.) Therefore the NFS client never
knows that the reply was lost and had to be retransmitted.
<P>
<B>29.7</B> It is possible for
the NFS server to obtain a different port number after the reboot.
This would complicate the client, because it would have to know
that the server crashed and contact the server's port mapper after
the reboot to find the NFS server's new port number.
<P>
This scenario, where the server crashes and reboots
and a server RPC application obtains a new ephemeral port, can
happen to any RPC application that doesn't use a well-known port.
<P>
<B>29.8</B> No. The NFS client
can reuse the same local, reserved port number for different servers.
TCP requires the 4-tuple of local IP address, local port, foreign
IP address, and foreign port to be unique, and the foreign IP
address is different for each server host.
<H3>Chapter 30</H3>
<P>
<B>30.1</B> Type <TT>whois
&quot;net 88&quot;</TT>. Class A network IDs 64 through
95 are reserved.
<P>
<B>30.2</B> Type <TT>whois
whitehouse-dom</TT>. Either the <TT>host</TT>
command or <TT>nslookup</TT> can query the
DNS.
<P>
<B>30.3</B> No, <TT>xscope</TT>
can run on a different host from the server. If the hosts are
different, then <TT>xscope</TT> can also use
TCP port 6000 for its incoming connection.
</BODY>
</HTML>
