<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Chapter 14. DNS: The Domain Name System</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<BODY>
<a name="14_0"><H1><I>DNS: The Domain Name System</I></H1></a>
<a name="14_1"><H3>14.1 Introduction</H3></a>
<P>
The <I>Domain Name System,</I> or DNS, is a distributed
database that is used by TCP/IP applications to map between hostnames
and IP addresses, and to provide electronic mail routing information.
We use the term <I>distributed</I> because no single site on the
Internet knows all the information. Each site (university department,
campus, company, or department within a company, for example)
maintains its own database of information and runs a server program
that other systems across the Internet (clients) can query. The
DNS provides the protocol that allows clients and servers to communicate
with each other.
<P>
From an application's point of view, access to the
DNS is through a <I>resolver</I>. On Unix hosts the resolver is
accessed primarily through two library functions, <TT>gethostbyname</TT>(3)
and <TT>gethostbyaddr</TT>(3), which are linked
with the application when the application is built. The first
takes a hostname and returns an IP address, and the second takes
an IP address and looks up a hostname. The resolver contacts one
or more <I>name servers</I> to do the mapping.
<P>
In <a href="arp_addr.htm#fig_4_2" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/arp_addr.htm#fig_4_2">Figure 4.2</a> we showed that the resolver is normally
part of the application. It is not part of the operating system
kernel as are the TCP/IP protocols. Another fundamental point
from this figure is that an application must convert a hostname
to an IP address before it can ask TCP to open a connection or
send a datagram using UDP. The TCP/IP protocols within the kernel
know nothing about the DNS.
<P>
In this chapter we'll take a look at how resolvers
communicate with name servers using the TCP/IP protocols (mainly
UDP). We do not cover all the administrative details of running
a name server or all the options available with resolvers and
servers. These details can fill an entire book. (See [Albitz and
Liu 1992] for all the details on the care and feeding of the standard
Unix resolver and name server.)
<P>
RFC 1034 [Mockapetris 1987a] specifies the concepts
and facilities provided by the DNS, and RFC 1035 [Mockapetris
1987b] details the implementation and specification. The most
commonly used implementation of the DNS, both resolver and name
server, is called BIND-the Berkeley Internet Name Domain server.
The server is called named. An analysis of the wide-area network
traffic generated by the DNS is given in [Danzig, Obraczka, and
Kumar 1992].
<a name="14_2"><H3>14.2 DNS Basics</H3></a>
<P>
The DNS name space is hierarchical, similar to the
Unix filesystem. Figure 14.1 shows this hierarchical organization.
<P>
<CENTER><a name="fig_14_1"><img src="f_14_1.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_1.gif"></a><br>
<B>Figure 14.1</B> Hierarchical
organization of the DNS.</CENTER>
<P>
Every node (circles in Figure 14.1) has a <I>label</I>
of up to 63 characters. The root of the tree is a special node
with a null label. Any comparison of labels considers uppercase
and lowercase characters the same. The <I>domain name</I> of any
node in the tree is the list of labels, starting at that node,
working up to the root, using a period (&quot;dot&quot;) to separate
the labels. (Note that this is different from the Unix filesystem,
which forms a pathname by starting at the top and going down the
tree.) Every node in the tree must have a unique domain name,
but the same label can be used at different points in the tree.
<P>
A domain name that ends with a period is called an
<I>absolute domain name or a fully qualified domain name</I> (FQDN).
An example is <TT>sun.tuc.noao.edu.</TT>.
If the domain name does not end with a period, it is assumed that
the name needs to be completed. How the name is completed depends
on the DNS software being used. If the uncompleted name consists
of two or more labels, it might be considered to be complete;
otherwise a local addition might be added to the right of the
name. For example, the name sun might be completed by adding the
local suffix <TT>.tuc.noao.edu.</TT>. The
top-level domains are divided into three areas:
<OL>
<LI><TT>arpa</TT> is a special domain used for address-to-name
mappings. (We describe this in <a href="#14_5">Section 14.5</a>.)
<LI>The seven 3-character domains are called the
<I>generic</I> domains. Some texts call these the <I>organizational</I>
domains.
<LI>All the 2-character domains are based on the
country codes found in ISO 3166. These are called the <I>country</I>
domains, or the <I>geographical</I> domains.
</OL>
<P>
Figure 14.2 lists the normal classification of the
seven generic domains.
<CENTER>
<a name="fig_14_2"><TABLE></a>
<TR><TD WIDTH=64><CENTER>Domain</CENTER></TD>
<TD WIDTH=350><CENTER>Description</CENTER>
</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>com</tt></CENTER></TD><TD WIDTH=350>commercial organizations</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>edu</tt></CENTER></TD><TD WIDTH=350>educational institutions</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>gov</tt></CENTER></TD><TD WIDTH=350>other U.S. governmental organizations</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>int</tt></CENTER></TD><TD WIDTH=350>international organizations</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>mil</tt></CENTER></TD><TD WIDTH=350>U.S. military</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>net</tt></CENTER></TD><TD WIDTH=350>networks</TD></TR>
<TR><TD WIDTH=64>
<CENTER><tt>org</tt></CENTER></TD><TD WIDTH=350>other organizations</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.2</B> The
3-character generic domains.</CENTER>
<P>
DNS folklore says that the 3-character generic domains
are only for U.S. organizations, and the 2-character country domains
for everyone else, but this is false. There are many non-U.S.
organizations in the generic domains, and many U.S. organizations
in the <TT>.us</TT> country domain. (RFC 1480
[Cooper and Postel 1993] describes the <TT>.us</TT>
domain in more detail.) The only generic domains that are restricted
to the United States are <TT>.gov</TT> and
<TT>.mil</TT>.
<P>
Many countries form second-level domains beneath
their 2-character country code similar to the generic domains:
<TT>.ac.uk</TT>, for example, is for academic
institutions in the United Kingdom and <TT>.co.uk</TT>
is for commercial organizations in the United Kingdom.
<P>
One important feature of the DNS that isn't shown
in figures such as <a href="#fig_14_1">Figure 14.1</a> is the delegation of responsibility
within the DNS. No single entity manages every label in the tree.
Instead, one entity (the NIC) maintains a portion of the tree
(the top-level domains) and delegates responsibility to others
for specific zones.
<P>
A <I>zone</I> is a subtree of the DNS tree that is
administered separately. A common zone is a second-level domain,
<TT>noao.edu</TT>, for example. Many second-level
domains then divide their zone into smaller zones. For example,
a university might divide itself into zones based on departments,
and a company might divide itself into zones based on branch offices
or internal divisions.
<P>
If you are familiar with the Unix filesystem, notice
that the division of the DNS tree into zones is similar to the
division of a logical Unix filesystem into physical disk partitions.
Just as we can't tell from <a href="#fig_14_1">Figure 14.1</a> where the zones of authority
lie, we can't tell from a similar picture of a Unix filesystem
which directories are on which disk partitions.
<P>
Once the authority for a zone is delegated, it is
up to the person responsible for the zone to provide multiple
<I>name servers</I> for that zone. Whenever a new system is installed
in a zone, the DNS administrator for the zone allocates a name
and an IP address for the new system and enters these into the
name server's database. This is where the need for delegation
becomes obvious. At a small university, for example, one person
could do this each time a new system was added, but in a large
university the responsibility would have to be delegated (probably
by departments), since one person couldn't keep up with the work.
<P>
A name server is said to have authority for one zone
or multiple zones. The person responsible for a zone must provide
a <I>primary name server</I> for that zone and one or more <I>secondary
name servers.</I> The primary and secondaries must be independent
and redundant servers so that availability of name service for
the zone isn't affected by a single point of failure.
<P>
The main difference between a primary and secondary
is that the primary loads all the information for the zone from
disk files, while the secondaries obtain all the information from
the primary. When a secondary obtains the information from its
primary we call this a <I>zone transfer.</I>
<P>
When a new host is added to a zone, the administrator
adds the appropriate information (name and IP address minimally)
to a disk file on the system running the primary. The primary
name server is then notified to reread its configuration files.
The secondaries query the primary on a regular basis (normally
every 3 hours) and if the primary contains newer data, the secondary
obtains the new data using a zone transfer.
<P>
What does a name server do when it doesn't contain
the information requested? It must contact another name server.
(This is the <I>distributed</I> nature of the DNS.) Not every
name server, however, knows how to contact every other name server.
Instead every name server must know how to contact the <I>root
name servers.</I> As of April 1993 there were eight root servers
and all the primary servers must know the IP address of each root
server. (These IP addresses are contained in the primary's configuration
files. The primary servers must know the IP addresses of the root
servers, not their DNS names.) The root servers then know the
name and location (i.e., the IP address) of each authoritative
name server for all the second-level domains. This implies an
iterative process: the requesting name server must contact a root
server. The root server tells the requesting server to contact
another server, and so on. We'll look into this procedure with
some examples later in this chapter.
<P>
You can fetch the current list of root servers using
anonymous FTP. Obtain the file <TT>netinfo/root-servers.txt</TT>
from either <TT>ftp.rs.internic.net</TT> or
<TT>nic.ddn.mil</TT>.
<P>
A fundamental property of the DNS is <I>caching.</I>
That is, when a name server receives information about a mapping
(say, the IP address of a hostname) it caches that information
so that a later query for the same mapping can use the cached
result and not result in additional queries to other servers.
<a href="#14_7">Section 14.7</a> shows an example of caching.
<a name="14_3"><H3>14.3 DNS Message Format</H3></a>
<P>
There is one DNS message defined for both queries
and responses. <a href="#fig_14_3">Figure 14.3</a> shows the overall format of the message.
<BR>

<P>
<CENTER><a name="fig_14_3"><img src="f_14_3.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_3.gif"></a><br>
<B>Figure 14.3</B> General
format of DNS queries and responses.</CENTER>
<P>
The message has a fixed 12-byte header followed by
four variable-length fields.
<P>
The <I>identification</I> is set by the client and
returned by the server. It lets the client match responses to
requests.
<P>
The <I>16-bit flags</I> field is divided into numerous
pieces, as shown in Figure 14.4.

<P>
<CENTER><a name="fig_14_4"><img src="f_14_4.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_4.gif"></a><br>
<B>Figure 14.4</B> <I>flags</I>
field in the DNS header.</CENTER>
<P>
We'll start at the leftmost bit and describe each
field.
<UL>
<LI><I>QR</I> is a 1-bit field:
0 means the message is a query, 1 means it's a response.
<LI><I>opcode is</I> a 4-bit
field. The normal value is 0 (a standard query). Other values
are 1 (an inverse query) and 2 (server status request).
<LI><I>AA</I> is a 1-bit flag
that means &quot;authoritative answer.&quot; The name server is
authoritative for the domain in the question section.
<LI>TC is a 1-bit field that means &quot;truncated.&quot;
With UDP this means the total size of the reply exceeded 512 bytes,
and only the first 512 bytes of the reply was returned.
<LI><I>RD</I> is a 1-bit field
that means &quot;recursion desired.&quot; This bit can be set
in a query and is then returned in the response. This flag tells
the name server to handle the query itself, called a <I>recursive
query.</I> If the bit is not set, and the requested name server
doesn't have an authoritative answer, the requested name server
returns a list of other name servers to contact for the answer.
This is called an <I>iterative query.</I> We'll see examples of
both types of queries in later examples.
<LI><I>RA</I> is a 1-bit field
that means &quot;recursion available.&quot; This bit is set to
1 in the response if the server supports recursion. We'll see
in our examples that most name servers provide recursion, except
for some root servers.
<LI>There is a 3-bit field that must be 0.
<LI><I>rcode</I> is a 4-bit field
with the return code. The common values are 0 (no error) and 3
(name error). A name error is returned only from an authoritative
name server and means the domain name specified in the query does
not exist.
</UL>
<P>
The next four 16-bit fields specify the number of
entries in the four variable-length fields that complete the record.
For a query, the <I>number of questions</I> is normally 1 and
the other three counts are 0. Similarly, for a reply the <I>number
of answers is</I> at least 1, and the remaining two counts can
be 0 or nonzero.
<H4>Question Portion of DNS Query Message</H4>
<P>
The format of each question in the <I>question</I>
section is shown in Figure 14.5. There is normally just one question.
<P>
The <I>query name</I> is the name being looked up.
It is a sequence of one or more labels. Each <I>label</I> begins
with a 1-byte count that specifies the number of bytes that follow.
The name is terminated with a byte of 0, which is a label with
a length of 0, which is the label of the root. Each count byte
must be in the range of 0 to 63, since labels are limited.
<P>
<CENTER><a name="fig_14_5"><img src="f_14_5.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_5.gif"></a><br>
<B>Figure 14.5</B> Format
of <I>question</I> portion of DNS query message.</CENTER>
<P>
to 63 bytes. (We'll see later in this section that
a count byte with the two high-order bits turned on, values 192
to 255, is used with a compression scheme.) Unlike many other
message formats that we've encountered, this field is allowed
to end on a boundary other than a 32-bit boundary. No padding
is used. Figure 14.6 shows how the domain name <TT>gemini.tuc.noao.edu</TT>
is stored.
<P>
<CENTER><a name="fig_14_6"><img src="f_14_6.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_6.gif"></a><br>
<B>Figure 14.6</B> Representation
of the domain name <TT>gemini.tuc.noao.edu</TT>.</CENTER>
<P>
Each question has a <I>query type</I> and each response
(called a resource record, which we talk about below) has a <I>type.</I>
There are about 20 different values, some of which are now obsolete.
Figure 14.7 shows some of these values. The query type is a superset
of the type: two of the values we show can be used only in questions.
<P>
<CENTER>
<a name="fig_14_7"><TABLE BORDER=1></a>
<TR><TD WIDTH=100><CENTER>Name</CENTER></TD>
<TD WIDTH=66><CENTER>Numeric<BR>
value</CENTER>
</TD><TD WIDTH=230><CENTER>Description</CENTER>
</TD><TD WIDTH=47><CENTER><I>type?</I></CENTER>
</TD><TD WIDTH=47><CENTER><I>query
<BR>
type?</I></CENTER>
</TD></TR>
<TR><TD WIDTH=100>A<BR>
NS<BR>
CNAME<BR>
PTR<BR>
HINFO<BR>
MX
</TD><TD WIDTH=66><CENTER>1<BR>
2<BR>
5<BR>
12<BR>
13<BR>
15</CENTER>
</TD><TD WIDTH=230>IP address<BR>
name server<BR>
canonical name<BR>
pointer record<BR>
host info<BR>
mail exchange record
</TD><TD WIDTH=47><CENTER>*<BR>
*<BR>
*<BR>
*<BR>
*<BR>
*</CENTER>
</TD><TD WIDTH=47><CENTER>*<BR>
*<BR>
*<BR>
*<BR>
*<BR>
*</CENTER>
</TD></TR>
<TR><TD WIDTH=100>AXFR<BR>
* or ANY</TD><TD WIDTH=66><CENTER>252<BR>
255</CENTER>
</TD><TD WIDTH=230>request for zone transfer<BR>
request for all records
</TD><TD WIDTH=47></TD><TD WIDTH=47><CENTER>*<BR>
*</CENTER>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.7</B> <I>type</I>
and <I>query type</I> values for DNS questions and responses.</CENTER>
<P>
The most common query type is an A type, which means
an IP address is desired for the <I>query name.</I> A PTR query
requests the names corresponding to an IP address. This is a pointer
query that we describe in <a href="#14_5">Section 14.5</a>. We describe the other
query types in <a href="#14_6">Section 14.6</a>.
<P>
The <I>query class</I> is normally 1, meaning Internet
address. (Some other non-IP values are also supported at some
locations.)
<H4>Resource Record Portion of DNS Response Message</H4>
<P>
The final three fields in the DNS message, the <I>answers</I>,<I>
authority</I>, and <I>additional information</I> fields, share
a common format called a <I>resource record</I> or <I>RR.</I>
Figure 14.8 shows the format of a resource record.
<P>
<CENTER><a name="fig_14_8"><img src="f_14_8.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_8.gif"></a><br>
<B>Figure 14.8</B> Format
of DNS resource record.</CENTER>
<P>
The <I>domain name</I> is the name to which the following
resource data corresponds. It is in the same format as we described
earlier for the <I>query name</I> field (<a href="#fig_14_6">Figure 14.6</a>).
<P>
The <I>type</I> specifies one of the RR type codes.
These are the same as the <I>query type</I> values that we described
earlier. The <I>class</I> is normally 1 for Internet data.
<P>
The <I>time-to-live</I> field is the number of seconds
that the RR can be cached by the client. RRs often have a TTL
of 2 days.
<P>
The <I>resource data length</I> specifies the amount
of <I>resource data.</I> The format of this data depends on the
<I>type.</I> For a type of 1 (an A record) the resource data is
a 4-byte IP address.
<P>
Now that we've described the basic format of the
DNS queries and responses, we'll see what is passed in the packets
by watching some exchanges using tcpdump.
<a name="14_4"><H3>14.4 A Simple Example</H3></a>
<P>
Let's start with a simple example to see the communication
between a resolver and a name server. We'll run the Telnet client
on the host <TT>sun</TT> to the host <TT>gemini</TT>,
connecting to the daytime server:
<TABLE>
<TR><TD WIDTH=320><TT>sun % <B>telnet gemini daytime<BR>
</B>Trying 140.252.1.11 ...<BR>
Connected to gemini. tuc.noao.edu.<BR>
Escape character is '^]'<BR>
Wed Mar 24 10:44:17 1993<BR>
Connection closed by foreign host.</TT>
</TD><TD WIDTH=340><BR>
<I>first three lines of output are from Telnet client<BR>
<BR><br>
<I>this is the output from the daytime server<BR>
<I>and this is from the Telnet client</I></I></I>
</TD></TR>
</TABLE>
<P>
For this example we direct the resolver on the host
sun (where the Telnet client is run) to use the name server on
the host <TT>noao.edu</TT> (140.252.1.54).
Figure 14.9 shows the arrangement of the three systems.
<P>
<CENTER><a name="fig_14_9"><img src="f_14_9.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_9.gif"></a><br>
<B>Figure 14.9</B> Systems
being used for simple DNS example.</CENTER>
<P>
As we've mentioned before, the resolver is part of
the client, and the resolver contacts a name server to obtain
the IP address before the TCP connection can be established between
Telnet and the daytime server.
<P>
In this figure we've omitted the detail that the
connection between <TT>sun</TT> and the 140.252.1
Ethernet is really a SLIP link (see the figure on the inside front
cover) because that doesn't affect the discussion. We will, however,
run <TT>tcpdump</TT> on the SLIP link to see
the packets exchanged between the resolver and name server.
<P>
The file <TT>/etc/resolv.conf</TT>
on the host <TT>sun</TT> tells the resolver
what to do:
<P>
<TT>sun % <B>cat /etc/resolv.conf
<BR>
</B>nameserver 140.252.1.54<BR>
domain tuc.noao.edu</TT>
<P>
The first line gives the IP address of the name server
- the host <TT>noao.edu</TT>. Up to three
<TT>nameserver</TT> lines can be specified,
to provide backup in case one is down or unreachable. The <TT>domain</TT>
line specifies the default domain. If the name being looked up
is not a fully qualified domain name (it doesn't end with a period)
then the default domain <TT>.tuc.noao.edu</TT>
is appended to the name. This is why we can type <TT>telnet
gemini</TT> instead of <TT>telnet gemini.tuc.noao.edu</TT>.
Figure 14.10 shows the packet exchange between the resolver and
name server.
<CENTER>
<a name="fig_14_10"><TABLE></a>
<TR><TD WIDTH=17>1</TD><TD WIDTH=180><TT>0.0</TT>
</TD><TD WIDTH=490><TT>140.252.1.29.1447 &gt; 140.252.1.54.53: 1+ A?
<BR>
gemini.tuc.noao.edu. (37)</TT>
</TD></TR>
<TR><TD WIDTH=17>2</TD><TD WIDTH=180><TT>0.290820 (0.2908)</TT>
</TD><TD WIDTH=490><TT>140.252.1.54.53 &gt; 140.252.1.29.1447: 1* 2/0/0 A
<BR>
140.252.1.11 (69)</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.10</B> <TT>tcpdump</TT>
output for name server query of the hostname <TT>gemini.tuc.noao.edu</TT>.</CENTER>
<P>
We've instructed <TT>tcpdump</TT>
not to print domain names for the source and destination IP addresses
of each IP datagram. Instead it prints 140.252.1.29 for the client
(the resolver) and 140.252.1.54 for the name server. Port 1447
is the ephemeral port used by the client and 53 is the well-known
port for the name server. If <TT>tcpdump</TT>
had tried to print names instead of IP addresses, then it would
have been contacting the same name server (doing pointer queries),
confusing the output.
<P>
Starting with line 1, the field after the colon (<TT>1+</TT>)
means the identification field is 1, and the plus sign means the
RD flag (recursion desired) is set. We see that by default, the
resolver asks for recursion.
<P>
The next field, <TT>A?</TT>,
means the query type is A (we want an IP address), and the question
mark indicates it's a query (not a response). The query name is
printed next: <TT>gemini.tuc.noao.edu.</TT>.
The resolver added the final period to the query name, indicating
that it's an absolute domain name.
<P>
The length of user data in the UDP datagram is shown
as 37 bytes: 12 bytes are the fixed-size header (<a href="#fig_14_3">Figure 14.3</a>);
21 bytes for the query name (<a href="#fig_14_6">Figure 14.6</a>), and 4 bytes for the
query type and query class. The odd-length UDP datagram reiterates
that there is no padding in the DNS messages.
<P>
Line 2 in the tcpdump output is the response from
the name server and <TT>1*</TT> is the identification
field with the asterisk meaning the AA flag (authoritative answer)
is set. (We expect this server, the primary server for the <TT>noao.edu</TT>
domain, to be authoritative for names within its domain.)
<P>
The output <TT>2/0/0</TT> shows
the number of resource records in the final three variable-length
fields in the response: 2 answer RRs, 0 authority RRs, and 0 additional
RRs. <TT>tcpdump</TT> only prints the first
answer, which in this case has a type of A (IP address) with a
value of 140.252.1.11.
<P>
Why do we get two answers to our query? Because the
host <TT>gemini</TT> is multihomed. Two IP
addresses are returned. Indeed, another useful tool with the DNS
is a publicly available program named host. It lets us issue queries
to a name server and see <I>what</I> comes back. If we run this
program we'll see the two IP addresses for this host:
<TABLE>
<TR><TD WIDTH=220><TT>sun % <B>host gemini</B></TT>
</TD><TD WIDTH=47></TD><TD WIDTH=132></TD></TR>
<TR><TD WIDTH=220><TT>gemini.tuc.noao.edu</TT></TD><TD WIDTH=47><TT>A</TT>
</TD><TD WIDTH=132><TT>140.252.1.11</TT></TD></TR>
<TR><TD WIDTH=220><TT>gemini.tuc.noao.edu</TT></TD><TD WIDTH=47><TT>A</TT>
</TD><TD WIDTH=132><TT>140.252.3.54</TT></TD></TR>
</TABLE>
<P>
The first answer in <a href="#fig_14_10">Figure 14.10</a> and the first line
of output from the <TT>host</TT> command are
the IP address that shares the same subnet (140.252.1) as the
requesting host. This is not an accident. If the name server and
the host issuing the query are on the same network (or subnet),
then BIND sorts the results so that addresses on common networks
appear first.
<P>
We can still access the host <TT>gemini</TT>
using the other address, but it might be less efficient. Using
<TT>traceroute</TT> in this instance shows
that the normal route from subnet 140.252.1 to 140.252.3 is not
through the host <TT>gemini</TT>, but through
another router that's connected to both networks. So in this case
if we accessed <TT>gemini</TT> through the
other IP address (140.252.3.54) all the packets would require
an additional hop. We return to this example and explore the reason
for the alternative route in <a href="snmp_sim.htm#25_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/snmp_sim.htm#25_9">Section 25.9</a>, when we can use SNMP
to look at a router's routing table.
<P>
There are other programs that provide easy interactive
access to the DNS. <TT>nslookup</TT> is supplied
with most implementations of the DNS. Chapter 10 of [Albitz and
Liu 1992] provides a detailed description of how to use this program.
The <TT>dig</TT> program (&quot;Domain Internet
Groper&quot;) is another publicly available tool that queries
DNS servers, <TT>doc</TT> (&quot;Domain Obscenity
Control&quot;) is a shell script that uses <TT>dig</TT>
and diagnoses misbehaving domains by sending queries to the appropriate
DNS name servers, and performing simple analysis of the responses.
See Appendix F for details on how to obtain these programs.
<P>
The final detail to account for in this example is
the size of the UDP data in the reply: 69 bytes. We need to know
two points to account for these bytes.
<OL>
<LI>The question is returned in the reply.
<LI>There can be many repetitions of domain names
in a reply, so a compression scheme is used. Indeed, in our example,
there are three occurrences of the domain name <TT>gemini.tuc.noao.edu</TT>.
<P>
The compression scheme is simple. Anywhere the
label portion of a domain name can occur, the single count byte
(which is between 0 and 63) has its two high-order bits turned
on instead. This means it is a 16-bit <I>pointer</I> and not an
8-bit count byte. The 14 bits that follow in the pointer specify
an offset in the DNS message of a label to continue with. (The
offset of the first byte in the identification field is 0.) We
purposely said that this pointer can occur wherever a label can
occur, not just where a complete domain name can. occur, since
it's possible for a pointer to form either a complete domain name
or just the ending portion of a name. (This is because the ending
labels in the names from a given domain tend to be identical.)
</OL>
<P>
Figure 14.11 shows the format of the DNS reply, line
2 from <a href="#fig_14_10">Figure 14.10</a>. We also show the IP and UDP headers to reiterate
that DNS messages are normally encapsulated in UDP datagrams.
We explicitly show the count bytes in the labels of the domain
name in the question. The two answers returned are the same, except
for the different IP addresses returned in each answer. In this
example the pointer in each answer would have a value of 12, the
offset from the start of the DNS header of the complete domain
name.
<P>
The final point to note from this example is from
the second line of output from the Telnet command, which we repeat
here:
<TABLE>
<TR><TD WIDTH=300><TT>sun % <B>telnet gemini daytime</B></TT>
</TD><TD WIDTH=350><I>we only type <TT>gemini</TT></I>
</TD></TR>
<TR><TD WIDTH=300><TT>Trying 140.252.1.11</TT></TD><TD WIDTH=300>
</TD></TR>
<TR><TD WIDTH=300><TT>... Connected to gemini.tuc.noao.edu.</TT>
</TD><TD WIDTH=350><I>but the Telnet client outputs FQDN</I>
</TD></TR>
</TABLE>
<P>
We typed just the hostname (<TT>gemini</TT>),
not the FQDN, but the Telnet client output the FQDN. What's happening
is that the Telnet client looks up the name we type by calling

<P>
<CENTER><a name="fig_14_11"><img src="f_14_11.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_11.gif"></a><br>
<B>Figure 14.11</B> Format
of DNS reply corresponding to line 2 of <a href="#fig_14_10">Figure 14.10</a>.</CENTER>
<P>
the resolver (<TT>gethostbyname</TT>),
which returns the IP addresses and the FQDN. Telnet then prints
the IP address that it's trying to establish a TCP connection
with, and when the connection is established, it outputs the FQDN.
<P>
If there is a significant pause between typing the
Telnet command and printing the IP address, this delay is caused
by the resolver contacting a name server to resolve the name into
an IP address. A pause between printing <TT>Trying</TT>
and <TT>Connected to</TT>, however, is a delay
caused by the establishment of the TCP connection between the
client and server, not the DNS.
<a name="14_5"><H3>14.5 Pointer Queries</H3></a>
<P>
A perpetual stumbling block in understanding the
DNS is how pointer queries are handled - given an IP address,
return the name (or names) corresponding to that address.
<P>
First return to <a href="#fig_14_1">Figure 14.1</a> and examine the <TT>arpa</TT>
top-level domain, and the <TT>in-addr</TT>
domain beneath it. When an organization joins the Internet and
obtains authority for a portion of the DNS name space, such as
<TT>noao.edu</TT>, they also obtain authority
for a portion of the <TT>in-addr.arpa</TT>
name space corresponding to their IP address on the Internet.
In the case of <TT>noao.edu</TT> it is the
class B network ID 140.252. The level of the DNS tree beneath
<TT>in-addr.arpa</TT> must be the first byte
of the IP address (140 in this example), the next level is the
next byte of the IP address (252), and so on. But remember that
names are written starting at the bottom of the DNS tree, working
upward. This means the DNS name for the host <TT>sun</TT>,
with an IP address of 140.252.13.33, is 33.13.252.140. <TT>in-addr.arpa</TT>.
<P>
We have to write the 4 bytes of the IP address backward
because authority is delegated based on network IDs: the first
byte of a class A address, the first and second bytes of a class
B address, and the first, second, and third bytes of a class C
address. The first byte of the IP address must be immediately
below the <TT>in-addr</TT> label, but FQDNs
are written from the bottom of the tree up. If FQDNs were written
from the top down, then the DNS name for the IP address would
be <TT>arpa.in-addr.140.252.13.33</TT>, but
the FQDN for the host would be <TT>edu.noao.tuc.sun</TT>.
<P>
If there was not a separate branch of the DNS tree
for handling this address-to-name translation, there would be
no way to do the reverse translation other than starting at the
root of the tree and trying <I>every</I> top-level domain. This
could literally take days or weeks, given the current size of
the Internet. The <TT>in-addr.arpa</TT> solution
is a clever one, although the reversed bytes of the IP address
and the special domain are confusing.
<P>
Having to worry about the <TT>in-addr.arpa</TT>
domain and reversing the bytes of the IP address affects us only
if we're dealing directly with the DNS, using a program such as
<TT>host</TT>, or watching the packets with
<TT>tcpdump</TT>. From an application's point
of view, the normal resolver function (<TT>gethostbyaddr</TT>)
takes an IP address and returns information about the host. The
reversal of the bytes and appending the domain <TT>in-addr.arpa</TT>
are done automatically by this resolver function.
<H4>Example</H4>
<P>
Let's use the <TT>host</TT> program
to do a pointer lookup and watch the packets with <TT>tcpdump</TT>.
We'll use the same setup as in <a href="#fig_14_9">Figure 14.9</a>, running the <TT>host</TT>
program on the host <TT>sun</TT>, and the
name server on the host <TT>noao.edu</TT>.
We specify the IP address of our host <TT>svr4</TT>:
<P>
<TT>sun % <B>host 140.252.13.34
<BR>
</B>Name: svr4.tuc.noao.edu<BR>
Address: 140.252.13.34</TT>
<P>
Since the only command-line argument is an IP address,
the <TT>host</TT> program automatically generates
the pointer query. Figure 14.12 shows the <tt>tcpdump</tt> output.
<CENTER>
<a name="fig_14_12"><TABLE></a>
<TR><TD WIDTH=26>1</TD><TD WIDTH=180><TT>0.0</TT>
</TD><TD WIDTH=520><TT>140.252.1.29.1610 &gt; 140.252.1.54.53: 1+ PTR?
<BR>
34.13.252.140.in-addr.arpa. (44)</TT>
</TD></TR>
<TR><TD WIDTH=26>2</TD><TD WIDTH=180><TT>0.332288 (0.3323)</TT>
</TD><TD WIDTH=520><TT>140.252.1.54.53 &gt; 140.252.1.29.1610: 1* 1/0/0 PTR
<BR>
svr4.tuc.noao.edu. (75)</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.12</B> <TT>tcpdump</TT>
output for a pointer query.</CENTER>
<P>
Line 1 shows that the identifier is 1, the recursion-desired
flag is set (the plus sign), and the query type is PTR. (Recall
that the question mark means this is a query and not a response.)
The data size of 44 bytes is from the 12-byte DNS header, 28 bytes
for the 7 labels in the domain name, and 4 bytes for the query
type and query class.
<P>
The reply has the authoritative-answer bit set (the
asterisk) and contains one answer RR. The RR type is PTR and the
resource data contains the domain name.
<P>
What is passed from the resolver to the name server
for a pointer query is not a 32-bit IP address, but the domain
name <TT>34.13.252.140.in-addr.arpa</TT>.
<H4>Hostname Spoofing Check</H4>
<P>
When an IP datagram arrives at a host for a server,
be it a UDP datagram or a TCP connection request segment, all
that's available to the server process is the client's IP address
and port number (UDP or TCP). Some servers require the client's
IP address to have a pointer record in the DNS. We'll see an example
of this, using anonymous FTP from an unknown IP address, in <a href="ftp_file.htm#27_9" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/ftp_file.htm#27_9">Section 27.3</a>.
<P>
Other servers, such as the Rlogin server (Chapter
26), not only require that the client's IP address have a pointer
record, but then ask the DNS for the IP addresses corresponding
to the name returned in the PTR response, and require that one
of the returned addresses match the source IP address in the received
datagram. This check is because entries in the <TT>.rhosts</TT>
file (<a href="telnet.htm#26_2" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/telnet.htm#26_2">Section 26.2</a>) contain the hostname, not an IP address, so
the server wants to verify that the hostname really corresponds
to the incoming IP address.
<P>
Some vendors automatically put this check into their
resolver routines, specifically the function <TT>gethostbyaddr</TT>.
This makes the check available to any program using the resolver,
instead of manually placing the check in each application.
<P>
We can see an example of this using the SunOS 4.1.3
resolver library. We have written a simple program that performs
a pointer query by calling the function <TT>gethostbyaddr</TT>.
We have also set our <TT>/etc/resolv.conf</TT>
file to use the name server on the host <TT>noao.edu</TT>,
which is across the SLIP link from the host <TT>sun</TT>.
Figure 14.13 shows the <TT>tcpdump</TT> output
collected on the SLIP link when the function <TT>gethostbyaddr</TT>
is called to fetch the name corresponding to the IP address 140.252.1.29
(our host <TT>sun</TT>).
<CENTER>
<a name="fig_14_13"><TABLE></a>
<TR><TD WIDTH=26><TT>1</TT></TD><TD WIDTH=180><TT>0.0</TT>
</TD><TD WIDTH=420><TT>sun. 1812 &gt; noao.edu.domain: 1+ PTR?
<BR>
29.1.252.140.in-addr.arpa. (43) </TT>
</TD></TR>
<TR><TD WIDTH=26><TT>2</TT></TD><TD WIDTH=180><TT>0.339091 (0.3391)</TT>
</TD><TD WIDTH=420><TT>noao.edu.domain &gt; sun.1812: 1* 1/0/0 PTR
<BR>
sun.tuc.noao.edu. (73)</TT>
</TD></TR>
<TR><TD WIDTH=26><TT>3</TT></TD><TD WIDTH=180><TT>0.344348 (0.0053)</TT>
</TD><TD WIDTH=420><TT>sun. 1813 &gt; noao.edu.domain: 2+ A?
<BR>
sun.tuc.noao.edu. (33)</TT>
</TD></TR>
<TR><TD WIDTH=26><TT>4</TT></TD><TD WIDTH=180><TT>0.669022 (0.3247)</TT>
</TD><TD WIDTH=420><TT>noao.edu.domain &gt; sun.1813: 2* 2/0/0 A
<BR>
140.252.1.29 (69)</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.13</B> Calling
resolver function to perform pointer query</CENTER>
<P>
Line 1 is the expected pointer query, and line 2
is the expected response. But the resolver function automatically
sends an IP address query in line 3 for the name returned in line
2. The response in line 4 contains two answer records, since the
host sun has two IP addresses. If one of the addresses does not
match the argument to <TT>gethostbyaddr</TT>,
a message is sent to the system logging facility, and the function
returns an error to the application.
<a name="14_6"><H3>14.6 Resource Records</H3></a>
<P>
We've seen a few different types of resource records
(RRs) so far: an IP address has a type of A, and PTR means a pointer
query. We've also seen that RRs are what a name server returns:
answer RRs, authority RRs, and additional information RRs. There
are about 20 different types of resource records, some of which
we'll now describe. Also, more RR types are being added over time.
<TABLE BORDER =1>
<TR><TD WIDTH=64>A</TD><TD WIDTH=676>An A record defines an IP address. It is stored as a 32-bit binary value.
</TD></TR>
<TR><TD WIDTH=64>PTR</TD><TD WIDTH=676>This is the pointer record used for pointer queries. The IP address is represented as a domain name (a sequence of labels) in the <TT>in-addr.arpa</TT> domain.
</TD></TR>
<TR><TD WIDTH=64>CNAME</TD><TD WIDTH=676>This stands for &quot;canonical name.&quot; It is represented as a domain name (a sequence of labels). The domain name that has a canonical name is often called an <I>alias.</I> These are used by some FTP sites to







 provide an easy to remember alias for some other system.
<P>
For example, the <TT>gated</TT> server (mentioned in <a href="dynamic.htm#10_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/dynamic.htm#10_3">Section 10.3</a>) is available through anonymous FTP from the server <TT>gated.cornell.edu</TT>. But there is no system named <TT>gated</TT>, this is an alias for some other
system. That other system is the canonical name for <TT>gated.cornell.edu</TT>:
<P>
<TT>sun % <B>host -t cname gated.cornell.edu<BR>
</B>gated.cornell.edu CNAME COMET.CIT.CORNELL.EDO</TT>
<P>
Here we use the <TT>-t</TT> option to specify one particular query type.
</TD></TR>
<TR><TD WIDTH=64>HINFO</TD><TD WIDTH=676>Host information: two arbitrary character strings specifying the CPU and operating system. Not all sites provide HINFO records for all their systems, and the information provided may not be up to date.
<P>
<TT>sun % <B>host -t hinfo sun<BR>
</B>sun.tuc.noao.edu HINFO Sun-4/25 Sun4.1.3</TT>
</TD></TR>
<TR><TD WIDTH=64>MX</TD><TD WIDTH=676>Mail exchange records, which are used in the following scenarios: (1) A site that is not connected to the Internet can get an Internet-connected site to be its mail exchanger. The two sites then work out an alternati







ve way to exchange any mail that arrives, often using the UUCP protocol. (2) MX records provide a way to deliver mail to an alternative host when the destination host is not available. (3) MX records allow organizations to provide virtual hosts that one
can send mail to, such as <TT>cs.university.edu</TT>, even if a host with that name doesn't exist. (4) Organizations with firewall gateways can use MX records to limit connectivity to internal systems.
<P>
Many sites that are not connected to the Internet have a UUCP link with an Internet connected site such as UUNET. MX records are then provided so that electronic mail can be sent to the site using the standard <TT>user@host</TT> notation. For example, a
fictitious domain <TT>foo.com</TT> might have the following MX records:
<P>
<TT>sun % <B>host -t mx foo.com<BR>
</B>foo.com MX relayl.UU.NET<BR>
foo.com MX relay2.UH.NET</TT>
<P>
MX records are used by mailers on hosts connected to the Internet. In this example the other mailers are told &quot;if you have mail to send to <TT>user@foo.com</TT>, send the mail to <TT>relay1.uu.net</TT> or <TT>relay2.uu.net</TT>.&quot;
<P>
MX records have 16-bit integers assigned to them, called <I>preference values. </I>If multiple MX records exist for a destination, they're used in order, starting with the smallest preference value.
<P>
Another example of MX records handles the case when a host is down or unavailable. In that case the mailer uses the MX records only if it can't connect to the destination using TCP. In the case of the author's primary system, which is connected to the In







ternet by a SLIP connection, which is down most of the time, we have:
<P>
<TT>sun % <B>host -tv mx sun<BR>
</B>Query about sun for record types MX<BR>
Trying sun within tuc.noao.edu ...<BR>
Query done, 2 answers, authoritative status: no error<BR>
sun.tuc.noao.edu 86400 IN MX 0 sun.tuc.noao.edu<BR>
sun.tuc.noao.edu 86400 IN MX 10 noao.edu</TT>
<P>
We also specified the <TT>-v</TT> option, to see the preference values. (This option also causes other fields to be output.) The second field, 86400, is the time-to-live value in seconds. This TTL is 24 hours (24 x 60 x 60). The third column, IN, is the
class (Internet). We see that direct delivery to the host itself, the first MX record, has the lowest preference value of 0. If that doesn't work (i.e., the SLIP link is down), the next higher preference is used (10) and delivery is attempted to the host







 <TT>noao.edu</TT>. If that doesn't work, the sender will time out and retry at a later time.
<P>
In <a href="smtp_sim.htm#28_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/smtp_sim.htm#28_3">Section 28.3</a> we show examples of SMTP mail delivery using MX records.
</TD></TR>
<TR><TD WIDTH=64>NS</TD><TD WIDTH=676>Name server record. These specify the authoritative name server for a domain. They are represented as domain names (a sequence of labels). We'll see examples of these records in the <a href="#14_7">next section</a>.
</TD></TR>
</TABLE>
<P>
These are the common types of RRs. We'll encounter
many of them in later examples.
<a name="14_7"><H3>14.7 Caching</H3></a>
<P>
To reduce the DNS traffic on the Internet, all name
servers employ a cache. With the standard Unix implementation,
the cache is maintained in the server, not the resolver. Since
the resolver is part of each application, and applications come
and go, putting the cache into the program that lives the entire
time the system is up (the name server) makes sense. This makes
the cache available to any applications that use the server. Any
other hosts at the site that use this name server also share the
server's cache.
<P>
In the scenario that we've used for our examples
so far (<a href="#fig_14_9">Figure 14.9</a>), we've run the clients on the host sun accessing
the name server across the SLIP link on the host <TT>noao.edu</TT>.
We'll change that now and run the name server on the host <TT>sun</TT>.
In this way if we monitor the DNS traffic on the SLIP link using
<TT>tcpdump</TT>, we'll only see queries that
can't be handled by the server out of its cache.
<P>
By default, the resolver looks for a name server
on the local host (UDP port 53 or TCP port 53). We delete the
<TT>nameserver</TT> directive from our resolver
file, leaving only the domain directive:
<P>
<TT>sun % <B>cat /etc/resolv.conf
<BR>
</B>domain tuc.noao.edu</TT>
<P>
The absence of a <TT>nameserver</TT>
directive in this file causes the resolver to use the name server
on the local host.
<P>
We then use the <TT>host</TT>
command to execute the following query:
<P>
<TT>sun % <B>host ftp.uu.net<BR>
</B>ftp.uu.net A 192.48.96.9</TT>
<P>
Figure 14.14 shows the <TT>tcpdump</TT>
output for this query.
<CENTER>
<a name="fig_14_14"><TABLE></a>
<TR><TD WIDTH=26>1</TD><TD WIDTH=200><TT>0.0</TT>
</TD><TD WIDTH=510><TT>sun.tuc.noao.edu.domain &gt; NS.NIC.DDN.MIL.domain:
<BR>
2 A? ftp.uu.net. (28)</TT>
</TD></TR>
<TR><TD WIDTH=26>2</TD><TD WIDTH=200><TT>0.559285 ( 0.5593)</TT>
</TD><TD WIDTH=510><TT>NS.NIC.DDN.MIL.domain &gt; sun.tuc.noao.edu.domain:
<BR>
2- 0/5/5 (229)</TT>
</TD></TR>
<TR><TD WIDTH=26>3</TD><TD WIDTH=200><TT>0.564449 ( 0.0052)</TT>
</TD><TD WIDTH=510><TT>sun.tuc.noao.edu.domain &gt; ns.UU.NET.domain:
<BR>
3+ A? ftp.uu.net. (28)</TT>
</TD></TR>
<TR><TD WIDTH=26>4</TD><TD WIDTH=200><TT>1.009476 ( 0.4450)</TT>
</TD><TD WIDTH=510><TT>ns.UU.NET.domain &gt; sun.tuc.noao.edu.domain:
<BR>
3* 1/0/0 A ftp.UU.NET (44)</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.14</B> <TT>tcpdump</TT>
output for: <TT>host ftp.uu.net</TT>.</CENTER>
<P>
This time we've used a new option for tcpdump. We
collected all the data to or from UDP or TCP ports 53 with the
<TT>-w</TT> option. This saves the raw output
in a file for later processing. This prevents <TT>tcpdump</TT>
from trying to call the resolver itself, to print all the names
corresponding to the IP addresses. After we ran our queries, we
terminated <TT>tcpdump</TT> and reran it with
the <TT>-r</TT> option. This causes it to
read the raw output file and generate its normal printed output
(which we show in Figure 14.14). This takes a few seconds, since
<TT>tcpdump</TT> calls the resolver itself.
<P>
The first thing to notice in our <TT>tcpdump</TT>
output is that the identifiers are small integers (2 and 3). This
is because we terminated the name server, and then restarted it,
to force the cache to be empty. When the name server starts up,
it initializes the identifier to 1.
<P>
When we type our query, looking for the IP address
of the host <TT>ftp.uu.net</TT>, the name
server contacts one of the eight root servers, <TT>ns.nic.ddn.mil</TT>
(line 1). This is the normal A type query that we've seen before,
but notice that the recursion-desired flag is <I>not</I> specified.
(A plus sign would have been printed after the identifier 2 if
the flag was set.) In our earlier examples we always saw the resolver
set the recursion-desired flag, but here we see that our name
server doesn't set the flag when it's contacting one of the root
servers. This is because the root servers shouldn't be asked to
recursively answer queries-they should be used only to find the
addresses of other, authoritative servers.
<P>
Line 2 shows that the response comes back with no
answer RRs, five authority RRs, and five additional information
RRs. The minus sign following the identifier 2 means the recursion-available
(RA) flag was not set-this root server wouldn't answer a recursive
query even if we asked it to.
<P>
Although <TT>tcpdump</TT> doesn't
print the 10 RRs that are returned, we can execute the host command
to see what's in the cache:
<P>

<P>
<TABLE>
<TR><TD COLSPAN=5 WIDTH=499><TT>sun % host -v ftp.uu.net</TT>
</TD></TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>Query about ftp.uu.net for record types A</TT>
</TD></TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>Trying ftp.uu.net ...</TT></TD>
</TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>Query done, 1 answer, status: no error</TT>
</TD></TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>The following answer is not authoritative:</TT>
</TD></TR>
<TR><TD WIDTH=177><TT>ftp.uu.net</TT></TD><TD WIDTH=66><TT>19109</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>192.48.96.9</TT></TD></TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>Authoritative nameservers:</TT>
</TD></TR>
<TR><TD WIDTH=177><TT>UU.NET</TT></TD><TD WIDTH=66><TT>170308</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>NS</tt>
</TD><TD WIDTH=180><TT>NS.UU.NET</TT></TD></TR>
<TR><TD WIDTH=177><TT>UU.NET</TT></TD><TD WIDTH=66><TT>170308</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>NS</tt>
</TD><TD WIDTH=180><TT>UUNET.UU.NET</TT></TD></TR>
<TR><TD WIDTH=177><TT>UU.NET</TT></TD><TD WIDTH=66><TT>170308</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><TT>NS</TT></TD>
<TD WIDTH=180><TT>UUCP-GW-1.PA.DEC.COM</TT></TD></TR>
<TR><TD WIDTH=177><TT>UU.NET</TT></TD><TD WIDTH=66><TT>170308</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>NS</tt>
</TD><TD WIDTH=180><TT>UUCP-GW-2.PA.DEC.COM</TT></TD></TR>
<TR><TD WIDTH=177><TT>UU.NET</TT></TD><TD WIDTH=66><TT>170308</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>NS</tt>
</TD><TD WIDTH=180><TT>NS.EU.NET</TT></TD></TR>
<TR><TD COLSPAN=5 WIDTH=499><TT>Additional information:</TT></TD>
</TR>
<TR><TD WIDTH=177><TT>NS.UU.NET</TT></TD><TD WIDTH=66><TT>170347</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>137.39.1.3</TT></TD></TR>
<TR><TD WIDTH=177><TT>UUNET.UU.NET</TT></TD><TD WIDTH=66><TT>170347</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>192.48.96.2</TT></TD></TR>
<TR><TD WIDTH=177><TT>UUCP-GW-1.PA.DEC.COM</TT></TD><TD WIDTH=66><TT>170347</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>16.1.0.18</TT></TD></TR>
<TR><TD WIDTH=177><TT>UUCP-GW-2.PA.DEC.COM</TT></TD><TD WIDTH=66><TT>170347</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>16.1.0.19</TT></TD></TR>
<TR><TD WIDTH=177><TT>NS.EU.NET</TT></TD><TD WIDTH=66><TT>170347</TT>
</TD><TD WIDTH=38><TT>IN</TT></TD><TD WIDTH=38><tt>A</tt>
</TD><TD WIDTH=180><TT>192.16.202.11</TT></TD></TR>
</TABLE>
<P>
This time we specified the <TT>-v</TT>
option to see more than just the A record. This shows that there
are five authoritative name servers for the domain <TT>uu.net</TT>.
The five RRs with additional information that are returned by
the root server contain the IP addresses of these five name servers.
This saves us from having to contact the root server again, to
look up the address of one of the servers. This is another implementation
optimization in the DNS.
<P>
The <TT>host</TT> command states
that the answer is not authoritative. This is because the answer
was obtained from our name server's cache, not by contacting an
authoritative server.
<P>
Returning to line 3 of <a href="#fig_14_14">Figure 14.14</a>, our name server
contacts the first of the authoritative servers (<TT>ns.uu.net</TT>)
with the same question: What is the IP address of <TT>ftp.uu.net</TT>?
This time our server sets the recursion-desired flag. The answer
is returned on line 4 as a response with one answer RR.
<P>
We then execute the <TT>host</TT>
command again, asking for the same name:
<P>
<TT>sun % <B>host ftp.uu.net<BR>
</B>ftp.uu.net A 192.48.96.9</TT>
<P>
This time there is no <TT>tcpdump</TT>
output. This is what we expect, since the answer output by <TT>host</TT>
is returned from the server's cache.
<P>
We execute the <TT>host</TT>
command again, looking for the address of <TT>ftp.ee.lbl.gov</TT>:
<TABLE>
<TR><TD COLSPAN=3 WIDTH=310><TT>sun%hostftp.ee.lbl.gov</TT></TD>
</TR>
<TR><TD WIDTH=140><TT>ftp.ee.lbl.gov</TT></TD><TD WIDTH=57><TT>CNAME</TT>
</TD><TD WIDTH=113><TT>ee.lbl.gov</TT></TD></TR>
<TR><TD WIDTH=140><TT>ee.lbl.gov</TT></TD><TD WIDTH=57><TT>A</TT>
</TD><TD WIDTH=113><TT>128.3.112.20</TT></TD></TR>
</TABLE>
<P>
Figure 14.15 shows the <TT>tcpdump</TT>
output.
<CENTER>
<a name="fig_14_15"><TABLE></a>
<TR><TD WIDTH=26>1</TD><TD WIDTH=210><TT>18.664971 (17.6555)</TT>
</TD><TD WIDTH=510><TT>sun.tuc.noao.edu.domain &gt; c.nyser.net.domain:<BR>
4 A? ftp.ee.lbl.gov. (32)</TT>
</TD></TR>
<TR><TD WIDTH=26>2</TD><TD WIDTH=210><TT>19.429412 ( 0.7644)</TT>
</TD><TD WIDTH=510><TT>c.nyser.net.domain &gt; sun.tuc.noao.edu.domain:
<BR>
4 0/4/4 (188)</TT>
</TD></TR>
<TR><TD WIDTH=26>3</TD><TD WIDTH=210><TT>19.432271 ( 0.0029)</TT>
</TD><TD WIDTH=510><TT>sun.tuc.noao.edu.domain &gt; nsl.lbl.gov.domain:
<BR>
5+ A? ftp.ee.lbl.gov. (32)</TT>
</TD></TR>
<TR><TD WIDTH=26>4</TD><TD WIDTH=210><TT>19.909242 ( 0.4770)</TT>
</TD><TD WIDTH=510><TT>nsl.lbl.gov.domain &gt; sun.tuc.noao.edu.domain:
<BR>
5* 2/0/0 CNAME ee.lbl.gov. (72)</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER><B>Figure 14.15</B> <TT>tcpdump</TT>
output for: <TT>host ftp.ee.lbl.gov</TT>.</CENTER>
<P>
Line 1 shows that this time our server contacts another
of the root servers (<TT>c.nyser.net</TT>).
A name server normally cycles through the various servers for
a zone until round-trip estimates are accumulated. The server
with the smallest round-trip time is then used.
<P>
Since our server is contacting a root server, the
recursion-desired flag is not set. This root server does not clear
the recursion-available flag, as we saw in line 2 in <a href="#fig_14_14">Figure 14.14</a>.
(Even so, a name server still should not ask a root server for
a recursive query.)
<P>
In line 2 the response comes back with no answers,
but four authority RRs and four additional information RRs. As
we can guess, the four authority RRs are the names of the name
servers for <TT>ftp.ee.lbl.gov</TT>, and the
four other RRs contain the IP addresses of these four servers.
<P>
Line 3 is the query of the name server <TT>nsl.lbl.gov</TT>
(the first of the four name servers returned in line 2). The recursion-desired
flag is set.
<P>
The response in line 4 is different from previous
responses. Two answer RRs are returned and <TT>tcpdump</TT>
says that the first one is a CNAME RR. The canonical name of <TT>ftp.ee.lbl.gov</TT>
is <TT>ee.lbl.gov</TT>.
<P>
This is a common usage of CNAME records. The FTP
site for LBL always has a name beginning with <TT>ftp</TT>,
but it may move from one host to another over time. Users need
only know the name <TT>ftp.ee.lbl.gov</TT>
and the DNS will replace this with its canonical name when referenced.
<P>
Remember that when we ran <TT>host</TT>,
it printed both the CNAME and the IP address of the canonical
name. This is because the response (line 4 in <a href="#fig_14_15">Figure 14.15</a>) contained
two answer RRs. The first one is the CNAME and the second is the
A record. If the A record had not been returned with the CNAME,
our server would have issued another query, asking for the IP
address of <TT>ee.lbl.gov</TT>. This is another
implementation optimization-both the CNAME and the A record of
the canonical name are returned in one response.
<a name="14_8"><H3>14.8 UDP or TCP</H3></a>
<P>
We've mentioned that the well-known port numbers
for DNS name servers are UDP port 53 and TCP port 53. This implies
that the DNS supports both UDP and TCP. But all the examples that
we've watched with <TT>tcpdump</TT> have used
UDP. When is each protocol used and why?
<P>
When the resolver issues a query and the response
comes back with the TC bit set (&quot;truncated&quot;) it means
the size of the response exceeded 512 bytes, so only the first
512 bytes were returned by the server. The resolver normally issues
the request again, using TCP. This allows more than 512 bytes
to be returned. (Recall our discussion of the maximum UDP datagram
size in <a href="udp_user.htm#11_10" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/udp_user.htm#11_10">Section 11.10</a>.) Since TCP breaks up a stream of user data
into what it calls <I>segments,</I> it can transfer any amount
of user data, using multiple segments.
<P>
Also, when a secondary name server for a domain starts
up it performs a zone transfer from the primary name server for
the domain. We also said that the secondary queries the primary
on a regular basis (often every 3 hours) to see if the primary
has had its tables updated, and if so, a zone transfer is performed.
Zone transfers are done using TCP, since there is much more data
to transfer than a single query or response.
<P>
Since the DNS primarily uses UDP, both the resolver
and the name server must perform their own timeout and retransmission.
Also, unlike many other Internet applications that used UDP (TFTP,
BOOTP, and SNMP), which operate mostly on local area networks,
DNS queries and responses often traverse wide area networks. The
packet loss rate and variability in round-trip times are normally
higher on a WAN than a LAN, increasing the importance of a good
retransmission and timeout algorithm for DNS clients.
<a name="14_9"><H3>14.9 Another Example</H3></a>
<P>
Let's look at another example that ties together
many of the DNS features that we've described. We start an Rlogin
client, connecting to an Rlogin server in some other domain. Figure
14.16 shows the exchange of packets that takes place.
<P>
<CENTER><a name="fig_14_16"><img src="f_14_16.gif" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/gifs/f_14_16.gif"></a><br>
<B>Figure 14.16</B> Summary
of packets exchanged to start up Rlogin client and server</CENTER>
<P>
The following 11 steps take place, assuming none
of the information is already cached by the client or server:
<OL>
<LI>The client starts and calls its resolver function
to convert the hostname that we typed into an IP address. A query
of type A is sent to a root server.
<LI>The root server's response contains the name
servers for the server's domain.
<LI>The client's resolver reissues the query of type
A to the server's name server. This query normally has the recursion-desired
flag set.
<LI>The response comes back with the IP address of
the server host.
<LI>The Rlogin client establishes a TCP connection
with the Rlogin server. (Chapter 18 provides all the details of
this step.) Three packets are exchanged between the client and
server TCP modules.
<LI>The Rlogin server receives the connection from
the client and calls its resolver to obtain the name of the client
host, given the IP address that the server receives from its TCP.
This is a PTR query issued to a root name server. This root server
can be different from the root server used by the client in step
1.
<LI>The root server's response contains the name
servers for the client's <TT>in-addr.arpa</TT>
domain.
<LI>The server's resolver reissues the PTR query
to the client's name server.
<LI>The PTR response contains the FQDN of the client
host.
<LI>The server's resolver issues a query of type
A to the client's name server, asking for the IP addresses corresponding
to the name returned in the previous step. This may be done automatically
by the server's <TT>gethostbyaddr</TT> function,
as we described in <a href="#14_5">Section 14.5</a>, otherwise the Rlogin server does
this step explicitly. Also, the client's name server is often
the same as the client's <TT>in-addr.arpa</TT>
name server, but this isn't required.
<LI>The response from the client's name server contains
the A records for the client host. The Rlogin server compares
the A records with the IP address from. the client's TCP connection
request.
</OL>
<P>
Caching can reduce the number of packets exchanged
in this figure.
<a name="14_10"><H3>14.10 Summary</H3></a>
<P>
The DNS is an essential part of any host connected
to the Internet, and widely used in private internets also. The
basic organization is a hierarchical tree that forms the DNS name
space.
<P>
Applications contact resolvers to convert a hostname
to an IP address, and vice versa. Resolvers then contact a local
name server, and this server may contact one of the root servers
or other servers to fulfill the request.
<P>
All DNS queries and responses have the same message
format. This message contains questions and possibly answer resource
records (RRs), authority RRs, and additional RRs. We saw numerous
examples, showing the resolver configuration file and some of
the DNS optimizations: pointers to domain names (to reduce the
size of messages), caching, the <TT>in-addr.arpa</TT>
domain (to look up a name given an IP address), and returning
additional RRs (to save the requestor from issuing another query).
<H4>Exercises</H4>
<P>
<B>14.1</B> Classify a DNS resolver
and a DNS name server as either client, server, or both.
<P>
<B>14.2</B> Account for all 75
bytes in the response in <a href="#fig_14_12">Figure 14.12</a>.
<P>
<B>14.3</B> In <a href="broadcas.htm#12_3" tppabs="http://www.uic.rnd.runnet.ru/doc/inet/tcp_stevens/broadcas.htm#12_3">Section 12.3</a> we
said that an application that accepts either a dotted-decimal
IP address or a hostname should assume the former, and if that
fails, then assume a hostname. What happens if the order of the
tests is reversed?
<P>
<B>14.4</B> Every UDP datagram
has an associated length. A process that receives a UDP datagram
is told what its length is. When a resolver issues a query using
TCP instead of UDP, since TCP is a stream of bytes without any
record markers, how does the application know how much data is
returned? Notice that there is no length field in the DNS header
(<a href="#fig_14_3">Figure 14.3</a>). (<I>Hint:</I> Look at RFC 1035.)
<P>
<B>14.5</B> We said that a name
server must know the IP addresses of the root servers and that
this information is available via anonymous FTP. Unfortunately
not all system administrators update their DNS files whenever
changes are made to the list of root servers. (Changes do occur
to the list of root servers, but not frequently.) How do you think
the DNS handles this?
<P>
<B>14.6</B> Fetch the file specified
in Exercise 1.8 and determine who is responsible for maintaining
the root name servers. How frequently are the root servers updated?
<P>
<B>14.7 </B>What is a problem
with maintaining the cache in the name server, and having a stateless
resolver?
<P>
<B>14.8</B> In the discussion
of <a href="#fig_14_10">Figure 14.10</a> we said that the name server sorts the A records
so that addresses on common networks appear first. Who should
sort the A records, the name server or the resolver?
</BODY>
</HTML>
