<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<glsl_hacker>
	
  <window name="win3d01" title="Shader Toy, cells demo (OpenGL 2.1)" 
          width="800" height="600" 
          gl_version_major="2" gl_version_minor="1"
          build_opengl_extensions_list="0" />


<gpu_program name="gpu_program" >
	<raw_data_vs><![CDATA[	 
void main()
{	
	gl_TexCoord[0] = gl_MultiTexCoord0;
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;		
}
  ]]></raw_data_vs>
  
	<raw_data_ps><![CDATA[	 

  
uniform vec3      iResolution;     // viewport resolution (in pixels)
uniform float     iGlobalTime;     // shader playback time (in seconds)
uniform vec4      iMouse;          // mouse pixel coords. xy: current (if MLB down), zw: click
uniform samplerCube iChannel0;

// https://www.shadertoy.com/view/ldfGWn

float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }

#define Iterations 64
#define Thickness 0.1
#define SuperQuadPower 8.0
#define Fisheye 0.5

float truchetarc(vec3 pos)
{
	float r=length(pos.xy);
//	return max(abs(r-0.5),abs(pos.z-0.5))-Thickness;
//	return length(vec2(r-0.5,pos.z-0.5))-Thickness;
	return pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness;
}

float truchetcell(vec3 pos)
{
	return min(min(
	truchetarc(pos),
	truchetarc(vec3(pos.z,1.0-pos.x,pos.y))),
	truchetarc(vec3(1.0-pos.y,1.0-pos.z,pos.x)));
}

float distfunc(vec3 pos)
{
	vec3 cellpos=fract(pos);
	vec3 gridpos=floor(pos);

	float rnd=rand(gridpos);

	if(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));
	else if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));
	else if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));
	else if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));
	else if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,cellpos.z));
	else if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,cellpos.z));
	else if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,cellpos.z));
	else  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,cellpos.z));
}

vec3 gradient(vec3 pos)
{
	const float eps=0.0001;
	float mid=distfunc(pos);
	return vec3(
	distfunc(pos+vec3(eps,0.0,0.0))-mid,
	distfunc(pos+vec3(0.0,eps,0.0))-mid,
	distfunc(pos+vec3(0.0,0.0,eps))-mid);
}

void main()
{
	const float pi=3.141592;

	vec2 coords=(2.0*gl_FragCoord.xy-iResolution.xy)/length(iResolution.xy);

	float a=iGlobalTime/3.0;
	mat3 m=mat3(
	0.0,1.0,0.0,
	-sin(a),0.0,cos(a),
	cos(a),0.0,sin(a));
	m*=m;
	m*=m;

	vec3 ray_dir=m*normalize(vec3(1.4*coords,-1.0+Fisheye*(coords.x*coords.x+coords.y*coords.y)));

	float t=iGlobalTime/3.0;
	vec3 ray_pos=vec3(
    2.0*(sin(t+sin(2.0*t)/2.0)/2.0+0.5),
    2.0*(sin(t-sin(2.0*t)/2.0-pi/2.0)/2.0+0.5),
    2.0*((-2.0*(t-sin(4.0*t)/4.0)/pi)+0.5+0.5));

	float i=float(Iterations);
	for(int j=0;j<Iterations;j++)
	{
		float dist=distfunc(ray_pos);
		ray_pos+=dist*ray_dir;

		if(abs(dist)<0.001) { i=float(j); break; }
	}

	vec3 normal=normalize(gradient(ray_pos));

	float ao=1.0-i/float(Iterations);
	float what=pow(max(0.0,dot(normal,-ray_dir)),2.0);
	float vignette=pow(1.0-length(coords),0.3);
	float light=ao*what*vignette*1.4;

	float z=ray_pos.z/2.0;
//	vec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;
	vec3 col=(cos(ray_pos/2.0)+2.0)/3.0;

	vec3 reflected=reflect(ray_dir,normal);
	vec3 env=textureCube(iChannel0,reflected*reflected*reflected).xyz;

	gl_FragColor=vec4(col*light+0.1*env,1.0);
} ]]></raw_data_ps>

</gpu_program>


  
  
	<script name="init_scene" run_mode="INIT" >
		<raw_data><![CDATA[	
    
winW, winH = gh_window.getsize()
   
font_a = gh_utils.font_create("Tahoma", 14)


camera_ortho = gh_camera.create_ortho(-winW/2, winW/2, -winH/2, winH/2, 1.0, -1.0)
gh_camera.set_viewport(camera_ortho, 0, 0, winW, winH)
gh_camera.set_position(camera_ortho, 0, 0, 1)


gpu_prog_01 = gh_node.getid("gpu_program")

local abs_path=0
-- tex01 = gh_texture.create_from_file("./data/cell_texture.jpg", 3, abs_path)
cubemap = gh_texture.create_cube_from_file("./data/skybox08_posx.jpg", "./data/skybox08_negx.jpg", "./data/skybox08_posy.jpg", "./data/skybox08_negy.jpg", "./data/skybox08_posz.jpg", "./data/skybox08_negz.jpg", pf, abs_path, 0)

mesh_quad = gh_mesh.create_quad(winW, winH)
gh_object.use_gl2_vertex_array(mesh_quad, 1) -- *** Old OpenGL... ***

gh_renderer.set_vsync(0)
gh_renderer.set_scissor_state(0)

		]]></raw_data>
	</script> 
  
	<script name="update_scene" run_mode="FRAME" >
		<raw_data><![CDATA[	

elapsed_time = gh_utils.get_elapsed_time()

gh_renderer.set_depth_test_state(1)

gh_camera.bind(camera_ortho)

gh_renderer.clear_color_depth_buffers(0.2, 0.2, 0.2, 1.0, 1.0)

gh_gpu_program.bind(gpu_prog_01)
gh_gpu_program.uniform1f(gpu_prog_01, "iGlobalTime", elapsed_time)
gh_gpu_program.uniform3f(gpu_prog_01, "iResolution", winW, winH, 0)
mouse_x, mouse_y = gh_input.mouse_getpos() 
gh_gpu_program.uniform4f(gpu_prog_01, "iMouse", mouse_x, winH-mouse_y, 0, 0)
gh_gpu_program.uniform1i(gpu_prog_01, "iChannel0", 0);
-- gh_gpu_program.uniform1i(gpu_prog_01, "iChannel1", 1);
-- gh_gpu_program.uniform1i(gpu_prog_01, "iChannel3", 2);

gh_texture.bind(cubemap, 0)
gh_object.render(mesh_quad)

gh_utils.font_render(font_a, 10, 20, 0.8, 0.8, 0.3, 1.0, "GLSL Hacker demo - Shader Toy Demo (www.shadertoy.com)")

		]]></raw_data>
	</script> 
	

	<script name="resize_scene" run_mode="SIZE" >
		<raw_data><![CDATA[	

winW, winH = gh_window.getsize(0)

aspect = 1.333
if (winH > 0) then
  aspect = winW / winH
end  
gh_camera.update_ortho(camera_ortho, -winW/2, winW/2, -winH/2, winH/2, 1.0, -1.0)
gh_camera.set_viewport(camera_ortho, 0, 0, winW, winH)

gh_utils.font_set_viewport_info(font_a, 0, 0, winW, winH)

gh_mesh.update_quad_size(mesh_quad, winW, winH)

		]]></raw_data>
	</script> 
  
  
</glsl_hacker>
