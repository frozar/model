<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<glsl_hacker>
	
  <window name="win3d01" title="GLSL Sandbox, demo 3240_0 (OpenGL 2.1)" 
          width="800" height="600" 
          gl_version_major="2" gl_version_minor="1"
          build_opengl_extensions_list="0" />


<gpu_program name="gpu_program" >
	<raw_data_vs><![CDATA[	 
void main()
{	
	gl_TexCoord[0] = gl_MultiTexCoord0;
	//gl_Position = ftransform();		
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;		
}
  ]]></raw_data_vs>
  
	<raw_data_ps><![CDATA[	 
// http://glsl.heroku.com/e#3240.0

// Some hills...
// rotwang: @mod* lowered cam for better flight feeling
// @mod+ mouse y controls flight height
// @mod* some color tests
// @mod+ Canyon

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

//Simple raymarching sandbox with camera

//Raymarching Distance Fields
//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
//Also known as Sphere Tracing
//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024

//Util Start

mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );

float hash( float n )
{
    return fract(sin(n)*43758.5453);
}

float noise( in vec2 x )
{
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0;
    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);
    return res;
}

float fbm( vec2 p )
{
    float f = 0.0;
    f += 0.50000*noise( p ); p = m*p*2.02;
    f += 0.25000*noise( p ); p = m*p*2.03;
    f += 0.12500*noise( p ); p = m*p*2.01;
    f += 0.06250*noise( p ); p = m*p*2.04;
    f += 0.03125*noise( p );
    return f/0.984375;
}
vec2 ObjUnion(in vec2 obj_floor,in vec2 obj_roundBox){
  if (obj_floor.x<obj_roundBox.x)
  	return obj_floor;
  else
  	return obj_roundBox;
}
//Util End

//Scene Start

//Torus
float torus(in vec3 p, in vec2 t){
	vec2 q = vec2(length(vec2(p.x,p.z))-t.x, p.y);
	return length(q) - t.y;
}

//Sphere
float sphere(in vec3 p, float radius){
	float length = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
	return length-radius;
}

//Floor
vec2 terrain(in vec3 p){
	

	float da = sin(1.1*p.y); 
	float db = sin(5.6*p.y);
  	vec2 vd = vec2(p.y+fbm(p.xz / 8.0) * 9.0,0);
	vd.x += mix(da,db, 0.1);	
	return vd;
}

vec3 hsv2rgb(float h,float s,float v) {
	return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;
}

/**
@rotwang:
smoothes between 2 vectors a and b (eg colors)
using a source value and a smooth amount
about the base as center.
*/
vec3 smoothmix(vec3 a, vec3 b, float base, float smooth, float source)
{
	float f = smoothstep(base-smooth, base+smooth, source );
	vec3 vec = mix(a, b, f);
	return vec;
}


//Terrain Color 
vec3 terrain_clr(in vec3 p){
	
	
	vec3 clr_a = vec3(0.7, 0.4, 0.2);
	vec3 clr_b = vec3(0.7, 0.4, 0.2);
	float m = fract(p.y*12.0);
	float g = fbm(p.xz * 12.2);
	vec3 clr =  smoothmix(clr_a, clr_b,2.66, 10.03, m );
	clr = mix( clr, g*clr, 0.6);

 	return clr; 
}

//IQs RoundBox (try other objects http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)
vec2 obj_roundBox(in vec3 p){
  return vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);
}

vec2 obj_sphere(in vec3 p){
  return vec2(length(p)-2.0);
}

//RoundBox with simple solid color
vec3 obj_roundBox_c(in vec3 p){
	return vec3(1.0,0.5,0.2);
}

//Objects union
vec2 inObj(in vec3 p){
  return terrain(p);
}

//Scene End

void main(void){
  //Camera animation
  vec3 U=vec3(0,1,0);//Camera Up Vector

	float speed = time*2.0;
	float my =  4.0; // mouse.y*4.0;
	float camy = -3.3+my; 
	float tary = -4.0+my; 
  vec3 E=vec3(speed, camy, 0);//vec3(-sin(time/4.0)*8.0,4,cos(time/4.0)*8.0); //Camera location; Change camera path position here
  vec3 viewDir=vec3(E.x-sin(mouse.x*0.0),tary,E.z+cos(mouse.x*0.0)); //Change camere view vector here
  //vec3 E=vec3(mouse.x*0.0, 4, mouse.y*4.0); //Camera location; Change camera path position here
	
  //Camera setup
  vec3 C=normalize(viewDir-E);
  vec3 A=cross(C, U);
  vec3 B=cross(A, C);
  vec3 M=(E+C);
  
  vec2 vPos=2.0*gl_FragCoord.xy/resolution.xy - 1.0; // (2*Sx-1) where Sx = x in screen space (between 0 and 1)
  vec3 scrCoord=M + vPos.x*A*resolution.x/resolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)
  vec3 scp=normalize(scrCoord-E);

  //Raymarching
  const vec3 e=vec3(0.1,0,0);
  const float MAX_DEPTH=60.0; //Max depth

  vec2 s=vec2(0.1,0.0);
  vec3 c,p,n;

  float f=1.0;
  for(int i=0;i<100;i++){
    if (abs(s.x)<.01||f>MAX_DEPTH) break;
    f+=s.x;
    p=E+scp*f;
    s=inObj(p);
  }
  
  if (f<MAX_DEPTH){
    if (s.y==0.0)
      c=terrain_clr(p);

	  
    n=normalize(
      vec3(s.x-inObj(p-e.xyy).x,
           s.x-inObj(p-e.yxy).x,
           s.x-inObj(p-e.yyx).x));
    float b=dot(n,normalize(E-p));
	  
    gl_FragColor=vec4(b*c*(2.0-f*.01),1.0);//simple phong LightPosition=CameraPosition
  }
  else gl_FragColor=vec4(0.0,0.0,0.0,1); //background color
}  ]]></raw_data_ps>

</gpu_program>
  

  
  
	<script name="init_scene" run_mode="INIT" >
		<raw_data><![CDATA[	
    
winW, winH = gh_window.getsize()
   
font_a = gh_utils.font_create("Tahoma", 14)

camera = gh_camera.create_persp(60, 1.333, 0.1, 1000.0)
gh_camera.set_viewport(camera, 0, 0, winW, winH)
gh_camera.setpos(camera, 0, 0, 20)
gh_camera.setlookat(camera, 0, 0, 0)
gh_camera.setupvec(camera, 0, 1, 0, 0)

gpu_prog_01 = gh_node.getid("gpu_program")

mesh_quad = gh_mesh.create_quad(winW, winH)
gh_object.use_gl2_vertex_array(mesh_quad, 1) -- *** Old OpenGL... ***

gh_renderer.set_vsync(0)
gh_renderer.set_scissor_state(0)

		]]></raw_data>
	</script> 
  
	<script name="update_scene" run_mode="FRAME" >
		<raw_data><![CDATA[	

elapsed_time = gh_utils.get_elapsed_time()

gh_renderer.set_depth_test_state(1)

gh_camera.bind(camera)

gh_renderer.clear_color_depth_buffers(0.2, 0.2, 0.2, 1.0, 1.0)

gh_gpu_program.bind(gpu_prog_01)
gh_gpu_program.uniform1f(gpu_prog_01, "time", elapsed_time)
gh_gpu_program.uniform2f(gpu_prog_01, "resolution", winW, winH)
mouse_x, mouse_y = gh_input.mouse_getpos() 
gh_gpu_program.uniform2f(gpu_prog_01, "mouse", mouse_x, winH-mouse_y)

gh_object.render(mesh_quad)

gh_utils.font_render(font_a, 10, 20, 0.2, 1.0, 0.0, 1.0, "GLSL Hacker demo - GLSL Sandbox demo")

		]]></raw_data>
	</script> 
	

	<script name="resize_scene" run_mode="SIZE" >
		<raw_data><![CDATA[	

winW, winH = gh_window.getsize(0)

aspect = 1.333
if (winH > 0) then
  aspect = winW / winH
end  
gh_camera.update_persp(camera, 60, aspect, 0.1, 1000.0)
gh_camera.set_viewport(camera, 0, 0, winW, winH)

gh_utils.font_set_viewport_info(font_a, 0, 0, winW, winH)

gh_mesh.update_quad_size(mesh_quad, winW, winH)


		]]></raw_data>
	</script> 
  
  
</glsl_hacker>
